<!doctype html><html lang=en class=no-js><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=generator content="Hugo 0.83.0"><link rel=canonical type=text/html href=/docs/><meta name=ROBOTS content="NOINDEX, NOFOLLOW"><link rel="shortcut icon" href=/favicons/favicon.ico><link rel=apple-touch-icon href=/favicons/apple-touch-icon-180x180.png sizes=180x180><link rel=icon type=image/png href=/favicons/favicon-16x16.png sizes=16x16><link rel=icon type=image/png href=/favicons/favicon-32x32.png sizes=32x32><link rel=icon type=image/png href=/favicons/android-36x36.png sizes=36x36><link rel=icon type=image/png href=/favicons/android-48x48.png sizes=48x48><link rel=icon type=image/png href=/favicons/android-72x72.png sizes=72x72><link rel=icon type=image/png href=/favicons/android-96x96.png sizes=96x96><link rel=icon type=image/png href=/favicons/android-144x144.png sizes=144x144><link rel=icon type=image/png href=/favicons/android-192x192.png sizes=192x192><title>Workshop | Unikraft Summer of Code 2021</title><meta property="og:title" content="Workshop"><meta property="og:description" content="A free and virtual Unikernel and library Operating Systems workshop held by members of the Unikraft community"><meta property="og:type" content="website"><meta property="og:url" content="/docs/"><meta property="og:site_name" content="Unikraft Summer of Code 2021"><meta itemprop=name content="Workshop"><meta itemprop=description content="A free and virtual Unikernel and library Operating Systems workshop held by members of the Unikraft community"><meta name=twitter:card content="summary"><meta name=twitter:title content="Workshop"><meta name=twitter:description content="A free and virtual Unikernel and library Operating Systems workshop held by members of the Unikraft community"><link rel=preload href=/scss/main.min.1858cefeac68bf8654b05bceedf9634026955a53eb72683390eb36eb9c7a0dfc.css as=style><link href=/scss/main.min.1858cefeac68bf8654b05bceedf9634026955a53eb72683390eb36eb9c7a0dfc.css rel=stylesheet integrity><script src=https://code.jquery.com/jquery-3.5.1.min.js integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin=anonymous></script></head><body class=td-section><header><nav class="js-navbar-scroll navbar navbar-expand navbar-dark flex-column flex-md-row td-navbar"><a class=navbar-brand href=/><span class=navbar-logo><svg id="Layer_1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 500 500" style="enable-background:new 0 0 500 500"><g><path style="fill:#fff" d="M116.8525 421.9722c-5.7041.0-10.3442-4.3127-10.3442-9.6129V88.183c0-5.3002 4.6401-9.6117 10.3442-9.6117H320.858c3.0347.0 9.3959.5498 11.7506 2.6302l.3545.3442 58.905 63.2912c2.3101 2.491 2.9202 8.4928 2.9202 11.3184v256.2039c0 5.3002-4.6407 9.6129-10.3436 9.6129H116.8525z"/><g><g><g><path style="fill:#767676" d="M384.4445 423.2066H116.852c-6.3839.0-11.5786-4.8658-11.5786-10.8474V88.1831c0-5.9804 5.1947-10.8461 11.5786-10.8461h204.0062c.377.0 9.2786.0329 12.568 2.9389l.3947.3833 58.9508 63.337c3.2135 3.4652 3.2514 11.7924 3.2514 12.1593v256.2036C396.0231 418.3408 390.8284 423.2066 384.4445 423.2066zM116.5079 411.9189c.0848.0278.1999.0531.3441.0531h267.5925c.1442.0.2581-.0253.3441-.0531V156.1556c-.0076-.9033-.3593-3.7347-.7034-5.0037l-57.6527-61.9416c-1.4651-.3176-4.4533-.6389-5.5742-.6389H116.852c-.143.0-.2594.024-.3441.0531V411.9189zm267.4533-261.149zM327.0321 89.371v.0013V89.371z"/></g></g></g><g><g><path style="fill:#5b7fc0" d="M189.0874 210.1754l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4473C177.5953 212.627 183.0601 210.1742 189.0874 210.1754zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 234.1722 197.0804 232.033z"/><path style="opacity:.3;fill:#fff" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/><g><defs><path id="SVGID_1_" d="M194.7376 237.6875c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 234.2399 196.1861 236.239 194.7376 237.6875z"/></defs><clipPath id="SVGID_2_"><use xlink:href="#SVGID_1_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_2_);fill:#fff" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/><path style="opacity:.13;clip-path:url(#SVGID_2_);fill:#020202" d="M190.0704 225.0237c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 225.7247 191.9774 225.0237 190.0704 225.0237z"/></g><g><defs><path id="SVGID_3_" d="M189.0898 210.176c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 212.6276 183.0612 210.176 189.0898 210.176zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 236.239 197.0839 234.2399 197.0839 232.0372z"/></defs><clipPath id="SVGID_4_"><use xlink:href="#SVGID_3_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_4_);fill:#5b7fc0" d="M172.6595 215.6045c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8475-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 209.1953 176.6171 211.647 172.6595 215.6045z"/></g></g><rect x="198.8952" y="225.1043" style="fill:#5b7fc0" width="122.6266" height="13.8671"/></g><g><path style="fill:#d95140" d="M189.0874 155.7611l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.0249 2.454-11.4897 6.4116-15.4473C177.5953 158.2128 183.0601 155.7599 189.0874 155.7611zm7.993 21.8577c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.2508 181.7667 197.0816 179.758 197.0804 177.6188z"/><path style="opacity:.3;fill:#fff" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/><g><defs><path id="SVGID_5_" d="M194.7376 183.2733c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 179.8256 196.1861 181.8248 194.7376 183.2733z"/></defs><clipPath id="SVGID_6_"><use xlink:href="#SVGID_5_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_6_);fill:#fff" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/><path style="opacity:.13;clip-path:url(#SVGID_6_);fill:#020202" d="M190.0704 170.6095c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9546.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.663-2.8588-6.116.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C193.7885 171.3104 191.9774 170.6095 190.0704 170.6095z"/></g><g><defs><path id="SVGID_7_" d="M189.0898 155.7617c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8066-21.8612-21.8613.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 158.2134 183.0612 155.7617 189.0898 155.7617zm7.9941 21.8613c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 181.8248 197.0839 179.8256 197.0839 177.623z"/></defs><clipPath id="SVGID_8_"><use xlink:href="#SVGID_7_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_8_);fill:#d95140" d="M172.6595 161.1903c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 154.7811 176.6171 157.2327 172.6595 161.1903z"/></g><rect x="198.8952" y="170.69" style="fill:#d95140" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#56a55c" d="M189.5379 264.6147l.0012-.0012c7.7751.0012 15.0294 4.1862 18.932 10.9235 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3304-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032-5.8394.0-11.3281-2.2733-15.458-6.4032-4.13-4.13-6.4032-9.6186-6.4056-15.4628.0012-6.0249 2.454-11.4897 6.4116-15.4472C178.0458 267.0663 183.5105 264.6135 189.5379 264.6147zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6538 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403C196.7013 290.6202 197.5321 288.6115 197.5309 286.4723z"/><path style="opacity:.3;fill:#fff" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/><g><defs><path id="SVGID_9_" d="M195.1881 292.1268c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.9989 7.9942-7.9941 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.5344 288.6792 196.6366 290.6783 195.1881 292.1268z"/></defs><clipPath id="SVGID_10_"><use xlink:href="#SVGID_9_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_10_);fill:#fff" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/><path style="opacity:.13;clip-path:url(#SVGID_10_);fill:#020202" d="M190.5209 279.463c-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7446-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9941 2.3802-1e-4 4.616 1.0833 6.1218 2.8788C194.239 280.164 192.4279 279.463 190.5209 279.463z"/></g><g><defs><path id="SVGID_11_" d="M189.5403 264.6153c7.7763.0 15.0283 4.1826 18.926 10.9151 1.9201 3.3135 2.9377 7.0987 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8613-12.0547.0024-21.8636-9.8065-21.8612-21.8613.0-6.0285 2.4516-11.492 6.4116-15.452C178.0482 267.0669 183.5117 264.6153 189.5403 264.6153zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9941.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.6366 290.6783 197.5344 288.6792 197.5344 286.4765z"/></defs><clipPath id="SVGID_12_"><use xlink:href="#SVGID_11_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_12_);fill:#56a55c" d="M173.11 270.0439c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8613 12.0547.0024 21.8636-9.797 21.8613-21.8613.0024-3.8474-1.0151-7.6326-2.9353-10.9462-3.8977-6.7325-11.1497-10.9151-18.926-10.9151C182.5311 263.6346 177.0676 266.0863 173.11 270.0439z"/></g></g><rect x="199.3456" y="279.5436" style="fill:#56a55c" width="122.6266" height="13.8671"/></g><g><g><path style="fill:#f1bc42" d="M189.0874 318.7208l.0012-.0012c7.7751.0012 15.0295 4.1862 18.932 10.9234 1.9177 3.3159 2.9305 7.1011 2.9293 10.9378.0 5.8394-2.2733 11.3305-6.4032 15.4604-4.1288 4.1288-9.6186 6.4032-15.458 6.4032s-11.328-2.2733-15.458-6.4032-6.4032-9.6186-6.4056-15.4628c.0012-6.025 2.454-11.4897 6.4116-15.4472C177.5953 321.1724 183.0601 318.7196 189.0874 318.7208zm7.993 21.8576c.0012-1.4042-.3687-2.7868-1.063-3.9887-1.4293-2.4684-4.0833-3.9995-6.9299-4.0019-4.4077.0024-7.993 3.5877-7.993 7.993.0 2.1356.832 4.1431 2.3427 5.6539 1.5083 1.5083 3.5159 2.3403 5.6503 2.3415 2.1356.0 4.1443-.8308 5.6539-2.3403S197.0816 342.7176 197.0804 340.5784z"/><path style="opacity:.3;fill:#fff" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/><g><defs><path id="SVGID_13_" d="M194.7376 346.2329c-1.4461 1.4461-3.4452 2.3439-5.6479 2.3439-4.4077-.0024-7.9918-3.5865-7.9942-7.9942.0024-4.4125 3.5937-7.999 7.9942-7.9942 2.8443.0 5.497 1.5323 6.924 3.9983.6991 1.2067 1.0702 2.5881 1.0702 3.9959C197.0839 342.7853 196.1861 344.7844 194.7376 346.2329z"/></defs><clipPath id="SVGID_14_"><use xlink:href="#SVGID_13_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_14_);fill:#fff" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/><path style="opacity:.13;clip-path:url(#SVGID_14_);fill:#020202" d="M190.0704 333.5691c-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0011 1.9547.7088 3.7452 1.8782 5.1354-1.7447-1.4674-2.8575-3.6631-2.8588-6.1161.0024-4.4125 3.5936-7.999 7.9942-7.9942 2.3802-1e-4 4.616 1.0834 6.1218 2.8788C193.7885 334.2701 191.9774 333.5691 190.0704 333.5691z"/></g><g><defs><path id="SVGID_15_" d="M189.0898 318.7214c7.7763.0 15.0283 4.1826 18.926 10.915 1.9201 3.3136 2.9377 7.0988 2.9353 10.9462.0024 12.0643-9.8065 21.8636-21.8613 21.8612-12.0547.0024-21.8636-9.8065-21.8612-21.8612.0-6.0285 2.4516-11.4921 6.4116-15.452C177.5977 321.173 183.0612 318.7214 189.0898 318.7214zm7.9941 21.8612c0-1.4078-.3711-2.7892-1.0702-3.9959-1.4269-2.466-4.0797-3.9983-6.924-3.9983-4.4005-.0048-7.9918 3.5817-7.9942 7.9942.0024 4.4077 3.5865 7.9918 7.9942 7.9942 2.2027.0 4.2018-.8978 5.6479-2.3439C196.1861 344.7844 197.0839 342.7853 197.0839 340.5826z"/></defs><clipPath id="SVGID_16_"><use xlink:href="#SVGID_15_" style="overflow:visible"/></clipPath><path style="clip-path:url(#SVGID_16_);fill:#f1bc42" d="M172.6595 324.15c-3.96 3.96-6.4116 9.4235-6.4116 15.452-.0024 12.0547 9.8066 21.8636 21.8613 21.8612 12.0547.0024 21.8636-9.797 21.8613-21.8612.0024-3.8474-1.0151-7.6327-2.9353-10.9462-3.8977-6.7324-11.1497-10.9151-18.926-10.9151C182.0806 317.7407 176.6171 320.1924 172.6595 324.15z"/></g></g><rect x="198.8952" y="333.6497" style="fill:#f1bc42" width="122.6266" height="13.8671"/></g></g></svg></span><span class="text-uppercase font-weight-bold">Unikraft Summer of Code 2021</span></a><div class="td-navbar-nav-scroll ml-md-auto" id=main_navbar><ul class="navbar-nav mt-2 mt-lg-0"><li class="nav-item mr-4 mb-2 mb-lg-0"><a class="nav-link active" href=/docs/><span class=active>Workshop</span></a></li><li class="nav-item mr-4 mb-2 mb-lg-0"><a class=nav-link href=/community/><span>Community</span></a></li></ul></div><div class="navbar-nav d-none d-lg-block"><input type=search class="form-control td-search-input" placeholder="&#xf002 Search this site…" aria-label="Search this site…" autocomplete=off></div></nav></header><div class="container-fluid td-outer"><div class=td-main><div class="row flex-xl-nowrap"><div class="col-12 col-md-3 col-xl-2 td-sidebar d-print-none"></div><div class="d-none d-xl-block col-xl-2 td-toc d-print-none"></div><main class="col-12 col-md-9 col-xl-8 pl-md-5" role=main><div class=td-content><div class="pageinfo pageinfo-primary d-print-none"><p>This the multi-page printable view of this section.
<a href=# onclick="return print(),!1">Click here to print</a>.</p><p><a href=/docs/>Return to the regular view of this page</a>.</p></div><h1 class=title>Workshop</h1><ul><li>1: <a href=#pg-c1e6c515a3dcbb9929303d3518abd835>Schedule</a></li><li>2: <a href=#pg-7d93865f2930080c4fafcbee4584e6f4>People</a></li><li>3: <a href=#pg-5fe3cc3ea98bbc7c5e522eb003aa1f2a>Session 01: Baby Steps</a></li><li>4: <a href=#pg-a7aba59367c86f53527a038cb13a4d73>Session 02: Behind the Scenes</a></li><li>5: <a href=#pg-bcb4d0663368befcd015944d5552b25f>Session 03: Debugging in Unikraft</a></li><li>6: <a href=#pg-cbba34b6d1e7d9a0e83c791f84d7f29d>Session 04: Complex Applications</a></li><li>7: <a href=#pg-221c0eb25b4f393f30fd7c711495bed2>Session 05: Contributing to Unikraft</a></li><li>8: <a href=#pg-c8164d0e219bb0f24fd8b32fe7e996e3>Session 06: Testing Unikraft</a></li><li>9: <a href=#pg-e8257ea2e30401a82888d38de2231d40>Session 07: Syscall Shim</a></li><li>10: <a href=#pg-0cf305157c0d79c36b53cb269a783170>Session 08: Basic App Porting</a></li><li>11: <a href=#pg-f352576afa36c9b30f15b2be6533c580>Session 09: Advanced App Porting</a></li><li>12: <a href=#pg-9026b735a1faa018402aa9ac7ce1ebd9>Session 10: High Performance</a></li></ul><div class=content><div class="alert alert-primary" role=alert><h4 class=alert-heading>Deadline for applications to the workshop has ended</h4>The application deadline was <strong>July 26, 2021, 11pm CEST</strong> and has now passed.
Fear not! We will be making all the material free as the workshop progresses so
you can follow along. All technical talks will be live streamed recorded and
all workshops will be recorded. We will post links to relevant content in due
course.</div><p><em>This website site contains information, documentation, timetables, and more for
participants of the Unikraft Summer of Code 2021 (USoC21). If you are not
participating in USoC21 feel free to use this site and its resources to learn
how to build Unikraft unikernels.</em></p><p>Unikraft Summer of Code is a <strong>free</strong> two week virtual Unikernel and library
Operating Systems workshop held by members of the Unikraft community including
professors, lecturers, PhD and MSci students from:</p><ul><li><a href=http://nets.cs.pub.ro>University POLITEHNICA of Bucharest</a>,</li><li><a href=https://net.scc.lancs.ac.uk>Lancaster University</a>,</li><li><a href=https://www.uliege.be/cms/c_8699436/en/uliege>University of Liège</a>,</li><li><a href=https://www.cs.manchester.ac.uk/research/expertise/advanced-processor-technologies/>Manchester University</a>, and</li><li>industry partners <a href=http://sysml.neclab.eu>NEC Laboratories Europe GmbH</a>.</li></ul><p>To learn more about Unikraft, please visit the <a href=https://unikraft.org>Unikraft Project
Website</a>, visit the <a href=http://docs.unikraft.org>main documentation website</a> or checkout the <a href=https://github.com/unikraft/unikraft>GitHub project</a>.</p><p>In this workshop, you will learn about how to build Unikraft unikernels,
including zero-to-hero workshops on how to get started using Unikraft. As the
week progresses, we will dive into more in-depth topics of Unikraft, including
programming structures and architectures, how it is organized, methodologies for
porting libraries and applications to Unikraft and more!</p><p>The workshop will be hands-on and will take place for 10 days, between August 23
and September 3, 2021, 4pm-8pm CEST. And an 8 hours hackathon on September 4,
2021, 9am-5pm CEST. It will be online and in English. Topics include building
unikernels, benchmarking, debugging, porting applications, virtualization and
platform specifics.</p><p><em>USoC21 and Unikraft are supported by the <a href=https://unicore-project.eu/>UNICORE Project</a>, EU Horizon 2020 grant agreement No 825377.</em></p></div></div><div class=td-content style=page-break-before:always><h1 id=pg-c1e6c515a3dcbb9929303d3518abd835>1 - Schedule</h1><p>Unikraft Summer of Code 2021 (USoC'21) consists of 10 sessions in 10 days and a hackathon.
Each session is 4 hours long and consists of practical demos and then exercises for participants.
The hackathon is an 8 hours event where you&rsquo;ll have different tasks to enable, test, fix, evaluate and improve applications and libraries with Unikraft.</p><p>The complete schedule for USoC'21 is (all times in CEST - Central European Summer Time):</p><table><thead><tr><th>Date</th><th>Interval</th><th>Activity</th><th>TA(s)</th></tr></thead><tbody><tr><td>Mon, 23.08.2021</td><td>3:30pm-4pm<br>4pm-8pm</td><td>Opening Ceremony<br><a href=/docs/sessions/01-baby-steps/ title="01. Baby Steps">Session 01: Baby Steps</a></td><td>RazvanD, Alex, CristiV<br>Alex, CristiV, Vlad</td></tr><tr><td>Tue, 24.08.2021</td><td>4pm-8pm</td><td><a href=/docs/sessions/02-behind-scenes/ title="02. Behind the Scenes">Session 02: Behind the Scenes</a></td><td>RazvanD, Costi</td></tr><tr><td>Wed, 25.08.2021</td><td>4pm-4:30pm<br>4:30pm-8pm</td><td>Tech Talk: Debugging and Tracing in Unikraft<br><a href=/docs/sessions/03-debugging/ title="03. Debugging in Unikraft">Session 03: Debugging in Unikraft</a></td><td>Simon<br>CristiV, RazvanD</td></tr><tr><td>Thu, 26.08.2021</td><td>4pm-8pm</td><td><a href=/docs/sessions/04-complex-applications/ title="04. Complex Applications">Session 04: Complex Applications</a></td><td>Costi, Vlad</td></tr><tr><td>Fri, 27.08.2021</td><td>4pm-4:30pm<br>4:30pm-8pm</td><td>Tech Talk: Virtual Memory in Unikraft<br><a href=/docs/sessions/05-contributing-to-unikraft/ title="05. Contributing to Unikraft">Session 05: Contributing to Unikraft</a></td><td>Ștefan<br>Vlad, RazvanD</td></tr><tr><td>Mon, 30.08.2021</td><td>4pm-8pm</td><td><a href=/docs/sessions/06-testing-unikraft/ title="06. Testing Unikraft">Session 06: Testing Unikraft</a></td><td>CristiB, Alex</td></tr><tr><td>Tue, 31.08.2021</td><td>4pm-4:30pm<br>4:30pm-8pm</td><td>Tech Talk: Memory Deduplication with Unikraft<br><a href=/docs/sessions/07-syscall-shim/ title="07. Syscall Shim">Session 07: Syscall Shim</a></td><td>Gaulthier<br>RazvanD, Alex</td></tr><tr><td>Wed, 01.09.2021</td><td>4pm-8pm</td><td><a href=/docs/sessions/08-basic-app-porting/ title="08. Basic App Porting">Session 08: Basic App Porting</a></td><td>Cezar, RazvanD</td></tr><tr><td>Thu, 02.09.2021</td><td>4pm-4:30pm<br>4:30pm-8pm</td><td>Tech Talk: Retrofitting Isolation into Unikraft with FlexOS<br><a href=/docs/sessions/09-advanced-app-porting/ title="09. Advanced App Porting">Session 09: Advanced App Porting</a></td><td>Hugo<br>Vlad, Cezar</td></tr><tr><td>Fri, 03.09.2021</td><td>4pm-8pm</td><td><a href=/docs/sessions/10-high-performance/ title="10. High Performance">Session 10: High Performance</a></td><td>Alex, RazvanD</td></tr><tr><td>Sat, 04.09.2021</td><td>9am-5pm</td><td>Hackathon</td><td>Dragoș, Gabi, Sergiu, Florin<br>Laurențiu, Cătălin, Vlad, Alex</td></tr></tbody></table></div><div class=td-content style=page-break-before:always><h1 id=pg-7d93865f2930080c4fafcbee4584e6f4>2 - People</h1><h3 id=program-chairs-and-project-coordinators>Program Chairs and Project Coordinators</h3><table><thead><tr><th>Name</th><th>Organization</th><th>Email</th></tr></thead><tbody><tr><td><a href=https://github.com/razvand>Răzvan Deaconescu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>razvan.deaconescu@cs.pub.ro</code></td></tr><tr><td><a href=https://github.com/nderjung>Alexander Jung</a></td><td>Lancaster University</td><td><code>a.jung@lancs.ac.uk</code></td></tr><tr><td><a href=https://github.com/skuenzer>Simon Kuenzer</a></td><td>NEC Laboratories Europe GmbH</td><td><code>simon.kuenzer@neclabs.eu</code></td></tr></tbody></table><h3 id=teaching-assistants-tas>Teaching Assistants (TAs)</h3><p>You&rsquo;ll see these kind people during the workshop to help answer questions and
work through problems.</p><table><thead><tr><th>Name</th><th>Organization</th><th>Email</th></tr></thead><tbody><tr><td><a href=https://github.com/dragosargint>Argint Dragos Iulian</a></td><td>University POLITEHNICA of Bucharest</td><td><code>dragosargint21@gmail.com</code></td></tr><tr><td><a href=https://github.com/CatalinPuscoci>Cătălin Pușcoci</a></td><td>University POLITEHNICA of Bucharest</td><td><code>catalinpuscoci@protonmail.com</code></td></tr><tr><td><a href=https://github.com/craciunoiuc>Cezar Craciunoiu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>cezar.craciunoiu@gmail.com</code></td></tr><tr><td><a href=https://github.com/consra>Constantin Raducanu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>raducanu.costi@gmail.com</code></td></tr><tr><td><a href=https://github.com/cristian-vijelie>Cristian Vijelie</a></td><td>University POLITEHNICA of Bucharest</td><td><code>cristianvijelie@gmail.com</code></td></tr><tr><td><a href=https://github.com/danield20>Daniel Dinca</a></td><td>University POLITEHNICA of Bucharest</td><td><code>dincadaniel97@gmail.com</code></td></tr><tr><td><a href=https://github.com/florin-diaconescu>Florin Diaconescu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>florin.diaconescu@protonmail.com</code></td></tr><tr><td><a href=https://github.com/laurbrb>Laurentiu Barbulescu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>lrbarbulescu@gmail.com</code></td></tr><tr><td><a href=https://github.com/CristiBM>Marius Cristian Baciu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>2309bmcristi@gmail.com</code></td></tr><tr><td><a href=https://github.com/gabrielmocanu>Mocanu Viorel Gabriel</a></td><td>University POLITEHNICA of Bucharest</td><td><code>gabi.mocanu98@gmail.com</code></td></tr><tr><td><a href=https://github.com/ungps>Paul Ungureanu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>ungureanupaulsebastian@gmail.com</code></td></tr><tr><td><a href=https://github.com/razvanvirtan>Răzvan Virtan</a></td><td>University POLITEHNICA of Bucharest</td><td><code>virtanrazvan@gmail.com</code></td></tr><tr><td><a href=https://github.com/mogasergiu>Sergiu Moga</a></td><td>University POLITEHNICA of Bucharest</td><td><code>sergiu.moga@protonmail.com</code></td></tr><tr><td><a href=https://github.com/vladandrew>Vlad-Andrei Badoiu</a></td><td>University POLITEHNICA of Bucharest</td><td><code>vlad_andrei.badoiu@upb.ro</code></td></tr></tbody></table><div class="alert alert-primary" role=alert><h4 class=alert-heading>Contact</h4>The fastest way to get in contact with anyone in this workshop regarding the
workshop is to join the <a href=https://bit.ly/UnikraftDiscord>Unikraft Community Discord</a>.</div></div><div class=td-content style=page-break-before:always><h1 id=pg-5fe3cc3ea98bbc7c5e522eb003aa1f2a>3 - Session 01: Baby Steps</h1><p>In this session we are going to understand the basic layout of the Unikraft working directory, its environment variables, as well as what the most common Unikraft specific files mean.
We are also going to take a look at how we can build basic applications and how we can extend their functionality and support by adding ported external libraries.</p><p>Before everything, let&rsquo;s take a bird&rsquo;s eye view of what Unikraft is and what we can do with it.
Unikraft is a unikernel SDK, meaning it offers you the blocks (source code, configuration and build system, runtime support) to build and run unikernels.
A unikernel is a single image file that can be loaded and run as a separate running instance, most often a virtual machine.</p><p>Summarily, Unikraft components are shown in the image below:</p><p><img src=/docs/sessions/01-baby-steps/images/unikraft_components.png alt="arch selection menu"></p><p>Unikraft is the core component, consisting of core / internal libraries, the build system, and platform and architecture code.
It is the basis of any unikernel image.
It is located in the <a href=https://github.com/unikraft/unikraft>main Unikraft repository</a>.</p><p>Libraries are additional software components that will be linked with Unikraft for the final image.
There are multiple supported libraries.
Each unikernel image is using its specific libraries.
Libraries are also called <strong>external</strong> libraries as they sit outside the main Unikraft repository.
Libraries are typically common libraries (such as OpenSSL or LWIP) that have been ported on top of Unikraft.
They are located in specialized repositories in the <a href=https://github.com/unikraft/>Unikraft organization</a>, those whose names start with <code>lib-</code>.</p><p>Application is the actual application code.
It typically provides the <code>main()</code> function (or equivalent) and is reliant on Unikraft and external libraries.
Applications that have been ported on top of Unikraft are located in repositories in the <a href=https://github.com/unikraft/>Unikraft organization</a>, those whose names start with <code>app-</code>.</p><p>An important role of the core Unikraft component is providing support for different platforms and architectures.
A platform is the virtualization / runtime environment used to run the resulting unikernel image.
An architecture details the CPU and memory specifics that will run the resulting image.</p><p>As this is a rather complicated setup, a companion tool (<a href=https://github.com/unikraft/kraft>kraft</a>) was designed and implemented to provide the interface for configuring, building and running unikernel images based on Unikraft.
The recommended way of building and running Unikraft is via <code>kraft</code>.</p><p>We are going to build the <a href=https://github.com/unikraft/app-helloworld>helloworld</a> application and the <a href=https://github.com/unikraft/app-httpreply>httpreply</a> application using <code>kraft</code>.
We are also going to use the lower-level configuration and build system (based on <a href=https://www.kernel.org/doc/html/latest/kbuild/kconfig-language.html>Kconfig</a> and Makefile) to get a grasp of how everything works.
The lower-level system will be detailed further in session 02: Behind the Scenes.</p><h2 id=demos>Demos</h2><h3 id=00-manual-kraft-installation>00. Manual kraft Installation</h3><p>Let&rsquo;s start with installing kraft (and validating the installation).</p><p>First of all, make sure you have all the dependencies installed:</p><pre><code>$ sudo apt-get install -y --no-install-recommends build-essential \
        libncurses-dev libyaml-dev flex git wget socat bison \
        unzip uuid-runtime
</code></pre><p>We begin by cloning the kraft repository on our machine:</p><pre><code>git clone https://github.com/unikraft/kraft.git
</code></pre><p>Now, all we have to do is enter this directory and run the setup installer:</p><pre><code>$ cd kraft
$ pip install --user -e .
</code></pre><p>This will install kraft for the local user.</p><p>After installing or updating kraft, the first step is to download / update the software components available for building unikernel images.
For this, run:</p><pre><code>$ kraft list update
</code></pre><p>It&rsquo;s very likely that running the command above will result in the following error:</p><pre><code>GitHub rate limit exceeded.  You can tell kraft to use a personal access token by setting the UK_KRAFT_GITHUB_TOKEN environmental variable.
</code></pre><p>If this is the case, first create a GitHub personal access token by following <a href=https://docs.github.com/en/github/authenticating-to-github/keeping-your-account-and-data-secure/creating-a-personal-access-token>these instructions</a>.
Then, use the following command:</p><pre><code>$ UK_KRAFT_GITHUB_TOKEN=&lt;your_GitHub_token_here&gt; kraft list update
</code></pre><p>After this is done, you can get a list of all components that are available for use with kraft:</p><pre><code>$ kraft list
UNIKRAFT        	VERSION 	RELEASED    	LAST CHECKED
unikraft        	0.5     	17 hours ago	18 Aug 21

PLATFORMS       	VERSION 	RELEASED    	LAST CHECKED
solo5           	0.5     	13 Jul 21   	18 Aug 21
[...]

LIBRARIES       	VERSION 	RELEASED    	LAST CHECKED
newlib          	0.5     	5 days ago  	18 Aug 21
pthreadpool     	0.5     	7 days ago  	18 Aug 21
lwip            	0.5     	6 days ago  	18 Aug 21
[...]

APPLICATIONS    	VERSION 	RELEASED    	LAST CHECKED
python3         	0.4     	29 Mar 21   	18 Aug 21
helloworld      	0.5     	29 Mar 21   	18 Aug 21
httpreply       	0.5     	13 Jul 21   	18 Aug 21
[...]
</code></pre><p>So, with kraft we have an interface to configure, build and run unikernel images based on Unikraft core, (external) platforms, (external) libraries and applications.</p><p>By default, these are saved to <code>~/.unikraft/</code> directory, which is also the value of the <code>UK_WORKDIR</code> environment variable used by kraft.
This represents the working directory for all Unikraft components.
This is the usual layout of the <code>~/.unikraft/</code> directory:</p><pre><code>|-- apps - This is where you would normally place existing app build
|-- archs - Here we place our custom arch's files
|-- libs - This is where the build system looks for external library pool sources
|-- plats - The files for our custom plats are placed here
`-- unikraft - The core source code of the Unikraft Unikernel
</code></pre><p>Apart from the general <code>UK_WORKDIR</code> environment variable that points to the overall directory, there are also environment variables available for the above subdirectories:</p><pre><code>UK_ROOT - The directory for Unikraft's core source code [default: $UK_WORKDIR/unikraft]
UK_LIBS - The directory of all the external Unikraft libraries [default: $UK_WORKDIR/libs]
UK_APPS - The directory of all the template applications [default: $UK_WORKDIR/apps]
</code></pre><p>After successfully running the above commands, kraft is now installed on our system and we can get to building and running unikernels.</p><h3 id=01-building-and-running-the-helloworld-application>01. Building and Running the Helloworld Application</h3><p>This is where the fun part begins - we get to build our first unikernel.</p><h4 id=one-command-to-rule-them-all>One Command to Rule Them All</h4><p>kraft makes it easy to download, configure, build existing components into unikernel images and then run those images.
The <code>kraft up</code> command makes it easy to do that with one swoop.
Let&rsquo;s do that for the <code>helloworld</code> application (listed with <code>kraft list</code>):</p><pre><code>$ kraft up -t helloworld hello
 100.00% :::::::::::::::::::::::::::::::::::::::: |       21 /       21 |:  app/helloworld@0.5
[INFO    ] Initialized new unikraft application: /home/razvan/hello
make: Entering directory '/home/razvan/.unikraft/unikraft'
[...]
#
# configuration written to /home/razvan/hello/.config
#
[...]
CC      libkvmplat: trace.common.o
CC      libkvmplat: traps.isr.o
CC      libkvmplat: cpu_features.common.o
[...]
CC      libnolibc: errno.o
CC      libnolibc: stdio.o
CC      libnolibc: ctype.o
[...]
LD      hello_kvm-x86_64.ld.o
OBJCOPY hello_kvm-x86_64.o
LD      hello_kvm-x86_64.dbg
SCSTRIP hello_kvm-x86_64
GZ      hello_kvm-x86_64.gz
LN      hello_kvm-x86_64.dbg.gdb.py
[...]
Successfully built unikernels:

  =&gt; build/hello_kvm-x86_64
  =&gt; build/hello_kvm-x86_64.dbg (with symbols)

[...]
To instantiate, use: kraft run
[...]
Starting VM...
[...]
                   Tethys 0.5.0~b8be82b
Hello world!
Arguments:  &quot;/home/razvan/hello/build/hello_kvm-x86_64&quot; &quot;console=ttyS0&quot;
</code></pre><p>In the snippet above, we selected parts of the output showing what <code>kraft</code> does behind the scenes:</p><ol><li>It downloads the <code>helloworld</code> application repository in the <code>hello/</code> directory.</li><li>It configures the repository, resulting in a <code>.config</code> file.</li><li>It builds the required components, resulting in the <code>build/hello_kvm-x86_64</code> unikernel image.</li><li>It runs the image, resulting in QEMU/KVM being run, with the &ldquo;Hello world!&rdquo; message getting printed.</li></ol><p>All that magic is done using one command.</p><p>A closer inspection of the <code>hello/</code> folder reveals it is a clone of the <a href=https://github.com/unikraft/app-helloworld>app-helloworld repository</a> and it stores the resulting configuration file (<code>.config</code>) and resulting build folder (and images) (<code>build/</code>):</p><pre><code>$ ls -Fa hello/
./  ../  build/  CODING_STYLE.md  .config  Config.uk  CONTRIBUTING.md  COPYING.md  .git/  kraft.yaml  main.c  MAINTAINERS.md  Makefile  Makefile.uk  monkey.h  README.md
</code></pre><p>Once this is done, we can now run the resulting unikernel image any time we want by simply using <code>kraft run</code>:</p><pre><code>$ cd hello/
$ kraft run
[...]
                   Tethys 0.5.0~b8be82b
Hello world!
Arguments:  &quot;/home/razvan/hello/build/hello_kvm-x86_64&quot; &quot;console=ttyS0&quot;
</code></pre><h4 id=doing-it-step-by-step-using-kraft>Doing it Step-by-Step Using kraft</h4><p>The above <code>kraft up</code> command seems like magic and it&rsquo;s not very clear what&rsquo;s really happening.
Let&rsquo;s break that down into subcommands and really get a good grip of the configure, build and run process.</p><p>We will go through the same steps above, running a separate command for each step:</p><ol><li>Download / Initialize the helloworld appplication.</li><li>Configure the application, resulting in a <code>.config</code> file.</li><li>Build the required components, resulting in the <code>build/hello_kvm-x86_64</code> unikernel image.</li><li>Run the image, with the &ldquo;Hello world!&rdquo; message getting printed.</li></ol><h5 id=initialize>Initialize</h5><p>First, let&rsquo;s create a directory that will host the application.
We enter the <code>demo/</code> directory of the current session and we create the <code>01-hello-world/</code> directory:</p><pre><code>$ cd demo/
$ mkdir 01-hello-world
$ cd 01-hello-world/
</code></pre><p>Now, we initialize the application by using the template for the helloworld app and see that it&rsquo;s populated with files belonging to the app:</p><pre><code>$ kraft init -t helloworld
$ ls
CODING_STYLE.md  Config.uk  CONTRIBUTING.md  COPYING.md  kraft.yaml  main.c  MAINTAINERS.md  Makefile  Makefile.uk  monkey.h  README.md
</code></pre><p>The <code>kraft.yaml</code> file is the most important file.
It stores kraft-speficic configuration for the app and it&rsquo;s used by kraft when configuring, building and running the application.
Other files are important as well, but they are used behind the scenes by kraft.
We will detail them later in the session and in session 02: Behind the Scenes.</p><h5 id=configure>Configure</h5><p>A unikernel image may be targeted for multiple platforms and architectures.
The available platforms and applications are listed in the <code>kraft.yaml</code> file:</p><pre><code>$ cat kraft.yaml
specification: '0.4'

unikraft: '0.5'

architectures:
  x86_64: true
  arm64: true

platforms:
  linuxu: true
  kvm: true
  xen: true
</code></pre><p>In our case, we can target the <code>x86_64</code> or <code>arm64</code> architectures.
And we can target <code>linuxu</code>, <code>kvm</code> or <code>xen</code> platforms.</p><p>The simplest way to select the platform and architecture is by running <code>kraft configure</code> and then interactively use arrow keys to select the desired option:</p><pre><code>$ kraft configure
[?] Which target would you like to configure?: 01-hello-world_linuxu-x86_64
 &gt; 01-hello-world_linuxu-x86_64
   01-hello-world_kvm-x86_64
   01-hello-world_xen-x86_64
   01-hello-world_linuxu-arm64
   01-hello-world_kvm-arm64
   01-hello-world_xen-arm64
</code></pre><p>We have 6 options (2 architectures x 3 platforms).
Once we select one, the configuration will be updated.</p><p>The alternate way (non-interactive) is to pass arguments to <code>kraft configure</code> to select the desired platform and architecture.
For example, if we want to use x86_64 and KVM, we use:</p><pre><code>$ kraft configure -p kvm -m x86_64
</code></pre><h5 id=build>Build</h5><p>Everything is set up now, all we have left to do is tell the build system to do its magic:</p><pre><code>$ kraft build
[...]
Successfully built unikernels:

  =&gt; build/01-hello-world_kvm-x86_64
  =&gt; build/01-hello-world_kvm-x86_64.dbg (with symbols)

To instantiate, use: kraft run
</code></pre><p>This results in the creation of two unikernel image files:</p><ol><li><code>build/01-hello-world_kvm-x86_64</code> - the main image file</li><li><code>build/01-hello-world_kvm-x86_64.dbg</code> - the image file with debug information (useful for debugging, duh!)</li></ol><p>And that&rsquo;s it! Our final unikernel binary is ready to be launched from the <code>build/</code> directory.</p><h5 id=run>Run</h5><p>To run an already-built unikernel image, we use <code>kraft run</code>:</p><pre><code>$ kraft run
[...]

                   Tethys 0.5.0~b8be82b
Hello world!
[...]
</code></pre><p>If we want to be more specific, we could use:</p><pre><code>$ kraft run -p kvm -m x86_64
</code></pre><p>This command is useful in the case we have multiple images built (for differing platforms and architectures).
We can then select which one to run.</p><p>For example, we can use the commands below to configure, build and run a helloworld image for the <code>linuxu</code> platform.</p><pre><code>kraft configure -p linuxu -m x86_64
kraft build
kraft run -p linuxu -m x86_64
</code></pre><p>You can now alter between running the <code>linuxu</code> and the <code>kvm</code> built images by using <code>kraft run</code> with the appropriate arguments.</p><h4 id=more-on-kraft>More on kraft</h4><p>Of course, this is the most basic way you can use <code>kraft</code>, but there are many other options.
To see every option <code>kraft</code> has to offer, you can simply type <code>kraft -h</code>.
If you want to know about a certain command, just follow it with the <code>-h</code> option.
For example, if I wanted to know more about the configure command, I would type <code>kraft configure -h</code>.</p><h4 id=manually-building-the-helloworld-application>Manually Building the helloworld Application</h4><p>Let&rsquo;s now learn how to build the app manually, without <code>kraft</code>.
We won&rsquo;t go into too much detail, this will be handled more thoroughly in session 02: Behind the Scenes.</p><p>The manual approach is more complicated (albeit giving you potentially more control) than kraft.
For most of the use cases (development, testing, evaluating, using) of Unikraft, we recommend you use kraft.</p><p>We will go through the same steps as above:</p><ol><li>Download / Initialize the helloworld application.</li><li>Configure the application, resulting in a <code>.config</code> file.</li><li>Build the required components, resulting in the <code>build/hello_kvm-x86_64</code> unikernel image.</li><li>Run the image, with the &ldquo;Hello world!&rdquo; message getting printed.</li></ol><h5 id=initialize-1>Initialize</h5><p>First, get out of the current build&rsquo;s directory and make a new one:</p><pre><code>$ cd ../ &amp;&amp; mkdir 01-hello-world-manual &amp;&amp; cd 01-hello-world-manual
</code></pre><p>Now, clone the remote Git repository:</p><pre><code>$ git clone https://github.com/unikraft/app-helloworld.git .
$ ls
CODING_STYLE.md  Config.uk  CONTRIBUTING.md  COPYING.md  kraft.yaml  main.c  MAINTAINERS.md  Makefile  Makefile.uk  monkey.h  README.md
</code></pre><h5 id=configure-1>Configure</h5><p>To configure the build process (and the resulting unikernel image) we access a text-user interface menu by using:</p><pre><code>$ make menuconfig
</code></pre><p>Looks like we are met with an error:</p><pre><code>$ make menuconfig
Makefile:9: recipe for target 'menuconfig' failed
make: *** [menuconfig] Error 2
</code></pre><p>We look in the <code>Makefile</code>:</p><pre><code>$ cat -n Makefile
     1  UK_ROOT ?= $(PWD)/../../unikraft
     2  UK_LIBS ?= $(PWD)/../../libs
     3  LIBS :=
     4
     5  all:
     6          @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)
     7
     8  $(MAKECMDGOALS):
     9          @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre><p>The underlying build / configuration system expects the Unikernel (<code>UK_ROOT</code>) to be located at <code>../../unikraft</code> from the current directory, which is very likely not the case.
Recall that the build system makes use of some important environment variables, namely <code>UK_WORKDIR</code>, <code>UK_ROOT</code> and <code>UK_LIBS</code>.
So, in order to properly inform the build system of our current location, we will have to manually set these by prefixing whatever build command we send with the hardcoded values of where our <code>Unikraft</code> work directory is.</p><pre><code>$ UK_WORKDIR=~/.unikraft UK_ROOT=~/.unikraft/unikraft UK_LIBS=~/.unikraft/libs make menuconfig
</code></pre><p><strong>Note</strong>: This menu is also available through the <code>kraft menuconfig</code> command, which rids you of the hassle of manually setting the environment variables.</p><p>We are met with the following configuration menu. Let&rsquo;s pick the architecture:</p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_arch.png alt="arch selection menu"></p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_arch2.png alt="arch selection menu2"></p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_arch3.png alt="arch selection menu3"></p><p>Now, press <code>Exit</code> (or hit the <code>Esc</code> key twice) until you return to the initial menu.</p><p>We have now set our desired architecture, let&rsquo;s now proceed with the platform.
We will choose both <code>linuxu</code> and <code>kvm</code>:</p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_plat.png alt="plat selection menu"></p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_plat2.png alt="plat selection menu2"></p><p><code>Save</code> and exit the configuration menu by repeatedly selecting <code>Exit</code>.</p><h5 id=build-1>Build</h5><p>Now let&rsquo;s build the final image (recall the environment variables):</p><pre><code>$ UK_WORKDIR=~/.unikraft UK_ROOT=~/.unikraft/unikraft UK_LIBS=~/.unikraft/libs  make
[...]
  LD      01-hello-world-manual_linuxu-x86_64.dbg
  SCSTRIP 01-hello-world-manual_kvm-x86_64
  GZ      01-hello-world-manual_kvm-x86_64.gz
  SCSTRIP 01-hello-world-manual_linuxu-x86_64
  LN      01-hello-world-manual_kvm-x86_64.dbg.gdb.py
  LN      01-hello-world-manual_linuxu-x86_64.dbg.gdb.py
</code></pre><p>Our final binaries are located inside the <code>build/</code> directory.</p><h5 id=run-1>Run</h5><p>Let&rsquo;s run the <code>linuxu</code> image by doing a Linux-like executable running:</p><pre><code>$ ./build/01-hello-world-manual_linuxu-x86_64  # The linuxu image
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Hello world!
</code></pre><p>To run the KVM image, we use the <code>qemu-system-x86_64</code> command:</p><pre><code>$ qemu-system-x86_64 -kernel build/01-hello-world-manual_kvm-x86_64 -nographic
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Hello world!
Arguments:  &quot;build/hello_kvm-x86_64&quot;
</code></pre><h3 id=02-building-and-running-the-httpreply-application>02. Building and Running the httpreply Application</h3><p>This is where we will take a look at how to build a basic HTTP Server both through <code>kraft</code> and manually.
The latter involves understanding how to integrate ported external libraries, such as <code>lwip</code>.</p><h4 id=using-kraft>Using kraft</h4><p>Just as before, let&rsquo;s create a directory that will host the application.
We enter the <code>demo/</code> directory of the current session and we create the <code>01-hello-world/</code> directory:</p><pre><code>$ cd demo/
$ mkdir 02-httpreply
$ cd 02-httpreply/
</code></pre><p>Now, we go through the steps above.</p><h5 id=initialize-2>Initialize</h5><p>Retrieve the already existing template for <code>httpreply</code>:</p><pre><code>$ kraft init -t httpreply
</code></pre><h5 id=configure-2>Configure</h5><p>Configure the building of a KVM unikernel image for x86_64:</p><pre><code>$ kraft configure -p kvm -m x86_64
</code></pre><h5 id=build-2>Build</h5><pre><code>$ kraft build
</code></pre><h5 id=run-2>Run</h5><pre><code>$ kraft run -p kvm -m x86_64
[...]
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
</code></pre><p>Use <code>Ctrl+c</code> to stop the HTTP server running as a unikernel virtual machine.</p><h5 id=connecting-to-the-http-server>Connecting to the HTTP Server</h5><p>The server listens on port <code>8123</code> but we can&rsquo;t access it, as the virtual machine doesn&rsquo;t have a (virtual) network connection to the host system and it doesn&rsquo;t have an IP address.
So we have to create a connection and assign an IP address.</p><p>We use a virtual bridge to create a connection between the VM and the host system.
We assign address <code>172.44.0.1/24</code> to the bridge interface (pointing to the host) and we assign address <code>172.44.0.2/24</code> to the virtual machine, by passing boot arguments.</p><p>We run the commands below to create and assign the IP address to the bridge <code>virbr0</code>:</p><pre><code>$ sudo brctl addbr virbr0
$ sudo ip a a  172.44.0.1/24 dev virbr0
$ sudo ip l set dev virbr0 up
</code></pre><p>We can check the proper configuration:</p><pre><code>$ ip a s virbr0
420: virbr0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc noqueue state UNKNOWN group default qlen 1000
    link/ether 3a:3e:88:e6:a1:e4 brd ff:ff:ff:ff:ff:ff
    inet 172.44.0.1/24 scope global virbr0
       valid_lft forever preferred_lft forever
    inet6 fe80::383e:88ff:fee6:a1e4/64 scope link
       valid_lft forever preferred_lft forever
</code></pre><p>Now we start the virtual machine and pass it the proper arguments to assign the IP address <code>172.44.0.2/24</code>:</p><pre><code>$ kraft run -b virbr0 &quot;netdev.ipv4_addr=172.44.0.2 netdev.ipv4_gw_addr=172.44.0.1 netdev.ipv4_subnet_mask=255.255.255.0 --&quot;
[...]
0: Set IPv4 address 172.44.0.2 mask 255.255.255.0 gw 172.44.0.1
en0: Added
en0: Interface is up
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
</code></pre><p>The boot message confirms the assigning of the <code>172.44.0.2/24</code> IP address to the virtual machine.
It&rsquo;s listening on port 8123 for HTTP connections on that IP address.
We use <code>wget</code> to validate it&rsquo;s working properly and we are able to get the <code>index.html</code> file:</p><pre><code>$ wget 172.44.0.2:8123
--2021-08-18 16:47:38--  http://172.44.0.2:8123/
Connecting to 172.44.0.2:8123... connected.
HTTP request sent, awaiting response... 200 OK
[...]
2021-08-18 16:47:38 (41.5 MB/s) - ‘index.html’ saved [160]
</code></pre><p>Cleaning up means closing the virtual machine (and the HTTP server) and disabling and deleting the bridge interface:</p><pre><code>$ sudo ip l set dev virbr0 down
$ sudo brctl delbr virbr0
</code></pre><h4 id=the-manual-way>The Manual Way</h4><h5 id=initialize-3>Initialize</h5><p>First, move into a new directory and clone the <code>httpreply</code> repo there.</p><pre><code>$ cd .. &amp;&amp; mkdir 02-httpreply-manual &amp;&amp; cd 02-httpreply-manual
$ git clone https://github.com/unikraft/app-httpreply .
</code></pre><h5 id=adding-a-makefile>Adding a Makefile</h5><p>Unlike before, you can notice that this time we are missing the regular <code>Makefile</code>.
Let&rsquo;s start by copying the <code>Makefile</code> from helloworld:</p><pre><code>$ cp ../01-hello-world/Makefile .
</code></pre><p>This is how it looks like:</p><pre><code>$ cat Makefile
UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
LIBS :=

all:
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre><p>As you can see, the previously presented environment values make the same wrong assumption.
Previously, we fixed this by preceding the <code>make</code> command with the updated values for the environment variables, but we could have also simply modified them from within the <code>Makefile</code>, like so:</p><pre><code>UK_ROOT ?= $(HOME)/.unikraft/unikraft
UK_LIBS ?= $(HOME)/.unikraft/libs
LIBS :=


	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre><p>For the HTTP server, however, we need the <code>lwip</code> library, and we have to add it to the <code>LIBS</code> variable in the Makefile.
We add it by first downloading it on our system in <code>$(UK_WORKDIR)/libs/</code>:</p><pre><code>$ git clone https://github.com/unikraft/lib-lwip ~/.unikraft/libs/lwip
fatal: destination path '~/.unikraft/libs/lwip' already exists and is not an empty directory.
</code></pre><p>The library is already cloned. That is because <code>kraft</code> took care of it for us behind the scenes in our previous automatic build.</p><p>The next step is to add this library in the <code>Makefile</code>:</p><pre><code>UK_ROOT ?= $(HOME)/.unikraft/unikraft
UK_LIBS ?= $(HOME)/.unikraft/libs
LIBS := $(UK_LIBS)/lwip

all:
        @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
        @$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre><h5 id=configure-3>Configure</h5><p>Now, we configure it through <code>make menuconfig</code>.</p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_lwip.png alt="lwip selection menu"></p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_lwip2.png alt="lwip2 selection menu"></p><p>If you noticed, the menu also automatically selected some other internal components that would be required by <code>lwip</code>.
Now <code>Save</code> and <code>Exit</code> the configuration and run <code>make</code>.</p><h5 id=build-3>Build</h5><pre><code>$ make
</code></pre><h5 id=run-3>Run</h5><p>To run the KVM image, we use the <code>qemu-system-x86_64</code> command:</p><pre><code>$ qemu-system-x86_64 -kernel build/02-httpreply-manual_kvm-x86_64 -nographic
[...]
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
</code></pre><p>To close the running QEMU process, use the <code>Ctrl+a x</code> key combination.</p><p><strong>Note</strong>: We didn&rsquo;t go into configuring a functional network connection and actually querying the HTTP server.
This is a bit more complicated and is outside the scope of this session.</p><pre><code>sudo qemu-system-x86_64 -netdev bridge,id=en0,br=virbr0 -device virtio-net-pci,netdev=en0 -append &quot;netdev.ipv4_addr=172.44.0.2 netdev.ipv4_gw_addr=172.44.0.1 netdev.ipv4_subnet_mask=255.255.255.0 --&quot; -kernel build/02-httpreply-manual_kvm-x86_64 -nographic
</code></pre><h5 id=connecting-to-the-http-server-1>Connecting to the HTTP Server</h5><p>Similarly to kraft, in order to connect to the HTTP server, we use a virtual bridge to create a connection between the VM and the host system.
We assign address <code>172.44.0.1/24</code> to the bridge interface (pointing to the host) and we assign address <code>172.44.0.2/24</code> to the virtual machine, by passing boot arguments.</p><p>We run the commands below to create and assign the IP address to the bridge <code>virbr0</code>:</p><pre><code>$ sudo brctl addbr virbr0
$ sudo ip a a  172.44.0.1/24 dev virbr0
$ sudo ip l set dev virbr0 up
</code></pre><p>Now we start the virtul machine and pass it the proper arguments to assing the IP address <code>172.44.0.2/24</code>:</p><pre><code>$ sudo qemu-system-x86_64 -netdev bridge,id=en0,br=virbr0 -device virtio-net-pci,netdev=en0 -append &quot;netdev.ipv4_addr=172.44.0.2 netdev.ipv4_gw_addr=172.44.0.1 netdev.ipv4_subnet_mask=255.255.255.0 --&quot; -kernel build/02-httpreply-manual_kvm-x86_64 -nographic
0: Set IPv4 address 172.44.0.2 mask 255.255.255.0 gw 172.44.0.1
en0: Added
en0: Interface is up
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~b8be82b
Listening on port 8123...
[...]
</code></pre><p>The boot message confirms the assigning of the <code>172.44.0.2/24</code> IP address to the virtual machine.
It&rsquo;s listening on port 8123 for HTTP connections on that IP address.
We use <code>wget</code> to validate it&rsquo;s working properly and we are able to get the <code>index.html</code> file:</p><pre><code>$ wget 172.44.0.2:8123
--2021-08-18 16:47:38--  http://172.44.0.2:8123/
Connecting to 172.44.0.2:8123... connected.
HTTP request sent, awaiting response... 200 OK
[...]
2021-08-18 16:47:38 (41.5 MB/s) - ‘index.html’ saved [160]
</code></pre><p>Cleaning up means closing the virtual machine (and the HTTP server) and disabling and deleting the bridge interface:</p><pre><code>$ sudo ip l set dev virbr0 down
$ sudo brctl delbr virbr0
</code></pre><h2 id=summary>Summary</h2><p><code>kraft</code>is an extremely useful tool for quickly deploying unikernel images.
It abstracts away many factors that would normally increase the difficulty of such tasks.
Through just a simple set of a few commands, we can build and run a set of fast and secure unikernel images with low memory footprint.</p><h2 id=practical-work>Practical Work</h2><h3 id=01-echo-back-server>01. Echo-back Server</h3><p>You will have to implement a simple echo-back server in C for the KVM platform.
The application will have to be able to open a socket on <code>172.44.0.2:1234</code> and send back to the client whatever the client sends to the server.
If the client closes the connection, the server will automatically close.</p><p>Enter the <code>work/01-echo-back/</code> directory.
Check the source code file (<code>main.c</code>) and support files.
Work on the contents to have a viable echo-back server implementation.
Things to consider:</p><ul><li>You will need some network client utility such as <code>netcat</code>.</li><li>You will need the Lightweight TCP/IP stack library (lwip): <a href=https://github.com/unikraft/lib-lwip>https://github.com/unikraft/lib-lwip</a></li><li>You will have to update the build and support files in the <code>work/01-echo-back/</code> directory.</li><li>If you want to run the application without <code>kraft</code>, the KVM launch script and network setup are already included inside <code>work/01-echo-back/launch.sh</code>.</li></ul><p>To test if your application works you can try sending it messages like so:</p><pre><code>$ nc 172.44.0.2 1234
</code></pre><p>After connecting to the server, whatever you enter in standard input, should be echoed back to you.</p><h3 id=02-rot-13>02. ROT-13</h3><p>Update the previously built application, to echo back a <code>rot-13</code> encoded message.
To do this, you will have to create a custom function inside <code>lwip</code> (<code>~/.unikraft/libs/lwip/</code>) that your application (from the new directory <code>work/02-rot13</code>) can call in order to encode the string.
For example, you could implement the function <code>void rot13(char *msg);</code> inside <code>~/.unikraft/libs/lwip/sockets.c</code> and add its header inside <code>~/.unikraft/libs/lwip/include/sys/socket.h</code>.</p><p>The required resources are the exact same as in the previous exercise, you will just have to update <code>lwip</code>.
To test if this works, use the same methodology as before, but ensure that the echoed back string is encoded.</p><h3 id=03-tutorial-mount-9pfs>03. Tutorial: Mount 9pfs</h3><p>In this tutorial, we will see what we would need to do if we wanted to have a filesystem available.
To make it easy, we will use the <code>9pfs</code> filesystem, as well as the <code>newlib</code> library.
The latter is used so that we have available an API that would enable us to interact with this filesystem (functions such as <code>lseek</code>, <code>open</code>).</p><p><strong>Note</strong>: the build will fail if <code>unikraft</code> and <code>newlib</code> repositories aren&rsquo;t both on the <code>staging</code> or the <code>stable</code> branches.
To avoid this situation, go to <code>~/.unikraft/unikraft</code> and checkout branch <code>staging</code>:</p><pre><code>cd ~/.unikraft/unikraft
git checkout staging
</code></pre><p>We will need to download <code>newlib</code>:</p><pre><code>git clone https://github.com/unikraft/lib-newlib.git ~/.unikraft/libs/newlib
</code></pre><p>Next, we include it in our <code>Makefile</code>:</p><pre><code>LIBS := $(UK_LIBS)/lwip:$(UK_LIBS)/newlib
</code></pre><p>And now, for the final step, through <code>make menuconfig</code> make sure you have selected <code>libnewlib</code> as well as <code>9pfs: 9p filesystem</code> inside the <code>Library Configuration</code> menu.
We will also check these options inside <code>Library Configuration</code> -> <code>vfscore: Configuration</code>:</p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_fs.png alt="fs selection menu"></p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_fs2.png alt="fs2 selection menu"></p><p><img src=/docs/sessions/01-baby-steps/images/menuconfig_select_fs3.png alt="fs3 selection menu"></p><p>What is more, you should also have present in the current directory an additional directory called <code>fs0</code>:</p><pre><code>mkdir fs0
</code></pre><p>And so, <code>fs0</code> will contain whatever files you create, read from or write to from within your unikernel.</p><p>For now, just make sure it successfully builds. If it does, move on to the next work item.</p><h3 id=04-store-strings>04. Store Strings</h3><p>For the final work item, you will have to update the source code from the second task, so that it stores in a file the received string before sending the encoded one back to the client.
In order to achieve this, you must have the previous work item completed.</p><p>The available resources are the exact same, you will simply have to modify <code>main.c</code>.</p><p>To test if your application ran successfully, check to see whether the original strings you sent through the client are present in that file or not.</p><h2 id=further-reading>Further Reading</h2><p><a href=http://docs.unikraft.org/index.html>Unikraft Documentation</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-a7aba59367c86f53527a038cb13a4d73>4 - Session 02: Behind the Scenes</h1><h2 id=reminders>Reminders</h2><h3 id=kraft>Kraft</h3><p><a href=https://github.com/unikraft/kraft>Kraft</a> is the tool developed by the Unikraft team, to make application deployment easier.
To automatically download, configure, build and run an application, for example Helloworld, run</p><pre><code>$ kraft list update
$ kraft up -t helloworld@staging ./my-first-unikernel
</code></pre><p>If you are already working with cloned / forked repositories from Unikraft, kraft can also help you configure, build and run you application.
<code>kraft up</code> can be broken down into the following commands:</p><pre><code>$ kraft configure
$ kraft build
$ kraft run
</code></pre><h2 id=required-tools-and-resources>Required Tools and Resources</h2><p>For this session, the following tools are needed: <code>qemu-kvm</code>, <code>qemu-system-x86_64</code>, <code>qemu-system-aarch64</code>, <code>gcc-aarch64-linux-gnu</code>.
To install on Debian/Ubuntu use the following command</p><pre><code>$ sudo apt-get -y install qemu-kvm qemu-system-x86 qemu-system-arm gcc-aarch64-linux-gnu
</code></pre><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/02-behind-scenes/

$ ls
demo/  images/  index.md  sol/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/02-behind-scenes/

$ ls
demo/  images/  index.md  sol/
</code></pre><h2 id=overview>Overview</h2><h3 id=01-virtualization>01. Virtualization</h3><p>Through virtualization, multiple operating systems (OS) are able to run on the same hardware, independently, thinking that each one of them controls the entire system.
This can be done using a hypervisor, which is a low-level software that virtualizes the underlying hardware and manages access to the real hardware, either directly or through the host Operating System.
There are 2 main virtualized environments: virtual machines and containers, each with pros and cons regarding complexity, size, performance and security.
Unikernels come somewhere between those 2.</p><h4 id=virtual-machines>Virtual Machines</h4><p>Virtual machines represent an abstraction of the hardware, over which an operating system can run, thinking that it is alone on the system and that it controls the hardware below it.
Virtual machines rely on hypervisors to run properly.
Those hypervisors can be classified in 2 categories: Type 1 and Type 2.
We won&rsquo;t go in depth into them, but it is good to know how they are different:</p><ul><li>The <strong>Type 1 hypervisor</strong>, also known as <strong>bare-metal hypervisor</strong>, has direct access to the hardware and controls all the operating systems that are running on the system.
KVM, despite the appearances, is a Type 1 hypervisor.</li><li>The <strong>Type 2 hypervisor</strong>, also known as <strong>hosted hypervisor</strong>, has to go through the host operating system to reach the hardware.
An example of Type 2 hypervisor is VirtualBox.</li></ul><table><thead><tr><th style=text-align:center><img src=/docs/sessions/02-behind-scenes/images/vm1.svg alt="type 1 hypervisor os"></th><th style=text-align:center><img src=/docs/sessions/02-behind-scenes/images/vm2.svg alt="type 2 hypervisor os"></th></tr></thead><tbody><tr><td style=text-align:center>Operating systems over type 1 hypervisor</td><td style=text-align:center>Operating systems over type 2 hypervisor</td></tr></tbody></table><h4 id=containers>Containers</h4><p>Containers are environments designed to contain and run only one application and its dependencies.
This leads to very small sizes.
The containers are managed by a Container Management Engine, like Docker, and are dependent on the host OS, as they cannot run without it.</p><table><thead><tr><th style=text-align:center><img src=/docs/sessions/02-behind-scenes/images/container.svg alt=containers></th></tr></thead><tbody><tr><td style=text-align:center>Containers</td></tr></tbody></table><h4 id=unikraft>Unikraft</h4><p>Unikraft has a size comparable with that of a container, while it retains the power of a virtual machine, meaning it can directly control the hardware components (virtualized, or not, if running bare-metal).
This gives it an advantage over classical Operating Systems.
Being a special type of operating system, Unikraft can run bare-metal or over a hypervisor.</p><table><thead><tr><th style=text-align:center><img src=/docs/sessions/02-behind-scenes/images/unikraft1.svg alt="type 1 hypervisor uk"></th><th style=text-align:center><img src=/docs/sessions/02-behind-scenes/images/unikraft2.svg alt="type 2 hypervisor uk"></th></tr></thead><tbody><tr><td style=text-align:center>Unikraft over Type 1 hypervisor</td><td style=text-align:center>Unikraft over Type 2 hypervisor</td></tr></tbody></table><p>The following table makes a comparison between regular Virtual Machines (think of an Ubuntu VM), Containers and Unikernels, represented by Unikraft:</p><table><thead><tr><th style=text-align:center></th><th style=text-align:center>Virtual Machines</th><th style=text-align:center>Containers</th><th style=text-align:center>Unikernels</th></tr></thead><tbody><tr><td style=text-align:center><strong>Time performance</strong></td><td style=text-align:center>Slowest of the 3</td><td style=text-align:center>Fast</td><td style=text-align:center>Fast</td></tr><tr><td style=text-align:center><strong>Memory footprint</strong></td><td style=text-align:center>Heavy</td><td style=text-align:center>Depends on the number of features</td><td style=text-align:center>Light</td></tr><tr><td style=text-align:center><strong>Security</strong></td><td style=text-align:center>Very secure</td><td style=text-align:center>Least secure of the 3</td><td style=text-align:center>Very secure</td></tr><tr><td style=text-align:center><strong>Features</strong></td><td style=text-align:center>Everything you would think of</td><td style=text-align:center>Depends on the needs</td><td style=text-align:center>Only the absolute necessary</td></tr></tbody></table><h3 id=02-linuxu-and-kvm>02. linuxu and KVM</h3><p>Unikraft can be run in 2 ways:</p><ul><li>As a virtual machine, using QEMU/KVM or Xen.
It acts as an operating system, having the responsibility to configure the hardware components that it needs (clocks, additional processors, etc).
This mode gives Unikraft direct and total control over hardware components, allowing advanced functionalities.</li><li>As a <code>linuxu</code> build, in which it behaves as a Linux user-space application.
This severely limits its performance, as everything Unikraft does must go through the Linux kernel, via system calls.
This mode should be used only for development and debugging.</li></ul><p>When Unikraft is running using QEMU/KVM, it can either be run on an emulated system or a (para)virtualized one.
Technically, KVM means virtualization support is enabled.
If using QEMU in emulated mode, KVM is not used.
To keep things simple, we will use interchangeably the terms QEMU, KVM or QEMU/KVM to refer to this use (either virtualized, or emulated).</p><p>Emulation is slower, but it allows using CPU architectures different from the local one (you can run ARM code on a x86 machine).
Using (para)virtualisation, aka hardware acceleration, greater speed is achieved and more hardware components are visible to Unikraft.</p><h3 id=03-unikraft-core>03. Unikraft Core</h3><p>The Unikraft core is comprised of several components:</p><ul><li><a href=https://github.com/unikraft/unikraft/tree/staging/arch>the architecture code</a>:
This defines behaviours and hardware interactions specific to the target architecture (x86_64, ARM, RISC-V).
For example, for the x86_64 architecture, this component defines the usable registers, data types sizes and how Thread-Local Storage should happen.</li><li><a href=https://github.com/unikraft/unikraft/tree/staging/plat>the platform code</a>:
This defines interaction with the underlying hardware, depending on whether a hypervisor is present or not, and which hypervisor is present.
For example, if the KVM hypervisor is present, Unikraft will behave almost as if it runs bare-metal, needing to initialize the hardware components according to the manufacturer specifications.
The difference from bare-metal is made only at the entry, where some information, like the memory layout, the available console, are supplied by the bootloader (Multiboot) and there&rsquo;s no need to interact with the BIOS or UEFI.
In the case of Xen, many of the hardware-related operations must be done through hypercalls, thus reducing the direct interaction of Unikraft with the hardware.</li><li><a href=https://github.com/unikraft/unikraft/tree/staging/lib>internal libraries</a>:
These define behaviour independent of the hardware, like scheduling, networking, memory allocation, basic file systems.
These libraries are the same for every platform or architecture, and rely on the platform code and the architecture code to perform the needed actions.
The internal libraries differ from the external ones in the implemented functionalities.
The internal ones define parts of the kernel, while the external ones define user-space level functionalities.
For example, <strong>uknetdev</strong> and <strong>lwip</strong> are 2 libraries that define networking components.
<a href=https://github.com/unikraft/unikraft/tree/staging/lib/uknetdev>Uknetdev</a> is an internal library that interacts with the network card and defines how packages are sent using it.
<a href=https://github.com/unikraft/lib-lwip>Lwip</a> is an external library that defines networking protocols, like IP, TCP, UDP.
This library knows that the packages are somehow sent over the NIC, but it is not concerned how.
That is the job of the kernel.</li></ul><h3 id=04-libc-in-unikraft>04. libc in Unikraft</h3><p>The Unikraft core provides only the bare minimum components to interact with the hardware and manage resources.
A software layer, similar to the standard C library in a general-purpose OS, is required to make it easy to run applications on top of Unikraft.</p><p>Unikraft has multiple variants of a libc-like component:</p><ul><li><a href=https://github.com/unikraft/unikraft/tree/staging/lib/nolibc>nolibc</a> is a minimalistic libc, part of the core Unikraft code, that contains only the functionality needed for the core (strings, qsort, etc).</li><li><a href=https://github.com/unikraft/unikraft/tree/staging/lib/isrlib>isrlib</a> is the interrupt-context safe variant of nolibc.
It is used for interrupt handling code.</li><li><a href=https://github.com/unikraft/lib-newlib>newlibc</a> is the most complete libc currently available for Unikraft, but it still lacks some functionalities, like multithreading.
Newlibc was designed for embedded environments.</li><li><a href=https://github.com/unikraft/lib-musl>musl</a> is, theoretically, the best libc that will be used by Unikraft, but it&rsquo;s currently in testing.</li></ul><p>Nolibc and isrlib are part of the Unikraft core.
Newlibc and musl are external libraries, from the point of view of Unikraft, and they must be included to the build, as shown in <a href=/docs/sessions/01-baby-steps>Session 01: Baby Steps</a>.</p><h3 id=05-configuring-unikraft---configuk>05. Configuring Unikraft - Config.uk</h3><p>Unikraft is a configurable operating system, where each component can be modified, configured, according to the user’s needs.
This configuration is done using a version of Kconfig, through the <strong>Config.uk</strong> files.
In these files, options are added to enable libraries, applications and different components of the Unikraft core.
The user can then apply those configuration options, using <code>make menuconfig</code>, which generates an internal configuration file that can be understood by the build system, <strong>.config</strong>.
Once configured, the Unikraft image can be built, using <code>make</code>, and run, using the appropriate method (Linux ELF loader, qemu-kvm, xen, others).</p><p>Configuration can be done in 3 ways:</p><ul><li><p>Manually, using</p><pre><code>$ make menuconfig
</code></pre></li><li><p>Adding a dependency in <strong>Config.uk</strong> for a component, so that the dependency gets automatically selected when the component is enabled.
This is done using <code>depends on</code> and <code>select</code> keywords in <strong>Config.uk</strong>.
The configuration gets loaded and the <strong>.config</strong> file is generated by running</p><pre><code>$ make menuconfig
</code></pre><p>This type of configuration removes some configuration steps, but not all of them.</p></li><li><p>Writing the desired configuration in <strong>kraft.yaml</strong>.
The configuration gets loaded and the <strong>.config</strong> file is generated by running</p><pre><code>$ kraft configure
</code></pre></li></ul><p>In this session, we will use the first and the last configuration options.</p><h3 id=06-the-build-system---basics>06. The Build System - basics</h3><p>Once the application is configured, in <strong>.config</strong>, symbols are defined (e.g. <code>CONFIG_ARCH_X86_64</code>).
Those symbols are usable both in the C code, to include certain functionalities only if they were selected in the configuring process, and in the actual building process, to include / exclude source files, or whole libraries.
This last thing is done in <strong>Makefile.uk</strong>, where source code files are added to libraries.
During the build process, all the <code>Makefile.uk</code> files (from the Unikraft core and external libraries) are evaluated, and the selected files are compiled and linked, to form the Unikraft image.</p><table><thead><tr><th style=text-align:center><img src=/docs/sessions/02-behind-scenes/images/build_uk.svg alt="unikraft build"></th></tr></thead><tbody><tr><td style=text-align:center>The build process of Unikraft</td></tr></tbody></table><h2 id=summary>Summary</h2><ul><li>Unikraft is a special type of operating system, that can be configured to match the needs of a specific application.</li><li>This configuration is made possible by a system based on Kconfig, that uses <strong>Config.uk</strong> files to add possible configurations, and <strong>.config</strong> files to store the specific configuration for a build.</li><li>The configuration step creates symbols that are visible in both Makefiles and source code.</li><li>Each component has its own <strong>Makefile.uk</strong>, where source files can be added, removed, or be made dependent on the configuration.</li><li>Unikraft has an internal libc, but it can use others, more complex and complete, like newlib and musl.</li><li>Being an operating system, it needs to be run by a hypervisor, like KVM, xen, to work at full capacity.
It can also be run as an ELF, in Linux, but in this way the true power of Unikraft is not achieved.</li></ul><h2 id=work-items>Work Items</h2><h3 id=support-files-1>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/02-behind-scenes/

$ ls
demo/  images/  index.md  sol/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/02-behind-scenes/

$ ls
demo/  images/  index.md  sol/
</code></pre><h3 id=01-tutorial--reminder-building-and-running-unikraft>01. Tutorial / Reminder: Building and Running Unikraft</h3><p>We want to build the Helloworld application, using the Kconfig-based system, for the <strong>linuxu</strong> and <strong>KVM</strong> platforms, for the <strong>ARM</strong> and <strong>x86</strong> architectures, and then run them.</p><p>If you don&rsquo;t have the <code>unikraft</code> and <code>app-helloworld</code> repositories cloned already, do so, by running the following commands:</p><pre><code>$ git clone https://github.com/unikraft/unikraft
$ cd apps
$ git clone https://github.com/unikraft/app-helloworld helloworld/
</code></pre><p>As you can see from the commands above, it is recommended to have the following file structure in your working directory:</p><pre><code>workdir
|_______apps
|	|_______helloworld
|_______libs
|_______unikraft
</code></pre><p>Make sure that <code>UK_ROOT</code> and <code>UK_LIBS</code> are set correctly in the <code>Makefile</code> file, in the <code>helloworld</code> folder.
If you are not sure if they are set correctly, set them like this:</p><pre><code>UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
</code></pre><h4 id=linuxu-x86_64>Linuxu, x86_64</h4><p>First, we will the image for the <strong>linuxu</strong> platform.
As the resulting image will be an ELF, we can only run the <strong>x86</strong> Unikraft image.
We follow the steps:</p><ol><li><p>While in the <code>helloworld</code> folder, run</p><pre><code>$ make menuconfig
</code></pre></li><li><p>From <code>Architecture Selection</code>, select <code>Architecture</code> -> <code>x86 compatible</code>.</p></li><li><p>From <code>Platform Configuration</code>, select <code>Linux user space</code>.</p></li><li><p>Save, exit and run</p><pre><code>$ make
</code></pre></li><li><p>The resulting image, <code>app-helloworld_linuxu-x86_64</code> will be present in the <code>build/</code> folder.
Run it.</p><pre><code>$ ./build/app-helloworld_linuxu-x86_64
</code></pre></li></ol><h4 id=kvm-x86_64>KVM, x86_64</h4><p>Next, we will build the image for the <strong>kvm</strong> platform.
Before starting the process, make sure that you have the necessary tools, listed in the <a href=/docs/sessions/02-behind-scenes/#required-tools>Required Tools</a> section.
We follow the steps:</p><ol><li><p>Run</p><pre><code>$ make menuconfig
</code></pre></li><li><p>We will leave the architecture as is, for now.</p></li><li><p>From <code>Platform Configuration</code>, select <code>KVM guest</code>.</p></li><li><p>Save, exit and run</p><pre><code>$ make
</code></pre></li><li><p>Load the resulting image in QEMU by using</p><pre><code>$ sudo qemu-system-x86_64 -kernel ./build/app-helloworld_kvm-x86_64 -serial stdio
</code></pre></li></ol><p>Besides <code>-serial stdio</code>, no other option is needed to run the Helloworld application.
Other, more complex applications, will require more options given to qemu.</p><p>We have run Unikraft in the emulation mode, with the command from above.
We can also run it in the virtualization mode, by adding the <code>-enable-kvm</code> option.
You may receive a warning, <code>host doesn't support requested feature:</code>.
This is because kvm uses a generic CPU model.
You can instruct kvm to use your local CPU model, by adding <code>-cpu host</code> to the command.</p><p>The final command will look like this:</p><pre><code>$ sudo qemu-system-x86_64 -enable-kvm -cpu host -kernel ./build/app-helloworld_kvm-x86_64 -serial stdio
</code></pre><p>While we are here, we can check some differences between emulation and virtualization.
Record the time needed by each image to run, using <code>time</code>, like this:</p><pre><code>$ time sudo qemu-system-x86_64 -kernel ./build/app-helloworld_kvm-x86_64 -serial stdio
$ time sudo qemu-system-x86_64 -enable-kvm -cpu host -kernel ./build/app-helloworld_kvm-x86_64 -serial stdio
</code></pre><p>Because <code>helloworld</code> is a simple application, the <strong>real</strong> running time will be similar.
The differences are where each image runs most of its time: in user space, or in kernel space.
Find an explanation to those differences.</p><h4 id=kvm-arm>KVM, ARM</h4><p>To configure Unikraft for the ARM architecture, go to the configuration menu, like before, and select, from <code>Architecture Selection</code>, <code>Armv8 compatible</code>.
Save and exit the configuration.
As a new architecture is selected, you have to clean the previously compiled files:</p><pre><code>$ make clean
</code></pre><p>After cleaning, build the image:</p><pre><code>$ make
</code></pre><p>To run Unikraft, use the following command:</p><pre><code>$ sudo qemu-system-aarch64 -machine virt -cpu cortex-a57 -kernel ./build/app-helloworld_kvm-arm64 -serial stdio
</code></pre><p>Note that now we need to provide a machine and a CPU model to be emulated, as there are no defaults available.
If you want to find information about other machines, run</p><pre><code>$ sudo qemu-system-aarch64 -machine help
</code></pre><h3 id=02-tutorial-make-it-speak>02. Tutorial: Make It Speak</h3><p>The goal of this exercise is to enable the internal debugging library for Unikraft (<code>ukdebug</code>) and make it display messages up to the <em>info</em> level.
We also want to identify which hardware components are initialized for both x86 and ARM, and where.</p><h4 id=arm>ARM</h4><p>Considering that the last exercise ended with an ARM image, we will start now with that configuration.
We need to enable <code>ukdebug</code> in the configuration menu.
It is located in the <code>Library Configuration</code> menu.
But, for this exercise, besides enabling a component, we must modify it.</p><p>Enter the <code>ukdebug</code> configuration menu.
We need to have <code>Enable kernel messages (uk_printk)</code> checked.
Also, we need to change the option below it, <code>Kernel message level</code>, from <code>Show critical and error messages (default)</code> to <code>Show all types of messages</code>.
To make thing prettier, also enable the <code>Colored output</code> option.
Save and exit the configuration, then build and run the image.</p><p>We have a bunch of initializations happening, before seeing the &ldquo;Hello world!&rdquo; message.
Let&rsquo;s break them down. We start with the platform internal library, <code>libkvmplat</code>.
Here, the hardware components are initialized, like the Serial module, <code>PL001 UART</code>, and the <code>GIC</code>, which is the interrupt controller.
After that, the memory address space is defined, and the booting process starts, by replacing the current stack with a larger one, that is part of the defined address space.
Lastly, before calling the main function of the application, the software components of Unikraft are initialized, like timers, interrupts, and bus handlers.
The execution ends in in the platform library, with the shutdown command.</p><h4 id=x86_64>x86_64</h4><p>For the x86 part, just change the architecture in the configuration interface.
Recall that, after changing the architecture, we have to clean the previously compiled files:</p><pre><code>$ make clean
</code></pre><p>Build Unikraft:</p><pre><code>$ make
</code></pre><p>And run in under QEMU/KVM.
The output differs.
We can see that, in the case of x86, the platform library initializes less components, or it is less verbose than the ARM one.
But the timer and bus initialization is more verbose.
We see what timer is used, the i8254 one.
Also, we see that the PCI bus is used.</p><p>If you are wondering what the Constructors are, they will be covered in <a href=/docs/sessions/06-testing-unikraft/>Session 06: Testing Unikraft</a></p><h3 id=03-more-messages>03. More Messages</h3><p>Sometimes we need a more detailed output.
For this, <code>ukdebug</code> has the option to show <em>debug</em> level messages.
Enable them and run Unikraft, for either ARM or x86 architectures, or both.</p><h3 id=04-going-through-the-code>04. Going through the Code</h3><p>Having the output of <code>ukdebug</code>, go through the Unikraft code, in the <code>unikraft</code> folder.
Find the components that you have seen in the outputs, in the platform library, and where the kernel messages are sent.
The platform library, even though is called a library, is not in the <code>lib</code> subfolder.
It is placed in the <code>plat</code> folder.
Explore the code, at your own pace.
Can you also find where the main function is called?</p><h3 id=05-i-have-an-important-message>05. I Have an Important Message</h3><p>Send an important kernel message, that everyone needs to see, right before the main function is called.
Try different message levels (critical, error, warning, info, debug), to see how they differ.</p><p>Note: sending a critical kernel message will not affect how Unikraft runs after the message.</p><h3 id=06-tutorial--reminder-adding-filesystems-to-an-application>06. Tutorial / Reminder: Adding Filesystems to an Application</h3><p>For this tutorial, the aim is to create a simple QEMU/KVM application that reads from a file and displays the contents to standard output.
A local directory is to be mounted as the root directory (<code>/</code>) inside the QEMU/KVM virtual machine.</p><p>Some parts of this tutorial were already discussed in <a href=content/en/docs/sessions/01-baby-steps/index.md>Session 01: Baby Steps</a>.</p><p>We will use both the manual approach (<code>make</code> and <code>qemu-system-x86_64</code> / <code>qemu-guest</code>) and <code>kraft</code> to configure, build and run the application.</p><h4 id=setup>Setup</h4><p>The basic setup is in the <code>work/06-adding-filesystems/</code> folder in the session directory.
Enter that folder:</p><pre><code>$ cd work/06-adding-filesystems/

$ ls -F
guest_fs/  kraft.yaml  launch.sh*  main.c  Makefile  Makefile.uk  qemu-guest*
</code></pre><p>The <code>guest_fs/</code> local directory is to be mounted as the root directory (<code>/</code>) inside the QEMU/KVM virtual machine.
It contains the <code>grass</code> file.
The program (<code>main.c</code>) reads the contents of the <code>/grass</code> file and prints it to standard output.
<code>Makefile.uk</code> lists the <code>main.c</code> file as the application source file to be compiled and linked with Unikraft.</p><p><code>Makefile</code> is used by the manual configuration and build system.
<code>kraft.yaml</code> is used by kraft to configure, build and run the application.</p><p><code>launch.sh</code> is a wrapper script around <code>qemu-system-x86_64</code> used to manually run the application.
Similarly, <code>qemu-guest</code> is a wrapper script <a href=https://github.com/unikraft/kraft/blob/staging/scripts/qemu-guest>used internally by <code>kraft</code></a>.
We&rsquo;ll use it as well to run the application.</p><p><strong>If, at any point of this tutorial, something doesn&rsquo;t work, or you want a quick check, see the reference solution in <code>sol/06-adding-filesystems/</code> folder in the session directory.</strong></p><h4 id=using-the-manual-approach>Using the Manual Approach</h4><p>Firstly, we will use the manual approach to configure, build and run the application.</p><h5 id=configure>Configure</h5><p>For filesystem functionalities (opening, reading, writing files) we require a more powerful libc.
<a href=https://github.com/unikraft/lib-newlib>newlib</a> is already ported in Unikraft and will do nicely.
For this, we update the <code>LIBS</code> line in the <code>Makefile</code>:</p><pre><code>LIBS := $(UK_LIBS)/newlib
</code></pre><p>Update the <code>UK_ROOT</code> and <code>UK_LIBS</code> variables in the <code>Makefile</code> to point to the folders storing the Unikraft and libraries repositories.</p><p><strong>Make sure that both <code>unikraft</code> and <code>newlib</code> repositories are on the <code>staging</code> branch.</strong>
Go to each of the two repository folders (<code>unikraft</code> and <code>newlib</code>) and check the current branch:</p><pre><code>$ git checkout
</code></pre><p>Now we need to enable <strong>9pfs</strong> and <strong>newlib</strong> in Unikraft.
To do this, we run:</p><pre><code>$ make menuconfig
</code></pre><p>We need to select the following options, from the <code>Library Configuration</code> menu:</p><ul><li><code>libnewlib</code></li><li><code>vfscore: VFS Core Interface</code></li><li><code>vfscore: VFS Configuration</code> -> <code>Automatically mount a root filesystem</code> -> <code>Default root filesystem</code> -> <code>9pfs</code><ul><li>For the <code>Default root device</code> option fill the <code>fs0</code> string (instead of the default <code>rootfs</code> string).</li></ul></li></ul><p>These configurations will also mark as required <strong>9pfs</strong> and <strong>uk9p</strong> in the menu.</p><p>We want to run Unikraft with QEMU/KVM, so we must select <strong>KVM guest</strong> in the <code>Platform Configuration</code> menu.
For 9PFS we also need to enable, in the <strong>KVM guest</strong> options menu, <code>Virtio</code> -> <code>Virtio PCI device support</code>.</p><p>Save the configuration and exit.</p><p>Do a quick check of the configuration in <code>.config</code> by pitting it against the <code>config.sol</code> file in the reference solution:</p><pre><code>$ diff -u .config ../../sol/06-adding-filesytstems/config.sol
</code></pre><p>Differences should be minimal, such as the application identifier.</p><h5 id=build>Build</h5><p>Build the Unikraft image:</p><pre><code>make
</code></pre><p>Building the Unikraft image will take a while.
It has to pull newlib source code, patch it and then build it, together with the Unikraft source code.</p><h5 id=run-with-qemu-system-x86_64>Run with qemu-system-x86_64</h5><p>To run the Unikraft image with QEMU/KVM, we use the wrapper <code>launch.sh</code> script, that calls <code>qemu-system-x86_64</code> command with the proper arguments:</p><pre><code>$ ./launch.sh ./build/unikraft-kraft-9pfs-issue_kvm-x86_64
[...]
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
Hello, world!
File contents: The grass is green!
Bye, world!
</code></pre><p>A completely manual run would use the command:</p><pre><code>$ qemu-system-x86_64 -fsdev local,id=myid,path=guest_fs,security_model=none -device virtio-9p-pci,fsdev=myid,mount_tag=fs0 -kernel build/06-adding-filesystems_kvm-x86_64 -nographic
[...]
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
Hello, world!
File contents: The grass is green!
Bye, world!
</code></pre><p>Lets break it down:</p><ul><li><code>-fsdev local,id=myid,path=guest_fs,security_model=none</code> - assign an id (<code>myid</code>) to the <code>guest_fs/</code> local folder</li><li><code>-device virtio-9p-pci,fsdev=myid,mount_tag=fs0</code> - create a device with the 9pfs type, assign the <code>myid</code> for the <code>-fsdev</code> option and also assign the mount tag that we configured above (<code>fs0</code>)
Unikraft will look after that mount tag when trying to mount the filesystem, so it is important that the mount tag from the configuration is the same as the one given as argument to qemu.</li><li><code>-kernel build/06-adding-filesystems_kvm-x86_64</code> - tells QEMU that it will run a kernel;
if this parameter is omitted, QEMU will think it runs a raw file</li><li><code>-nographic</code> - prints the output of QEMU to the standard output, it doesn&rsquo;t open a graphical window</li></ul><h4 id=run-with-qemu-guest>Run with qemu-guest</h4><p><a href=https://github.com/unikraft/kraft/blob/staging/scripts/qemu-guest>qemu-guest</a> is the script used by kraft to run its QEMU/KVM images.
Before looking at the command, take some time to look through the script, and maybe figure out the arguments needed for our task.</p><p>To run a QEMU/KVM application using <code>qemu-guest</code>, we use:</p><pre><code>$ ./qemu-guest -e guest_fs/ -k build/06-adding-filesystems_kvm-x86_64
</code></pre><p>If we add the <code>-D</code> option, we can see the <code>qemu-system</code> command generated.</p><p>You may get the following error:</p><pre><code>[    0.100664] CRIT: [libvfscore] &lt;rootfs.c @  122&gt; Failed to mount /: 22
</code></pre><p>If you do, check that the mount tag in the configuration is the same as the one used by <code>qemu-guest</code>.
<code>qemu-guest</code> will use the tag <code>fs0</code>.</p><p><strong>The <code>fs0</code> tag is hardcoded for <code>qemu-guest</code> (and, thus, for <code>kraft</code>).
This is why we used the <code>fs0</code> tag when configuring the application with <code>make menuconfig</code>.
Another tag could be used but then we couldn&rsquo;t run the application with <code>qemu-guest</code> or <code>kraft</code>.
It could only be run by manually using <code>qemu-system-x86_64</code> with the corresponding arguments.</strong></p><h4 id=using-kraft>Using kraft</h4><p>With kraft, the whole process of configuring, building and running Unikraft can be made easier.</p><h5 id=configure-1>Configure</h5><p>First, we need to replace the <code>TODO</code> lines in <strong>kraft.yaml</strong>, to reflect our new configuration.
The first set of <code>TODO</code> lines correspond to the Unikraft configuration.
They are used by the <code>kraft configure</code> command.
This is the equivalent of what <code>make menuconfig</code> does.
We need to update those <code>TODO</code> lines with:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>kconfig</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBUK9P=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIB9PFS=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBVFSCORE_AUTOMOUNT_ROOTFS=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBVFSCORE_ROOTFS_9PFS=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBVFSCORE_ROOTDEV=&#34;fs0&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>Then, we need to update the <code>TODO</code> lines for the volume configuration (for mounting the filesystem).
These configuration lines are to be used by the <code>kraft run</code> command.
We need to update those <code>TODO</code> lines with:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>volumes</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>guest_fs</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>driver</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>9pfs</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>In the end, the resulting <code>kraft.yaml</code> file will look like this:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#000>---</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>specification</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;0.5&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>name</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#0000cf;font-weight:700>06</span>-<span style=color:#000>adding-filesystems</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>unikraft</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>version</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;staging&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>kconfig</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBUK9P=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIB9PFS=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBVFSCORE_AUTOMOUNT_ROOTFS=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBVFSCORE_ROOTFS_9PFS=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span>- <span style=color:#000>CONFIG_LIBVFSCORE_ROOTDEV=&#34;fs0&#34;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>targets</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span>- <span style=color:#204a87;font-weight:700>architecture</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>x86_64</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>platform</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>kvm</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>libraries</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>newlib</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>version</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;staging&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>kconfig</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>      </span>- <span style=color:#000>CONFIG_LIBNEWLIBC=y</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>volumes</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>  </span><span style=color:#204a87;font-weight:700>guest_fs</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>    </span><span style=color:#204a87;font-weight:700>driver</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>9pfs</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div><p>Next, we will make kraft reconfigure our application, using <code>kraft configure</code>.
In our case, nothing should be modified in <code>.config</code>, as we had the same configuration before.
If you get an error like &ldquo;missing component: newlib&rdquo;, you need to run <code>kraft list update</code>.</p><h5 id=build-1>Build</h5><p>We can now build the application using:</p><pre><code>$ kraft build
</code></pre><h5 id=run>Run</h5><p>Run the application using:</p><pre><code>$ kraft run
</code></pre><p><strong>Note</strong>: This step is not currently working due to <a href=https://github.com/unikraft/kraft/issues/71>a kraft issue</a>.
You can use the fix described in the issue to make <code>kraft run</code> work.</p><h3 id=07-tutorial-give-the-user-a-choice>07. Tutorial: Give the User a Choice</h3><p>The goal of this exercise is to modify <strong>Config.uk</strong>, for the Helloworld app, so that the user can choose if the app will display <em>Hello world</em>, or what it reads from the file from the previous exercise.</p><p>First of all, we need to add a new configuration in <code>Config.uk</code>.
We will do it like this:</p><pre><code>config APPHELLOWORLD_READFILE
	bool &quot;Read my file&quot;
	default n
	help
	  Reads the file in guest_fs/ and prints its contents,
	  instead of printing helloworld
</code></pre><p>After this, we need to modify our code in <code>main.c</code>, to use this configuration option.</p><pre><code>#ifndef CONFIG_APPHELLOWORLD_READFILE
	printf(&quot;Hello world!\n&quot;);
#else
	FILE *in = fopen(&quot;file&quot;, &quot;r&quot;);
	char buffer[100];

	fread(buffer, 1, 100, in);
	printf(&quot;File contents: %s\n&quot;, buffer);
	fclose(in);
#endif
</code></pre><p>Note that, for our configuration option <code>APPHELLOWORLD_READFILE</code>, a symbol, <code>CONFIG_APPHELLOWORLD_READFILE</code>, was defined.
We tell GCC that, if that symbol was not defined, it should use the <code>printf("Hello world!\n")</code>.
Otherwise, it should use the code written by us.</p><p>The last step is to configure the application.
We do this by running <code>make menuconfig</code>, then going to the <code>Application Options</code> and enabling our configuration option.</p><p>Now we can build and run the new Unikraft image.</p><h3 id=08-tutorial-arguments-from-command-line>08. Tutorial: Arguments from Command Line</h3><p>We want to configure the helloworld app to receive command line arguments and then print them.</p><p>For this, the Helloworld application already has a configuration option.
Configure the application by running</p><pre><code>$ make menuconfig
</code></pre><p>In the configuration menu, go to <code>Application Options</code> and enable <code>Print arguments</code>.
If we build and run the image now, using <code>qemu-guest</code>, we will see that two arguments are passed to Unikraft: the kernel argument, and a console.
We want to pass it an aditional argument, <code>"foo=bar"</code>.</p><p>Before this, make sure to reset your configuration, so Unikraft won&rsquo;t use 9pfs for this task:</p><pre><code>$ make clean
</code></pre><h4 id=raw-qemu-command>Raw qemu command</h4><p>To send an argument with qemu-system, we use the <code>-append</code> option, like this:</p><pre><code>$ qemu-system-x86_64 -kernel build/app-helloworld_kvm-x86_64 -append &quot;console=ttyS0 foo=bar&quot; -serial stdio
</code></pre><h4 id=qemu-guest-script>qemu-guest script</h4><p>To send an argument with the qemu-guest script, we use the <code>-a</code> option, like this:</p><pre><code>$ ./qemu-guest -k build/app-helloworld_kvm-x86_64 -a &quot;foo=bar&quot;
</code></pre><h4 id=kraft-1>Kraft</h4><p>To send an argument while using kraft, run it like this:</p><pre><code>$ kraft run &quot;foo=bar&quot;
</code></pre><h3 id=09-adding-a-new-source-file>09. Adding a new source file</h3><p>Create a new source file for your application, and implement a function that sorts a given integer array, by calling qsort, in turn, from different libc variants, and then prints that array.
For each library, check the size of the Unikraft image.
Enable <strong>nolibc</strong> and then, as a separate config / build, <strong>newlibc</strong>, both by using <strong>make menuconfig</strong> and modifying <strong>kraft.yaml</strong>.
You will have four different configurations and builds:</p><ul><li>nolibc + kraft</li><li>nolibc + make</li><li>newlibc + kraft</li><li>newlibc + make</li></ul><h3 id=10-more-power-to-the-user>10. More Power to the User</h3><p>Add the possibility to include the new source file only if a configuration option is selected.
Make sure that after this change, the application can still be built and run.</p><h3 id=11-less-power-to-the-user>11. Less Power to the User</h3><p>Delete <code>Config.uk</code> and reconfigure / rebuild the app.
What happens when you run the app?</p><h3 id=12-give-us-feedback>12. Give Us Feedback</h3><p>We want to know how to make the next sessions better.
Fo this we need your <a href=https://forms.gle/awraHJpjLaPDeXzk9>feedback</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-bcb4d0663368befcd015944d5552b25f>5 - Session 03: Debugging in Unikraft</h1><p>Because unikernels aim to be a more efficient method of virtualization, this can sometimes cause problems.
This session aims to familiarize you to solve any problem encountered during the development using <strong>GDB</strong> and <strong>Tracepoints</strong>.</p><h2 id=reminders>Reminders</h2><p>At this stage, you should be familiar with the steps of configuring, building and running any application within Unikraft and know the main parts of the architecture.
Below you can see a list of the commands you have used so far.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>kraft list</code></td><td>Get a list of all components that are available for use with kraft</td></tr><tr><td><code>kraft up -t &lt;appname> &lt;your_appname></code></td><td>Download, configure and build existing components into unikernel images</td></tr><tr><td><code>kraft run</code></td><td>Run resulting unikernel image</td></tr><tr><td><code>kraft init -t &lt;appname></code></td><td>Initialize the application</td></tr><tr><td><code>kraft configure</code></td><td>Configure platform and architecture (interactive)</td></tr><tr><td><code>kraft configure -p &lt;plat> -m &lt;arch></code></td><td>Configure platform and architecture (non-interactive)</td></tr><tr><td><code>kraft build</code></td><td>Build the application</td></tr><tr><td><code>kraft clean</code></td><td>Clean the application</td></tr><tr><td><code>make menuconfig</code></td><td>Configure application through the main menu</td></tr></tbody></table><h2 id=support-files>Support Files</h2><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/03-debugging/

$ ls
demo/  images/  index.md  sol/  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/03-debugging/

$ ls
demo/  images/  index.md  sol/  work/
</code></pre><h2 id=debugging>Debugging</h2><p>Contrary to popular belief, debugging a unikernel is in fact simpler than debugging a standard operating system.
Since the application and OS are linked into a single binary, debuggers can be used on the running unikernel to debug both application and OS code at the same time.
A couple of hints that should help starting:</p><ol><li>In the configuration menu (presented with <code>make menuconfig</code>), under <code>Build Options</code> make sure that <code>Drop unused functions and data</code> is <strong>unselected</strong>.
This prevents Unikraft from removing unused symbols from the final image and, if enabled, might hide missing dependencies during development.</li><li>Use <code>make V=1</code> to see verbose output for all of the commands being executed during the build.
If the compilation for a particular file is breaking and you would like to understand why (e.g., perhaps the include paths are wrong), you can debug things by adding the <code>-E</code> flag to the command, removing the <code>-o [objname]</code>, and redirecting the output to a file which you can then inspect.</li><li>Check out the targets under <code>Miscellaneous</code> when typing <code>make help</code>, these may come in handy.
For instance, <code>make print-vars</code> enables inspecting at the value of a particular variable in <code>Makefile.uk</code>.</li><li>Use the individual <code>make clean-[libname]</code> targets to ensure that you&rsquo;re cleaning only the part of Unikraft you&rsquo;re working on and not all the libraries that it may depend on.
This will speed up the build and thus the development process.</li><li>Use the Linux user space platform target (<code>linuxu</code>) for quicker and easier development and debugging.</li></ol><h3 id=using-gdb>Using GDB</h3><p>The build system always creates two image files for each selected platform:</p><ul><li>one that includes debugging information and symbols (<code>.dbg</code> file extension)</li><li>one that does not</li></ul><p>Before using GDB, go to the configuration menu under <code>Build Options</code> and select a <code>Debug information level</code> that is bigger than 0.
We recommend 3, the highest level.</p><p><img src=./images/debug_information_level.png alt="debug information level"></p><p>Once set, save the configuration and build your images.</p><h4 id=linuxu>Linuxu</h4><hr><p>For the Linux user space target (<code>linuxu</code>) simply point GDB to the resulting debug image, for example:</p><pre><code>$ gdb build/app-helloworld_linuxu-x86_64.dbg
</code></pre><h4 id=kvm>KVM</h4><hr><p>For KVM, you can start the guest with the kernel image that includes debugging information, or the one that does not.
We recommend creating the guest in a paused state (the <code>-S</code> option):</p><pre><code>$ qemu-system-x86_64 -s -S -cpu host -enable-kvm -m 128 -nodefaults -no-acpi -display none -serial stdio -device isa-debug-exit -kernel build/app-helloworld_kvm-x86_64.dbg -append verbose
</code></pre><p>Note that the <code>-s</code> parameter is shorthand for <code>-gdb tcp::1234</code>.
To avoid this long <code>qemu-system-x86</code> command with a lot of arguments, we can use <code>qemu-guest</code>.</p><pre><code>$ qemu-guest -P -g 1234 -k build/app-helloworld_kvm-x86_64.dbg
</code></pre><p>Now connect GDB by using the debug image with:</p><pre><code>$ gdb --eval-command=&quot;target remote :1234&quot; build/app-helloworld_kvm-x86_64.dbg
</code></pre><p>Unless you&rsquo;re debugging early boot code (until <code>_libkvmplat_start32</code>), you’ll need to set a hardware break point:
Hardware breakpoints have the same effect as the common software breakpoints you are used to, but they are different in the implementation.
As the name suggests, hardware breakpoints are based on direct hardware support.
This may limit the number of breakpoints you can set, but makes them especially useful when debugging kernel code.</p><pre><code>hbreak [location]
continue
</code></pre><p>We’ll now need to set the right CPU architecture:</p><pre><code>disconnect
set arch i386:x86-64:intel
</code></pre><p>And reconnect:</p><pre><code>tar remote localhost:1234
</code></pre><p>You can now run <code>continue</code> and debug as you would normally.</p><h4 id=xen>Xen</h4><hr><div class="alert alert-primary" role=alert><h4 class=alert-heading>Running Unikraft in Xen</h4><p>For Xen you first need to create a VM configuration (save it under <code>helloworld.cfg</code>):</p><pre><code>name          = 'helloworld'
vcpus         = '1'
memory        = '4'
kernel        = 'build/app-helloworld_xen-x86_64.dbg'
</code></pre><p>Start the virtual machine with:</p><p><code>$ xl create -c helloworld.cfg</code></p></div><p>For Xen the process is slightly more complicated and depends on Xen&rsquo;s <code>gdbsx</code> tool.
First you&rsquo;ll need to make sure you have the tool on your system.
Here are sample instructions to do that:</p><pre><code>[get Xen sources]
$ ./configure
$ cd tools/debugger/gdbsx/ &amp;&amp; make
</code></pre><p>The <code>gdbsx</code> tool will then be under tools/debugger.
For the actual debugging, you first need to create the guest (we recommend paused state: <code>xl create -p</code>), note its domain ID (<code>xl list</code>) and execute the debugger backend:</p><pre><code>$ gdbsx -a [DOMAIN ID] 64 [PORT]
</code></pre><p>You can then connect GDB within a separate console and you&rsquo;re ready to debug:</p><pre><code>$ gdb --eval-command=&quot;target remote :[PORT]&quot; build/helloworld_xen-x86_64.dbg
</code></pre><p>You should be also able to use the debugging file (<code>build/app-helloworld_xen-x86_64.dbg</code>) for GDB instead passing the kernel image.</p><h2 id=tracepoints>Tracepoints</h2><p>Because Unikraft needs a tracing and performance measurement system, one method to do this is using Unikrat&rsquo;s tracepoint system.
A tracepoint provides a hook to call a function that you can provide at runtime.
You can put tracepoints at important locations in the code.
They are lightweight hooks that can pass an arbitrary number of parameters, which prototypes are described in a tracepoint declaration placed in a header file.</p><h3 id=dependencies>Dependencies</h3><p>We provide some tools to read and export trace data that were collected with Unikraft&rsquo;s tracepoint system.
The tools depend on Python3, as well as the click and tabulate modules.
You can install them by running (Debian/Ubuntu):</p><pre><code>sudo apt-get install python3 python3-click python3-tabulate
</code></pre><h3 id=enabling-tracing>Enabling Tracing</h3><p>Tracepoints are provided by <code>lib/ukdebug</code>.
To enable Unikraft to collect trace data, enable the option <code>CONFIG_LIBUKDEBUG_TRACEPOINTS</code> in your configuration (via <code>make menuconfig</code> under <code>Library Configuration -> ukdebug -> Enable tracepoints</code>).</p><p><img src=./images/enable_tracepoints.png alt="enable tracepoints"></p><p>The configuration option <code>CONFIG_LIBUKDEBUG_ALL_TRACEPOINTS</code> activates <strong>all</strong> existing tracepoints.
Because tracepoints may noticeably affect performance, you can alternatively enable tracepoints only for compilation units that you are interested in.</p><p>This can be done with the <code>Makefile.uk</code> of each library.</p><pre><code># Enable tracepoints for a whole library
LIBNAME_CFLAGS-y += -DUK_DEBUG_TRACE
LIBNAME_CXXFLAGS-y += -DUK_DEBUG_TRACE

# Alternatively, enable tracepoints of source files you are interested in
LIBNAME_FILENAME1_FLAGS-y += -DUK_DEBUG_TRACE
LIBNAME_FILENAME2_FLAGS-y += -DUK_DEBUG_TRACE
</code></pre><p>This can also be done by defining <code>UK_DEBUG_TRACE</code> in the head of your source files.
Please make sure that <code>UK_DEBUG_TRACE</code> is defined before <code>&lt;uk/trace.h></code> is included:</p><pre><code>#ifndef UK_DEBUG_TRACE
#define UK_DEBUG_TRACE
#endif

#include &lt;uk/trace.h&gt;
</code></pre><p>As soon as tracing is enabled, Unikraft will store samples of each enabled tracepoint into an internal trace buffer.
Currently this is not a circular buffer.
This means that as soon as it is full, Unikraft will stop collecting further samples.</p><h3 id=creating-tracepoints>Creating Tracepoints</h3><p>Instrumenting your code with tracepoints is done by two steps.
First, you define and register a tracepoint handler with the <code>UK_TRACEPOINT()</code> macro.
Second, you place calls to the generated handler at those places in your code where your want to trace an event:</p><pre><code>#include &lt;uk/trace.h&gt;

UK_TRACEPOINT(trace_vfs_open, &quot;\&quot;%s\&quot; 0x%x 0%0o&quot;, const char*, int, mode_t);

int open(const char *pathname, int flags, ...)
{
      trace_vfs_open(pathname, flags, mode);

      /* lots of cool stuff */

      return 0;
}
</code></pre><p><code>UK_TRACEPOINT(trace_name, fmt, type1, type2, ... typeN)</code> generates the handler <code>trace_name()</code> (static function).
It will accept up to 7 parameters of type <code>type1</code>, <code>type2</code>, etc.
The given format string <code>fmt</code> is a printf-style format which will be used to create meaningful messages based on the collected trace parameters.
This format string is only kept in the debug image and is used by the tools to read and parse the trace data.
Unikraft&rsquo;s trace buffer stores for each sample a timestamp, the name of the tracepoint, and the given parameters.</p><h3 id=reading-trace-data>Reading Trace Data</h3><p>Unikraft is storing trace data to an internal buffer that resides in the guest&rsquo;s main memory.
You can use GDB to read and export it.
For this purpose, you will need to load the <code>uk-gdb.py</code> helper script into your GDB session.
It adds additional commands that allow you to list and store the trace data.
We recommend to automatically load the script to GDB.
For this purpose, add the following line to your <code>~/.gdbinit</code>:</p><pre><code>source /path/to/your/build/uk-gdb.py
</code></pre><p>In order to collect the data, open GDB with the debug image and connect to your Unikraft instance as described in Section <a href=#using-gdb>Using GDB</a>:</p><pre><code>$ gdb build/app-helloworld_linuxu-x86_64.dbg
</code></pre><p>The <code>.dbg</code> image is required because it contains offline data needed for parsing the trace buffer.</p><p>As soon as you let run your guest, samples should be stored in Unikraft&rsquo;s trace buffer.
You can print them by issuing the GDB command <code>uk trace</code>:</p><pre><code>(gdb) uk trace
</code></pre><p>Alternatively, you can save all trace data to disk with <code>uk trace save &lt;filename></code>:</p><pre><code>(gdb) uk trace save traces.dat
</code></pre><p>It may make sense to connect with GDB after the guest execution has been finished (and the trace buffer got filled).
For this purpose, make sure that your hypervisor is not destroying the instance after guest shut down (on QEMU add <code>--no-shutdown</code> and <code>--no-reboot</code> parameters).</p><p>If you are seeing the error message <code>Error getting the trace buffer. Is tracing enabled?</code>, you probably did not enable tracing or Unikraft&rsquo;s trace buffer is empty.
This can happen when no tracepoint was ever called.</p><p>Any saved trace file can be later processed with the <code>trace.py</code> script. In our example:</p><pre><code>$ support/scripts/uk_trace/trace.py list traces.dat
</code></pre><h2 id=summary>Summary</h2><h2 id=practical-work>Practical Work</h2><h3 id=support-files-1>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/03-debugging/

$ ls
demo/  images/  index.md  sol/  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/03-debugging/

$ ls
demo/  images/  index.md  sol/  work/
</code></pre><h3 id=01-tutorial-use-gdb-in-unikraft>01. Tutorial. Use GDB in Unikraft</h3><p>For this tutorial, we will just start the <code>app-helloworld</code> application and inspect it with the help of GDB.</p><p>First make sure you have the following file structure in your working directory:</p><pre><code>workdir
|_______apps
|	|_______helloworld
|_______libs
|_______unikraft
</code></pre><h4 id=linuxu-1>Linuxu</h4><p>For the image for the <strong>linuxu</strong> platform we can use GDB directly with the binary already created.</p><pre><code>$ gdb build/app-helloworld_linuxu-x86_64.dbg
</code></pre><h4 id=kvm-1>KVM</h4><p>To avoid using a command with a lot of parameters that you noticed above in the <strong>KVM</strong> section, we can use <code>qemu-guest</code>.</p><pre><code>$ qemu-guest -P -g 1234 -k build/app-helloworld_kvm-x86_64.dbg
</code></pre><p>Open another terminal to connect to GDB by using the debug image with:</p><pre><code>$ gdb --eval-command=&quot;target remote :1234&quot; build/app-helloworld_kvm-x86_64.dbg
</code></pre><p>First you can set the right CPU architecture and then reconnect:</p><pre><code>disconnect
set arch i386:x86-64:intel
tar remote localhost:1234
</code></pre><p>Then you can put a hardware break point at main function and run <code>continue</code>:</p><pre><code>hbreak main
continue
</code></pre><p>All steps described above can be done using the script <code>kvm_gdb_debug</code> located in the <code>work/01-tutorial-gdb/</code> folder.
All you need to do is to provide the path to kernel image.</p><pre><code>kvm_gdb_debug build/app-helloworld_kvm-x86_64.dbg
</code></pre><h3 id=02-mystery-find-the-secret-using-gdb>02. Mystery: Find the secret using GDB</h3><p>Before starting the task let&rsquo;s get familiar with some GDB commands.</p><p><code>ni</code> - go to the next instruction, but skip function calls</p><p><code>si</code> - go to the next instruction, but enters function calls</p><p><code>c</code> - continue execution to the next breakpoint</p><p><code>p expr</code> - display the value of an expression</p><p><code>x addr</code> - get the value at the indicated address (similar to <code>p *addr</code>)</p><p><code>whatis arg</code> - print the data type of <code>arg</code></p><p>GDB provides convenience variables that you can use within GDB to hold on to a value and refer to it later.
For example:</p><pre><code>set $foo = *object_ptr
</code></pre><p>Note that you can also cast variables in GDB similar to C:</p><pre><code>set $var = (int *) ptr
</code></pre><p>If you want to dereference a pointer and actually see the value, you can use the following command:</p><pre><code>p *addr
</code></pre><p>You can find more GDB commands <a href=https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf>here</a>
Also, if you are unfamiliar with X86_64 calling convention you can read more about it <a href=https://en.wikipedia.org/wiki/X86_calling_conventions>here</a>.</p><p>Now, let&rsquo;s get back to the task.
Download the <code>mystery_kvm-x86_64</code> file from <a href="https://drive.google.com/drive/folders/1K74TYViRxGtyRwDepJ3W_JNOZWdO2LXT?usp=sharing">here</a>.
Copy the <code>mystery_kvm-x86_64</code> file to the <code>work/02-mystery/</code> directory.
Navigate to <code>work/02-mystery/</code> directory.
Use the 2 scripts in the directory (<code>debug.sh</code> and <code>connect.sh</code>) to start the <code>mystery_kvm-x86_64.dbg</code> executable using GDB.
Do you think you can find out the <strong>secret</strong>?</p><p><strong>HINT</strong> Use the <code>nm</code> utility on the binary as a starting point.</p><h3 id=03-bug-or-feature>03. Bug or feature?</h3><p>There are two kernel images located in the <code>work/03-app-bug/</code> folder.
One of them is build for <strong>Linuxu</strong>, the other for <strong>KVM</strong>.</p><p>First try to inspect what it&rsquo;s wrong with <strong>Linuxu</strong> image.
You will notice that if you run the program you will get a segmentation fault.
Why does this happen?</p><p>After you figure out what it&rsquo;s happening with <strong>Linuxu</strong> image have a look also at the <strong>KVM</strong> one.
It was built from the code source, but when you will try to run it, you will not get a segmentation fault.
Is this a bug or a feature?</p><h3 id=04-tutorial-use-tracepoints>04. Tutorial. Use Tracepoints.</h3><p>We will start from the <code>app-helloworld</code> application and we will put two tracepoints.
One at the beginning of the program (after the main) and one at the end of it and these tracepoints should print <code>argc</code>.</p><p>First we need to define <code>UK_DEBUG_TRACE</code> and to include <code>uk/trace.h</code>.</p><pre><code>#ifndef UK_DEBUG_TRACE
#define UK_DEBUG_TRACE
#endif

#include &lt;uk/trace.h&gt;
</code></pre><p>After that we have to define those tracepoints that we want to use.
In our case it should be something similar with:</p><pre><code>UK_TRACEPOINT(start_trace, &quot;%d&quot;, int);
UK_TRACEPOINT(stop_trace, &quot;%d&quot;, int);
</code></pre><p>Now we can invoke them inside the main.</p><pre><code>int main(int argc, char *argv[])
{
    start_trace(argc);
    start_status();

    printf(&quot;Hello world!\n&quot;);

    stop_trace(argc);
    stop_status();

    return 0;
}

</code></pre><p>We also added two simple functions for a better view of tracepoints in GDB.</p><pre><code>void start_status(){
    printf(&quot;Start tracing\n&quot;);
}

void stop_status(){
    printf(&quot;Stop tracing\n&quot;);
}
</code></pre><p>You can check the source code for this tutorial in <code>work/04-tutorial-tracepoints.</code>
Now we can build the application, but we need to make sure that we have checked the <code>CONFIG_LIBUKDEBUG_TRACEPOINTS</code> option in the configuration.(<code>Library Configuration -> ukdebug -> Enable tracepoints</code>)</p><p>Now we will have to start the application in paused state.</p><pre><code>qemu-guest -P -g 1234 -k build/app-helloworld-tracepoints_kvm-x86_64.dbg
</code></pre><p>In another terminal we will start the GDB:</p><pre><code>gdb --eval-command=&quot;target remote :1234&quot; build/app-helloworld-tracepoints_kvm-x86_64.dbg
</code></pre><p>Put a hardware break to main and continue until there.</p><pre><code>(gdb) hbreak main
(gdb) continue
</code></pre><p>Now we can put a break to first function <code>start_status</code> to check if the first tracepoint is successful.
To show all the tracepoints we can use <code>uk trace</code>.</p><div class="alert alert-primary" role=alert><h4 class=alert-heading>GDB configuration</h4>Don&rsquo;t forget to put this line <code>source /path/to/your/build/uk-gdb.py</code> in your GDB file configuration <code>~/.gdbinit</code>.
Otherwise you won&rsquo;t be able to use <code>uk trace</code>.</div><pre><code>(gdb) break start_status
(gdb) continue
(gdb) uk trace
0000116012362374 start_trace: 2
</code></pre><p>We notice that we got an output and that the tracepoint was reached.
We continue until the second trace point and we will save all the tracepoints obtained with the command <code>uk trace save traces.dat</code></p><pre><code>(gdb) break stop_status
(gdb) continue
(gdb) uk trace save traces.dat
Saving traces to traces.dat ...
</code></pre><p>Now we can read all the tracepoints obtained using <code>trace.py</code> from the main repo located in <code>unikraft/support/scripts/uk_trace/trace.py</code>.
The output will be similar to this:</p><pre><code>       time  tp_name        msg
-----------  -----------  -----
 5321091993  start_trace      2
11121071844  stop_trace       2
</code></pre><h3 id=05-can-you-trace-your-own-program>05. Can you trace your own program?</h3><p>Modify your <code>Echo-back Server</code> application implemented in the <a href=https://usoc21.unikraft.org/docs/sessions/01-baby-steps/#01-echo-back-server>first</a> session so that each time the server responds with a message a tracepoint with the corresponding message will be activated.
Save all your tracepoints in a <code>traces.dat</code> file and show them in a user-friendly view with <code>trace.py</code>.</p><h3 id=06-nginx-with-or-without-main-thats-the-question>06. Nginx with or without main? That&rsquo;s the question.</h3><p>Let&rsquo;s try a new application based on networking, <strong>Nginx</strong>.</p><p>First clone the repository for <a href=https://github.com/unikraft/app-nginx>app-nginx</a> and put it in the right hierarchy.
Then you need to create <code>Makefile</code> and <code>Makefile.uk</code>.
Make sure to respect the order of libraries in <code>Makefile</code>. For more information check <a href=https://github.com/unikraft/lib-nginx>lib-nginx</a> repository.</p><p>Do you observe something strange? Where is the <code>main.c</code>?</p><p>Deselect this option <code>Library Configuration</code> -> <code>libnginx</code> -> <code>Provide a main function</code> and try to make your own <code>main.c</code> that will run <strong>Nginx</strong>.</p><ul><li>Nginx + Makefile</li><li>Nginx without <code>provide main function</code></li></ul><h3 id=07-bonus-bad-elf-in-town>07. Bonus. Bad ELF in Town</h3><p>We managed to build an ELF file that is valid when doing static analysis, but that can&rsquo;t be executed.
The file is <code>bad_elf</code>, located in the <code>work/07-bad-elf/</code> folder.</p><p>Running it triggers a segmentation fault message.
Running it using <code>strace</code> show an error with <code>execve()</code>.</p><pre><code>~/Doc/U/summer-of-code-2021/c/e/d/s/0/w/05-bad-elf &gt; ./bad_elf
[1]    125458 segmentation fault  ./bad_elf
~/Doc/U/summer-of-code-2021/c/e/d/s/0/w/05-bad-elf &gt; strace ./bad_elf
execve(&quot;./bad_elf&quot;, [&quot;./bad_elf&quot;], 0x7ffc9ca2e960 /* 66 vars */) = -1 EINVAL (Invalid argument)
+++ killed by SIGSEGV +++
[1]    125468 segmentation fault (core dumped)  strace ./bad_elf

</code></pre><p>The ELF file itself is valid.
You can check using <code>readelf</code>:</p><pre><code>$ readelf -a ./bad_elf
</code></pre><p>The issue is to be detected in the kernel.
Use either <a href=https://www.brendangregg.com/perf.html><code>perf</code></a>, or, better yet <a href=https://jvns.ca/blog/2017/03/19/getting-started-with-ftrace/><code>ftrace</code></a> to inspect the kernel function calls done by the program.
Identify the function call that sends out the <code>SIGSEGV</code> signal.
Identify the cause of the issue.
Find that cause in the <a href=https://linux.die.net/man/5/elf>manual page <code>elf(5)</code></a>.</p><h3 id=08-give-us-feedback>08. Give Us Feedback</h3><p>We want to know how to make the next sessions better.
For this we need your <a href=https://forms.gle/9EuzgL1n244Mvqfq8>feedback</a>.
Thank you!</p><h2 id=further-reading>Further Reading</h2><ul><li><a href=https://sourceware.org/gdb/wiki/Internals/Breakpoint%20Handling>Hardware Breakpoint</a></li><li><a href=https://01.org/linuxgraphics/gfx-docs/drm/trace/tracepoints.html>Tracepoints</a></li><li><a href=https://users.ece.utexas.edu/~adnan/gdb-refcard.pdf>GDB Cheatsheet</a></li><li><a href=https://en.wikipedia.org/wiki/X86_calling_conventions>X86_64 calling convention</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-cbba34b6d1e7d9a0e83c791f84d7f29d>6 - Session 04: Complex Applications</h1><h2 id=reminders>Reminders</h2><h3 id=print-system>Print system</h3><p>This print system in implemented in <code>lib/ukdebug</code> and can be activated using <code>make menuconfig</code> (<code>Library Configuration -> ukdebug: Debugging and Tracing</code>).</p><p>We have two types of messages:</p><ul><li><strong>Kernel messages</strong><ul><li><strong>Information</strong>(<code>uk_pr_info</code>)</li><li><strong>Warnings</strong>(<code>uk_pr_warn</code>)</li><li><strong>Errors</strong>(<code>uk_pr_err</code>)</li><li><strong>Critical Messages</strong>(<code>uk_pr_crit</code>)</li></ul></li><li><strong>Debug messages</strong>(<code>uk_pr_debug</code>)</li></ul><h3 id=assertions>Assertions</h3><p>We can use assertions to check if the system is in a defined and stable state.
Can be compiled-in or compiled-out and it can be activated from <code>Library Configuration -> ukdebug: Debugging and Tracing -> Enable assertions</code>.</p><p>The macros used can be:</p><ul><li><code>UK_ASSERT</code> (condition)</li><li><code>UK_BUGON</code> (negative condition)</li><li><code>UK_CTASSERT</code> (condition)(used for compile-time assertions)</li></ul><h3 id=gdb>GDB</h3><p>To use GDB we need the symbols from the <code>gdb</code> file generated at build time.
For this we need to set <code>Debug information level</code> to <code>Level 3</code> from <code>make menuconfig</code> (<code>Build Options -> Debug information level -> Level 3</code>).</p><h4 id=linux>Linux</h4><p>For the Linux user space target (<code>linuxu</code>) simply point GDB to the resulting debug image:</p><pre><code>$ gdb path_to_unikraft_gdb_image
</code></pre><h4 id=kvm>KVM</h4><p>For KVM we need to go through few steps:</p><ol><li><p>Run guest in paused state</p><p>Using <strong>qemu</strong>:</p><pre><code>$ qemu-guest -P -g 1234 -k path_to_unikraft_gdb_image
</code></pre><p>Using <strong>kraft</strong>:</p><pre><code>$ kraft run -d -g 1234 -P
</code></pre></li><li><p>Attach debugger</p><pre><code>$ gdb --eval-command=&quot;target remote :1234&quot; path_to_unikraft_gdb_image
</code></pre></li><li><p>Disconnect GDB</p><pre><code>disconnect
</code></pre></li><li><p>Set GDB&rsquo;s machine architecture to x86_64</p><pre><code>$ set arch i386:x86-64:intel
</code></pre></li><li><p>Re-connect</p><pre><code>tar remote localhost:1234
</code></pre></li></ol><h3 id=tracepoints>Tracepoints</h3><p>Tracepoints are provided by <code>lib/ukdebug</code>.
To enable Unikraft to collect trace data, enable the option <code>CONFIG_LIBUKDEBUG_TRACEPOINTS</code> in your configuration (via <code>make menuconfig</code> under <code>Library Configuration -> ukdebug -> Enable tracepoints</code>).</p><h4 id=instrumenting>Instrumenting</h4><p>Instrumenting your code with tracepoints is done by two steps:</p><ul><li>Define and register a tracepoint handler with the <code>UK_TRACEPOINT()</code> macro.</li><li>Place calls to the generated handler at those places in your code where your want to trace an event.</li></ul><h4 id=reading-traces>Reading traces</h4><p>Unikraft is storing trace data to an internal buffer that resides in the guest&rsquo;s main memory.
To access that data you need to configure the GDB and add <code>source /path/to/your/build/uk-gdb.py</code> to <code>~/.gdbinit</code></p><p>Commands available in GDB:</p><table><thead><tr><th>Commands</th><th>Deion</th></tr></thead><tbody><tr><td>uk trace</td><td>show tracepoints in GDB</td></tr><tr><td>uk trace save <code>&lt;file></code></td><td>save tracepoints to file</td></tr></tbody></table><p>Any saved trace file can be later processed with the <code>trace.py</code> .</p><pre><code>$ support/s/uk_trace/trace.py list &lt;file&gt;
</code></pre><h2 id=work-items>Work Items</h2><p>In this session, we are going to run some real-world applications on top of Unikraft.</p><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/04-complex-applications/

$ ls -F
images/  index.md  sol/  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/04-complex-applications/

$ ls -F
images/  index.md  sol/  work/
</code></pre><h3 id=00-qemu-wrapper>00. Qemu Wrapper</h3><p>As we saw during the other sessions, <a href=https://github.com/unikraft/kraft/blob/staging/scripts/qemu-guest>qemu-guest</a> is a wrapper script over the <code>qemu-system-x86_64</code> executable, to make the use of binary less painful.
In the following session, it will be very handy to use it.
To see the options for this wrapper you can use <code>qemu-guest -h</code>.</p><p>It is possible to run a lot of complex applications on Unikraft.
In this session we analyze 3 of them:</p><ul><li>Sqlite</li><li>Redis</li><li>Nginx</li></ul><h3 id=01-sqlite-tutorial>01. SQLite (Tutorial)</h3><p>The goal of this tutorial is to get you to set up and run SQLite on top of Unikraft.
Find the support files in the <code>work/01-set-up-and-run-sqlite/</code> folder of the session directory.</p><p><a href=https://www.sqlite.org/index.html>SQLite</a> is a C library that implements an encapsulated SQL database engine that does not require any setting or administration.
It is one of the most popular in the world and is different from other SQL database engines because it is simple to administer, use, maintain, and test.
Thanks to these features, SQLite is a fast, secure, and most crucial simple application.</p><p>The SQLite application is formed by a ported external library that depends on two other libraries that are also ported for Unikraft: <a href=https://github.com/unikraft/lib-pthread-embedded>pthread-embedded</a> and <a href=https://github.com/unikraft/lib-newlib>newlib</a>.
To successfully compile and run the SQLite application for the KVM platform and x86-64 architecture, we follow the steps below.</p><h4 id=setup>Setup</h4><p>First, we make sure we have the directory structure to store the local clones of Unikraft, library and application repositories.
The structure should be:</p><pre><code>workdir
|-- unikraft/
|-- libs/
`-- apps/
</code></pre><p>We clone the <a href=https://github.com/unikraft/lib-sqlite>lib-sqlite</a> repository in the <code>libs/</code> folder.
The libraries on which <code>lib-sqlite</code> depends (<a href=https://github.com/unikraft/lib-newlib>pthread-embedded</a> and <a href=https://github.com/unikraft/lib-pthread-embedded>newlib</a>) are also to be cloned in the <code>libs/</code> folder.</p><p>We clone the <a href=https://github.com/unikraft/app-sqlite/>app-sqlite</a> repository in the <code>apps/</code> folder.
In this directory, we need to create two files:</p><ul><li><code>Makefile</code>: containing rules for building the application as well as specifying the libraries that the application needs</li><li><code>Makefile.uk</code>: used to define variables needed to compile the application or to add application-specific flags</li></ul><p>Also, in the <code>Makefile</code>, the order in which the libraries are mentioned in the <code>LIBS</code> variable is important to avoid the occurrence of compilation errors.</p><pre><code>UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
LIBS := $(UK_LIBS)/lib-pthread-embedded:$(UK_LIBS)/lib-newlib:$(UK_LIBS)/lib-sqlite

all:
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre><h4 id=configure>Configure</h4><p>We configure the application by running:</p><pre><code>$ make menuconfig
</code></pre><p>We select the SQLite library from the configuration menu, <code>Library Configuration</code> section.
For starters, we select the option to generate the main source file used to run the application.</p><p>To import or export databases or CSV/SQL files, the SQLite application needs to configure a filesystem.
The filesystem we use is 9pfs.
Hence, in the <code>Library Configuration</code> section, we select the <code>9pfs</code> filesystem within the <code>vfscore</code> library options.</p><p>Make sure, that both options <code>Virtio PCI device support</code> and <code>Virtio 9P device</code> are selected.
Those can be found in: <code>Platform Configuration</code> -> <code>KVM guest</code> -> <code>Virtio</code>.</p><p><img src=/docs/sessions/04-complex-applications/images/9pfs_options.png alt="9pfs options"></p><h4 id=build>Build</h4><p>We build the application by running:</p><pre><code>$ make
</code></pre><h4 id=test>Test</h4><p>For testing we can use the following SQLite script, which inserts ten values into a table:</p><pre><code>CREATE TABLE tab (d1 int, d2 text);
INSERT INTO tab VALUES (random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text)),
(random(), cast(random() as text));
</code></pre><p>Up next, create a folder in the application folder called <code>sqlite_files</code> and write the above script into a file.
When you run the application, you can specify the path of the newly created folder to the <code>qemu-guest</code> as following:</p><pre><code>$ ./qemu-guest -k ./build/app-sqlite_kvm-x86_64 \
               -e ./sqlite_files \
               -m 500
</code></pre><p>The SQLite start command has several parameters:</p><ul><li><code>k</code> indicates the executable resulting from the build of the entire system together with the <code>SQLite application</code></li><li><code>e</code> indicates the path to the shared directory where the Unikraft filesystem will be mounted</li><li><code>m</code> indicates the memory allocated to the application</li></ul><p>To load the SQLite script, we use the following command <code>.read &lt;sqlite_script_name.sql></code>.
And in the end, we run <code>select * from tab</code> to see the contents of the table.</p><p>If everything runs as expected, then we&rsquo;ll see the following output:</p><pre><code>SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
SQLite version 3.30.1 2019-10-10 20:19:45
Enter &quot;.help&quot; for usage hints.
sqlite&gt; .read script.sql
sqlite&gt; select * from tab;
-4482895989777805454|-110319092326802521
1731384004930241734|4521105937488475129
394829130239418471|-5931220326625632549
4715172377251814631|3421393665393635031
2633802986882468389|174376437407985264
-1691186051150364618|3056262814461654943
-4054754806183404125|-2391909815601847844
-4437812378917371546|-6267837926735068846
8830824471222267926|7672933566995619644
4185269687730257244|-3477150175417807640
sqlite&gt;
</code></pre><h3 id=02-sqlite-new-filesystem-tutorial>02. SQLite New Filesystem (Tutorial)</h3><p>In the previous work item, we have chosen to use 9PFS as the filesystem.
For this work item, we want to change the filesystem to RamFS and load the SQLlite script as we have done in the previous work item.
Find the support files in the <code>work/02-change-filesystem-sqlite/</code> folder of the session directory.</p><p>First, we need to change the filesystem to InitRD.
We can obtain that by using the command <code>make menuconfig</code> and from the <code>vfscore: Configuration</code> option, we select the default root filesystem as <code>InitRD</code>.</p><p><img src=/docs/sessions/04-complex-applications/images/filesystems.png alt="filesystems menu"></p><p>The InitRD filesystem can load only <a href="https://www.ibm.com/docs/en/zos/2.2.0?topic=formats-cpio-format-cpio-archives">cpio archives</a>, so to load our SQLite script into RamFS filesystem, we need to create a cpio out of it.
This can be achieved the following way: Create a folder, move the SQLite script in it, and <code>cd </code>in it.
After that we run the following command:</p><pre><code>$ find -type f | bsdcpio -o --format newc &gt; ../archive.cpio
</code></pre><p>We&rsquo;ll obtain an cpio archive called <code>archive.cpio</code> in the parent directory.</p><p>Next we run the following qemu command to run the instance:</p><pre><code>$ ./qemu-guest -k build/app-sqlite_kvm-x86_64 -m 100 -i archive.cpio
</code></pre><p>If everything runs as expected, then we&rsquo;ll see the following output:</p><pre><code>SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115
SQLite version 3.30.1 2019-10-10 20:19:45
Enter &quot;.help&quot; for usage hints.
sqlite&gt; .read script.sql
sqlite&gt; select * from tab;
-4482895989777805454|-110319092326802521
1731384004930241734|4521105937488475129
394829130239418471|-5931220326625632549
4715172377251814631|3421393665393635031
2633802986882468389|174376437407985264
-1691186051150364618|3056262814461654943
-4054754806183404125|-2391909815601847844
-4437812378917371546|-6267837926735068846
8830824471222267926|7672933566995619644
4185269687730257244|-3477150175417807640
sqlite&gt;
</code></pre><h3 id=03-redis-tutorial>03. Redis (Tutorial)</h3><p>The goal of this tutorial is to get you to set up and run Redis on top of Unikraft.
Find the support files in the <code>work/03-set-up-and-run-redis/</code> folder of the session directory.</p><p><a href=https://redis.io/topics/introduction>Redis</a> is one of the most popular key-value databases, with a design that facilitates the fast writing and reading of data from memory as well as the storage of data on disk to be able to reconstruct the state of data in memory in case of a system restart.
Unlike other data storage systems, Redis supports different types of data structures such as lists, maps, strings, sets, bitmaps, streams.</p><p>The Redis application is formed by a ported external library that depends on other ported libraries for Unikraft (<a href=https://github.com/unikraft/lib-pthread-embedded>pthread-embedded</a>, <a href=https://github.com/unikraft/lib-newlib>newlib</a>, <a href=https://github.com/unikraft/lib-lwip>lwip-network</a> library).
To successfully compile and run the Redis application for the KVM platform and x86-64 architecture, we follow the steps below.</p><h4 id=setup-1>Setup</h4><p>As above, we make sure we have the directory structure to store the local clones of Unikraft, library and application repositories.
The structure should be:</p><pre><code>workdir
|-- unikraft/
|-- libs/
`-- apps/
</code></pre><p>We clone the <a href=https://github.com/unikraft/lib-redis>lib-redis</a> repository in the <code>libs/</code> folder.
We alsoe clonethe library repositories which <a href=https://github.com/unikraft/lib-redis>lib-redis</a> depends on ([pthread-embedded](<a href=https://github.com/unikraft/lib-pthread-embedded>pthread-embedded</a>, <a href=https://github.com/unikraft/lib-newlib>newlib</a> and <a href=https://github.com/unikraft/lib-lwip>lwip</a>) in the <code>libs/</code> folder.</p><p>We clone the <a href=https://github.com/unikraft/app-redis/>app-redis</a> repository in the <code>apps/</code> folder.
In this directory, we need to create two files:</p><ul><li><code>Makefile</code>: it contains rules for building the application as well as specifying the libraries that the application needs</li><li><code>Makefile.uk</code>: used to define variables needed to compile the application or to add application-specific flags</li></ul><p>Also, in the <code>Makefile</code>, the order in which the libraries are mentioned in the <code>LIBS</code> variable is important to avoid the occurrence of compilation errors.</p><pre><code>UK_ROOT ?= $(PWD)/../../unikraft
UK_LIBS ?= $(PWD)/../../libs
LIBS := $(UK_LIBS)/lib-pthread-embedded:$(UK_LIBS)/lib-newlib:$(UK_LIBS)/lib-lwip:$(UK_LIBS)/lib-redis

all:
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS)

$(MAKECMDGOALS):
	@$(MAKE) -C $(UK_ROOT) A=$(PWD) L=$(LIBS) $(MAKECMDGOALS)
</code></pre><h4 id=configure-1>Configure</h4><p>We configure the application by running:</p><pre><code>$ make menuconfig
</code></pre><p>We select the Redis library from the configuration menu, <code>Library Configuration</code> section.
For starters, we select the option to generate the main source file used to run the application.</p><p><img src=/docs/sessions/04-complex-applications/images/redis_menu.png alt="redis selection menu"></p><h4 id=build-1>Build</h4><p>We build the application by running:</p><pre><code>$ make
</code></pre><h4 id=test-1>Test</h4><p>To connect to the Redis server, the network features should be configured.
Hence, in the configuration menu in the <code>Library Configuration</code> section, within the <code>lwip library</code> the following options should be selected:</p><ul><li><code>IPv4</code></li><li><code>UDP support</code></li><li><code>TCP support</code></li><li><code>ICMP support</code></li><li><code>DHCP support</code></li><li><code>Socket API</code></li></ul><p><img src=/docs/sessions/04-complex-applications/images/lwip_redis_menu.png alt="lwip selection menu"></p><p>The Redis application needs a configuration file to start.
Thus, a filesystem should be selected in Unikraft.
The filesystem we used was 9PFS.
So, in the <code>Library Configuration</code> section of the configuration menu, the following selection chain should be made in the vfscore library: <code>VFSCore Interface</code> -> <code>vfscore Configuration</code> -> <code>Automatically mount a root filesystem</code> -> <code>Default root filesystem</code> -> <code>9PFS</code>.</p><p>Therefore, following the steps above, the build of the entire system, together with the Redis application will be successful.
We used a script to run the application in which a bridge and a network interface (<code>kraft0</code>) are created.
The network interface has an IP associated with it used by clients to connect to the Redis server.
Also, the script takes care of starting the Redis server, but also of stopping it, deleting the settings created for the network.</p><pre><code>brctl addbr kraft0
ifconfig kraft0 172.44.0.1
ifconfig kraft0 up

dnsmasq -d \
        --log-queries \
        --bind-dynamic \
        --interface=kraft0 \
        --listen-addr=172.44.0.1 \
        --dhcp-range=172.44.0.2,172.44.0.254,255.255.255.0,12h &amp;&gt; $WORKDIR/dnsmasq.log &amp;

./qemu-guest.sh -k ./build/redis_kvm-x86_64 \
                -a &quot;/redis.conf&quot; \
                -b kraft0 \
                -e ./redis_files
                -m 100
</code></pre><p>The Redis server start command has several parameters:</p><ul><li><code>k</code> indicates the executable resulting from the build of the entire system together with the <code>Redis</code> application</li><li><code>e</code> indicates the path to the shared directory where the Unikraft filesystem will be mounted</li><li><code>b</code> indicates the network interface used for external communication</li><li><code>m</code> indicates the memory allocated to the application</li><li><code>a</code> allows the addition of parameters specific to running the application</li></ul><p>The following image is presenting an overview of our setup:</p><p><img src=/docs/sessions/04-complex-applications/images/redis_setup.png alt="lwip selection menu"></p><p>Consequently, after running the script the Redis server will start and dnsmasq will dynamically assign an IP address.
The IP can be seen in the output of qemu as bellow:</p><p><img src=/docs/sessions/04-complex-applications/images/redis_ip.png alt="redis ip"></p><p>Using the received IP, it will be possible to connect clients to it using <code>redis-cli</code> (the binary <code>redis-cli</code> is the folder for this work item):</p><pre><code>$ ./redis-cli -h 172.88.0.76 -p 6379
172.88.0.2:6379&gt; PING
PONG
172.88.0.2:6379&gt;
</code></pre><h3 id=04-redis-static-ip-address>04. Redis Static IP Address</h3><p>In tutorial above we have dynamically assigned an IP to the network interface used by Unikraft using the <code>dnsmasq</code> utility.
Find the support files in the <code>work/04-obtain-the-ip-statically/</code> folder of the session directory.</p><p>Modify the launching script and run the application with a static IP.
Beware that the assigned IP address must differ from the one assigned on the bridge.</p><p>You can use <code>redis-cli</code>, found in the suport folder to test your changes.
If everything runs as expected you should see the following output:</p><pre><code>$ ./redis-cli -h 172.88.0.76 -p 6379
172.88.0.2:6379&gt; PING
PONG
172.88.0.2:6379&gt;
</code></pre><h3 id=05-redis-benchmarking-tutorial>05. Redis Benchmarking (Tutorial)</h3><p>We aim to do benchmarking for the Redis app running on top of Unikraft and for the Redis running on top of Linux.
Find the support files in the <code>work/05-benchmark-redis/</code> folder of the session directory.
There are three binaries: <code>redis-cli</code>, <code>redis-benchmark</code>, and <code>redis</code>.</p><p>First, we will start by benchmarking <code>redis app</code>, running on Unikraft.
Start the Redis on the top of Unikraft as we have already done at above and in another terminal run the following command:</p><pre><code>$ ./redis-benchmark --csv -q -r 100 -n 10000 -c 1 -h 172.44.0.76 -p 6379 -P 8 -t set,get
</code></pre><p>The description of the used option can be seen here:</p><pre><code>Usage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests&gt;] [-k &lt;boolean&gt;]

 -h &lt;hostname&gt;      Server hostname (default 127.0.0.1)
 -p &lt;port&gt;          Server port (default 6379)
 -c &lt;clients&gt;       Number of parallel connections (default 50)
 -n &lt;requests&gt;      Total number of requests (default 100000)
 -P &lt;numreq&gt;        Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline).
 -q                 Quiet. Just show query/sec values
 --csv              Output in CSV format
 -t &lt;tests&gt;         Only run the comma separated list of tests. The test
                    names are the same as the ones produced as output.
</code></pre><p>If everything runs as expected, you&rsquo;ll see the following output:</p><pre><code>&quot;SET&quot;,&quot;147058.81&quot;
&quot;GET&quot;,&quot;153846.16&quot;
</code></pre><p>The printed values represent <code>requests/second</code> for the operation <code>set</code> and <code>get</code>.</p><p>Further, we will run the executable <code>redis-server</code> (<code>./redis-server</code>), which can be found in the support folder, and the following command (only the IP address of the redis server was changed):</p><pre><code>$ ./redis-benchmark --csv -q -r 100 -n 10000 -c 1 -h 127.0.0.1 -p 6379 -P 8 -t set,get
</code></pre><p>After that you&rsquo;ll get something like this:</p><pre><code>&quot;SET&quot;,&quot;285714.28&quot;
&quot;GET&quot;,&quot;294117.62&quot;
</code></pre><h3 id=06-nginx>06. Nginx</h3><p>The aim of this work item is to set up and run Nginx.
Find the support files in the <code>work/06-set-up-and-run-nginx/</code> folder of the session directory.</p><p>From the point of view of the library dependencies, the nginx app has the same dependencies as the Redis app.
It&rsquo;s your choice how you assign the IP to the VM.</p><p>In the support folder of this work item there is a subfolder called <code>nginx</code> with the following structure:</p><pre><code>nginx_files
`-- nginx/
    |-- conf/
    |   |-- fastcgi.conf
    |   |-- fastcgi_params
    |   |-- koi-utf
    |   |-- koi-win
    |   |-- mime.types
    |   |-- nginx.conf
    |   |-- nginx.conf.default
    |   |-- scgi_params
    |   |-- uwsgi_params
    |   `-- win-utf
    |-- data/
    |   `-- images/
    |       `-- small-img100.png
    |-- html/
    |   |-- 50x.html
    |   `-- index.html
    `-- logs/
        |-- error.log
        `-- nginx.pid
</code></pre><p>The path to the <code>nginx_files</code> folder should be given as a parameter to the <code>-e option</code> of the <code>qemu-guest</code>.
The <code>html/</code> folder stores the files of the website you want to be run.</p><p>If everything works as expected, you should see the following web page in the browser.</p><p><img src=/docs/sessions/04-complex-applications/images/nginx_output.png alt="nginx output"></p><h3 id=07-nginx-benchmarking-tutorial>07. Nginx Benchmarking (Tutorial)</h3><p>Benchmarking Nginx running on the top of Unikraft can be achieved with a utility called <code>iperf</code>.
The package can be easily installed using the command:</p><pre><code>sudo apt-get install -y iperf
</code></pre><p>Next, we will start the nginx app as we have done at the previous work item and then we will open another two terminals.
We&rsquo;ll start an <code>iperf</code> server in the first terminal with the command:</p><pre><code>$ iperf -s
</code></pre><p>In the second terminal we&rsquo;ll start an <code>iperf</code> client with the command:</p><pre><code>$ iperf -c 172.44.0.76 -p 80
</code></pre><p>If everything runs as expected, then we will see the following output:</p><pre><code>------------------------------------------------------------
Client connecting to 172.44.0.76, TCP port 80
TCP window size: 85.0 KByte (default)
------------------------------------------------------------
[  3] local 172.44.0.1 port 33262 connected with 172.44.0.76 port 80
[ ID] Interval       Transfer     Bandwidth
[  3]  0.0-10.0 sec  1.28 GBytes  1.10 Gbits/sec
</code></pre><h3 id=08-give-us-feedback>08. Give Us Feedback</h3><p>We want to know how to make the next sessions better. For this we need your <a href=https://forms.gle/QyvxBx19cK4fUYRS7>feedback</a>. Thank you!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-221c0eb25b4f393f30fd7c711495bed2>7 - Session 05: Contributing to Unikraft</h1><p>The focus of this session will be on porting new libraries to Unikraft and preparing them for upstreaming to the <a href=https://github.com/unikraft>main organization&rsquo;s GitHub</a>.</p><p>Being a library operating system, the unikernels created using Unikraft are mainly a collection of internal and external libraries, alongside the ported application.
As a consequence, a large library pool is mandatory in order to make this project compatible with as many applications as possible.</p><h2 id=reminders>Reminders</h2><p>From earlier sessions we saw that we can add an external library as a dependency for an application by appending it to the <code>$LIBS</code> variable of the application&rsquo;s <code>Makefile</code>:</p><pre><code>LIBS := $(UK_LIBS)/my_lib
</code></pre><p>Having done that, we can then select it in the menuconfig interface in order to be included in the build process.</p><p>Running an unikernel built for <code>kvm</code> can be done using the <code>qemu</code> command as follows:</p><pre><code>$ qemu-system-x86_64 -kernel unikraft_unikernel -nographic
</code></pre><p>The <code>-nographic</code> argument redirects the output generated by the unikernel to the console.</p><p>In <a href=content/en/docs/session/02-behind-scenes/index.md>Session 02: Behind the Scenes</a> we saw that there are two types of libraries:</p><ul><li><strong>internal</strong>, which are generally part of the kernel / core (schedulers, file systems, etc.);</li><li><strong>external</strong>: which generally provide user space-level functionalities</li></ul><p>The external libraries should be placed in the <code>$UK_LIBS</code> folder, which is by default <code>$UK_WORKDIR/libs</code>, and the applications should be placed in the <code>$UK_APPS</code> folder, which is by default <code>$UK_WORKDIR/apps</code>.</p><h2 id=overview>Overview</h2><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/05-contributing-to-unikraft/

$ ls -F
index.md  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/05-contributing-to-unikraft/

$ ls -F
index.md  work/
</code></pre><h3 id=git-structure>Git Structure</h3><p>The <a href=https://github.com/unikraft>organization&rsquo;s GitHub</a> contains <a href=https://github.com/unikraft/unikraft>the main Unikraft repository</a> and separate repositories for external libraries, as well as already ported apps.
In the previous sessions, we saw that the Unikraft repository consists of internal libraries, platform code and architecture code.
It doesn&rsquo;t have any external dependencies, in contrast to the external libraries or applications, which can have external dependencies.</p><p>External libraries can have more specific purposes.
So, we can port a library even just for a single application.
The process of adding new internal libraries is almost the same as for external ones, so further we will focus on porting an external library.</p><p>Also, the main repository has <a href=https://github.com/unikraft/unikraft/issues>open issues</a> to which you can contribute.
In general, this process is done by solving the issue on a fork of the project, and after that making a <a href=https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests>pull request (PR)</a> with your solution.</p><h3 id=example-of-external-library>Example of External Library</h3><p>Let&rsquo;s focus for now on an already ported library: <a href=https://github.com/unikraft/lib-libhogweed>lib-libhogweed</a>.
Let&rsquo;s examine its core components.
Go to the <code>work/01-tut-porting/libs/libhogweed/</code> directory and follow the bookmarks marked with <code>USOC_X</code>, where <code>X</code> is the index of the item in the list, from the files specified in the sections below.</p><h4 id=glue-code>Glue Code</h4><p>In some cases, not all the dependencies of an external library are already present in the Unikraft project, so the solution is to add them manually, as glue code, to the library&rsquo;s sources.</p><p>Another situation when we need glue code is when the ported library comes with test modules, used for testing the library&rsquo;s functionalities.
The goal, in this case, is to wrap all the test modules into one single function.
In this way, we can check the library integrity if we want so by just a single function call.
Moreover, we can create a test framework which can periodically check all of the ported libraries, useful especially for detecting if a new library will interfere with an already ported one.</p><p>Moving back to <code>libhogweed</code>, a practical example of the second case is the <code>run_all_libhogweed_tests(int v)</code> function from <code>libhogweed/testutils_glue.c</code>, line <code>#674</code>, which calls every selected (we will see later how we can make selectable config variables) test module and exits with <code>EXIT_SUCCESS</code> only if it passes over all the tests.
For exposing this API, we should also make a header file with all of the test modules, as well as our wrapper function.</p><p><strong>Note</strong>: Check <code>libhogweed/include/testutils_glue.h</code>.</p><h4 id=configuk>Config.uk</h4><p>The <code>Config.uk</code> file stores all the config variables, which will be visible in <code>make menuconfig</code>.
These variables can be accessed from <code>Makefile.uk</code> or even from C sources, by including <code>"uk/config.h"</code>, using the prefix <code>CONFIG_</code>.</p><p>Moving to the source code, <code>libhogweed/Config.uk</code>, we have:</p><ol><li><p>The main variable of the library which acts as an identifier for it:</p><pre><code>config LIBHOGWEED
	bool &quot;libhogweed - Public-key algorithms&quot;
	default n
</code></pre></li><li><p>We can also set another library&rsquo;s main variable, in this case <code>newlib</code>, which involves including it in the build process:</p><pre><code>select LIBNEWLIBC
</code></pre></li><li><p>Creating an auxiliary menu, containing all the test cases:</p><pre><code>menuconfig TESTSUITE
     bool &quot;testsuite - tests for libhogweed&quot;
     default n
     if TESTSUITE
         config TEST_X
             bool &quot;test x functionality&quot;
             default y
     endif
</code></pre><p>Each test case has its own variable in order to allow testing just some tests from the whole suite.</p></li></ol><h4 id=makefileuk>Makefile.uk</h4><p>The <code>libhogweed/Makefile.uk</code> file is used to:</p><ol><li><p>Register the library to Unikraft&rsquo;s build system:</p><pre><code>$(eval $(call addlib_s,libhogweed,$(CONFIG_LIBHOGWEED)))
</code></pre><p>As you can see, we are registering the library to Unikraft&rsquo;s build system only if the main library&rsquo;s config variable, <code>LIBHOGWEED</code>, is set.</p></li><li><p>Set the URL from where the library will be automatically downloaded at build time:</p><pre><code>LIBHOGWEED_VERSION=3.6
LIBHOGWEED_URL=https://ftp.gnu.org/gnu/nettle/nettle-$(LIBHOGWEED_VERSION).tar.gz
</code></pre></li><li><p>Declare helper variables for the most used paths:</p><pre><code>LIBHOGWEED_EXTRACTED = $(LIBHOGWEED_ORIGIN)/nettle-$(LIBHOGWEED_VERSION)
</code></pre><p>There are some useful default variables, for example:</p><ul><li><code>$LIBNAME_ORIGIN</code>: represents the path where the original library is downloaded and extracted during the build process;</li><li><code>$LIBNAME_BASE</code>: represents the path of the ported library sources(the path appended to the <code>$LIBS</code> variable).</li></ul><p>You can check all reserved variables in <a href=http://docs.unikraft.org/developers-app.html#makefile-uk>the main documentation</a>.</p></li><li><p>Set the locations where the headers are searched:</p><pre><code>// including the path of the glue header added by us
LIBHOGWEED_COMMON_INCLUDES-y += -I$(LIBHOGWEED_BASE)/include
</code></pre><p>You should include the directories with the default library&rsquo;s headers as well as the directories with the glue headers created by you, if it&rsquo;s the case.</p></li><li><p>Add compile flags, used in general for suppressing some compile warnings and making the build process neater:</p><pre><code>LIBHOGWEED_SUPPRESS_FLAGS += -Wno-unused-parameter \
        -Wno-unused-variable -Wno-unused-value -Wno-unused-function \
        -Wno-missing-field-initializers -Wno-implicit-fallthrough \
        -Wno-sign-compare

LIBHOGWEED_CFLAGS-y   += $(LIBHOGWEED_SUPPRESS_FLAGS) \
        -Wno-pointer-to-int-cast -Wno-int-to-pointer-cast
LIBHOGWEED_CXXFLAGS-y += $(LIBHOGWEED_SUPPRESS_FLAGS)
</code></pre></li><li><p>Register the library&rsquo;s sources:</p><pre><code>LIBHOGWEED_SRCS-y += $(LIBHOGWEED_EXTRACTED)/bignum.c
</code></pre></li><li><p>Register the library&rsquo;s tests:</p><pre><code>ifeq ($(CONFIG_RSA_COMPUTE_ROOT_TEST),y)
LIBHOGWEED_SRCS-y += $(LIBHOGWEED_EXTRACTED)/testsuite/rsa-compute-root-test.c
LIBHOGWEED_RSA-COMPUTE-ROOT-TEST_FLAGS-y += -Dtest_main=rsa_compute_root_test
endif
</code></pre><p>There are situations when the test cases have each a <code>main()</code> function.
In order to wrap all the tests into one single main function, we have to modify their main function name by using preprocessing symbols.</p><p>You can read more about compile flags in <a href=http://docs.unikraft.org/developers-app.html#makefile-uk>the main documentation</a>.</p><p><strong>Note</strong>: A good practice is to include a test only if the config variable corresponding to that test is set.</p></li><li><p>This step is very customizable, being like a script executed before starting to compile the unikernel.</p><p>In most cases, and in this case too, the libraries build their own config file through a provided executable, usually named <code>configure</code>:</p><pre><code>$(LIBHOGWEED_EXTRACTED)/config.h: $(LIBHOGWEED_BUILD)/.origin
	$(call verbose_cmd,CONFIG,libhogweed: $(notdir $@), \
        cd $(LIBHOGWEED_EXTRACTED) &amp;&amp; ./configure --enable-mini-gmp \
    )
LIBHOGWEED_PREPARED_DEPS = $(LIBHOGWEED_EXTRACTED)/config.h

$(LIBHOGWEED_BUILD)/.prepared: $(LIBHOGWEED_PREPARED_DEPS)

UK_PREPARE += $(LIBHOGWEED_BUILD)/.prepared
</code></pre><p>We can also do things like generating headers using the original building system, modify sources, etc.</p></li></ol><h3 id=warm-up>Warm-Up</h3><p>Let&rsquo;s check the integrity of this library using its test suite through the exposed wrapper function.</p><p>For this task, you have to move, <a href=https://github.com/unikraft/lib-libhogweed>or clone</a>, the library in the <code>$UK_LIBS</code> folder and the <code>work/01-tut-porting/apps/app-libhogweed</code> application in the <code>$UK_APPS</code> folder.
Fill the <code>TODO</code> lines from the application code: add the <code>libhogweed</code> library as a dependency in its <code>Makefile</code> and call from <code>main.c</code> the function exposed by the library for running the test suite.</p><p>Disable some tests, rebuild, and run again the checker application.</p><p><strong>Note</strong>: The <a href=https://github.com/unikraft/lib-libhogweed><code>libhogweed</code></a> library depends on <a href=https://github.com/unikraft/lib-newlib><code>newlib</code></a>.</p><p><strong>Note</strong>: Remember to select the test suite from <code>menuconfig</code>.
You can also check the library&rsquo;s <code>README.md</code> for additional information.</p><h2 id=summary>Summary</h2><p>We need a large library pool in order to make the Unikraft project compatible with as many applications as possible.</p><p>There are also many ways in which you can contribute to the Unikraft project, and you can find them in <a href=https://github.com/unikraft/unikraft/issues>the issues section</a> of the main repository.</p><h2 id=practical-work>Practical Work</h2><p>Moving to a more hands-on experience, let&rsquo;s port a new library.</p><h3 id=support-files-1>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/05-contributing-to-unikraft/

$ ls -F
index.md  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/05-contributing-to-unikraft/

$ ls -F
index.md  work/
</code></pre><h3 id=00-prepare>00. Prepare</h3><p>Let&rsquo;s suppose that we need kd tree support and that we found a C library, <a href=http://nuclear.mutantstargoat.com/sw/kdtree/><code>kdtree</code></a>, that does what we need.
After downloading and inspecting this library, we can see that it also has a set of examples, which can be used by us to test if we ported this library properly.
Move the skeleton of this library, <code>work/02-task-porting/src/libs/kdtree/</code>, in the <code>$UK_LIBS</code> directory and complete the porting process by following the <code>TODO</code> lines.</p><h3 id=01-declare-library-identifier>01. Declare Library Identifier</h3><p>Let&rsquo;s start by declaring a new config variable in the <code>Config.uk</code> file.
As stated before, this variable will represent the library&rsquo;s identifier.</p><h3 id=02-register-it-to-the-build-system>02. Register it to the Build System</h3><p>For the next steps, the working file will be <code>Makefile.uk</code> from the library&rsquo;s skeleton.
Let&rsquo;s use the previously declared variable: register the library to the build system only if the variable is set.</p><h3 id=03-set-its-url>03. Set its URL</h3><p>Having the library registered, set the <code>URL</code> from where it will be downloaded at build time, and explicitly fetch it.</p><h3 id=04-helper-variables>04 Helper Variables</h3><p>Make a variable with the path of the default directory obtained by extracting the original library&rsquo;s archive.</p><h3 id=05-headers-location>05. Headers Location</h3><p>Add the directory which contains the library&rsquo;s header.</p><p><strong>Hint</strong>: Inspect <code>$LIBKDTREE_EXTRACTED</code>.</p><h3 id=06-add-sources>06. Add Sources</h3><p>Add the library&rsquo;s <code>C</code> sources.</p><p><strong>Hint</strong>: Inspect <code>$LIBKDTREE_EXTRACTED</code>.</p><h3 id=07-additional-requirements>07. Additional Requirements</h3><p>Check the original library&rsquo;s <code>README</code> to see if it needs to be configured first, and add the proper rule if so.</p><h3 id=08-intermediary-check>08. Intermediary Check</h3><p>Until now we have registered the library and its sources, and we should be able to compile an unikernel with it <em>if it doesn&rsquo;t have any more unresolved dependencies</em>.
Move the <code>work/02-task-porting/src/apps/app-kdtree</code> application in the <code>$UK_APPS</code> directory, fill its <code>Makefile</code>, and use it to build an unikernel with our ported library as a dependency!</p><p>If needed, provide additional flags in order to suppress the compile warnings generated by this library.</p><p><strong>Note</strong>: You can leave the application&rsquo;s <code>main() function empty, the resulted unikernel will just print the </code>Unikraft` banner.</p><p><strong>Hint</strong>: You can readme, but the solution isn&rsquo;t here.</p><h3 id=09-add-test-config-variables>09. Add Test Config Variables</h3><p>Now let&rsquo;s make a wrapper for the test cases provided as examples.
Uncomment lines <code>#7-#15</code> from the library&rsquo;s <code>Config.uk</code> and complete <code>TODO_9</code> by adding new config variables for each test case.</p><h3 id=10-register-test-sources>10. Register Test Sources</h3><p>Moving back to the library&rsquo;s <code>Makefile.uk</code>, register the tests sources to the build system.</p><p><strong>Note</strong>: Inspect the functions from the tests.</p><p><strong>Note</strong>: Don&rsquo;t forget to uncomment the lines.</p><h3 id=11-wrapper-glue>11. Wrapper Glue</h3><p>Integrate all the test functions into a glue main.
Also, update the library&rsquo;s <code>include/test_suite_glue.h</code> header accordingly.</p><p><strong>Note</strong>: You can use <code>test_suite_glue.c</code> from the library&rsquo;s skeleton.</p><h3 id=12-register-glue-code>12. Register Glue Code</h3><p>Register both the glue test wrapper source and its header in <code>Makefile.uk</code>.</p><p><strong>Note</strong>: Don&rsquo;t forget to uncomment the lines.</p><h3 id=13-final-verification>13. Final Verification</h3><p>Test the resulted library by calling the test function from the <code>app-kdtree</code> application.</p><h3 id=14-give-us-feedback>14. Give Us Feedback</h3><p>We want to know how to make the next sessions better.
For this we need your <a href=https://forms.gle/SUYnQ4iUoDQo59Bh6>feedback</a>.
Thank you!</p><h2 id=further-reading>Further Reading</h2><p>You can get more in-depth information for the contributing process from <a href=http://docs.unikraft.org/developers-app.html#>the main documentation</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-c8164d0e219bb0f24fd8b32fe7e996e3>8 - Session 06: Testing Unikraft</h1><h2 id=00-the-concept-of-testing>00. The Concept of Testing</h2><p>In this session, we are going to explore the idea of validation by testing.
Even though our main focus will be testing, we&rsquo;ll also tackle other validation methods such as fuzzing and symbolic execution.
Before diving into how we can do testing on Unikraft, let&rsquo;s first focus on several key concepts that are used when talking about testing.</p><p>There are three types of testing: unit testing, integration testing and end-to-end testing.
To better understand the difference between them, we will look over an example of a webshop.
If we&rsquo;re testing the whole workflow (creating an account, logging in, adding products to a cart, placing an order) we will call this <strong>end-to-end testing</strong>.
Our shop also has an analytics feature that allows us to see a couple of data points such as: how many times an article was clicked on, how much time did a user look at it and so on.
To make sure the inventory module and the analytics module are working correctly (a counter in the analytics module increases when we click on a product), we will be writing <strong>integration tests</strong>.
Our shop also has at least an image for every product which should maximize when we&rsquo;re clicking on it. To test this, we would write a <strong>unit test</strong>.</p><p>Running the test suite after each change is called <strong>regression testing</strong>. <strong>Automatic testing</strong> means that the tests are run and verified automatically. <strong>Automated regression testing</strong> is the best practice in software engineering.</p><p>One of the key metrics used in testing is <strong>code coverage</strong>.
This is used to measure the percentage of code that is executed during a test suite run.</p><p>There are three common types of coverage:</p><ul><li><strong>Statement coverage</strong>: the percentage of code statements that are run during the testing</li><li><strong>Branch coverage</strong>: the percentage of branches executed during the testing (e.g. if or while)</li><li><strong>Path coverage</strong>: the percentage of paths executed during the testing</li></ul><p>We&rsquo;ll now go briefly over two other validation techniques: fuzzing and symbolic execution.</p><h3 id=fuzzing>Fuzzing</h3><p><strong>Fuzzing</strong> or fuzz testing is an automated software testing technique that involves providing invalid, unexpected, or random data as inputs to a computer program.
The program is then monitored for exceptions such as crashes, failing built-in code assertions, or potential memory leaks.</p><p>The most popular OS fuzzers are <a href=https://github.com/IntelLabs/kAFL>kAFL</a> and <a href=https://github.com/google/syzkaller>syzkaller</a>, but research in this area is very active.</p><h3 id=symbolic-execution>Symbolic Execution</h3><p>As per Wikipedia, <strong>symbolic</strong> execution is a means of analyzing a program to determine what inputs cause each part of a program to execute.
An interpreter follows the program, assuming symbolic values for inputs rather than obtaining actual inputs as normal execution of the program would.
An example of a program being symbolically executed can be seen in the figure below:</p><p><img src=/docs/sessions/06-testing-unikraft/images/symbex.png alt="Symbolic execution"></p><p>The most popular symbolic execution engines are KLEE, S2E and angr.</p><h2 id=01-existing-testing-frameworks>01. Existing Testing Frameworks</h2><p>Nowadays, testing is usually done using a framework.
There is no single testing framework that can be used for everything but one has plenty of options to chose from.</p><h3 id=linux-testing>Linux Testing</h3><p>The main framework used by Linux for testing is KUnit.
The building block of KUnit are test cases, functions with the signature <code>void (*)(struct kunit *test)</code>. For example:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#204a87;font-weight:700>void</span> <span style=color:#000>example_add_test</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>kunit</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>test</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
  <span style=color:#8f5902;font-style:italic>/* check if calling add(1,0) is equal to 1 */</span>
  <span style=color:#000>KUNIT_EXPECT_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>test</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>add</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>));</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>We can use macros such as <code>KUNIT_EXPECT_EQ</code> to verify results.</p><p>A set of test cases is called a <strong>test suite</strong>.
In the example below, we can see how one can add a test suite.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>kunit_case</span> <span style=color:#000>example_add_cases</span><span style=color:#000;font-weight:700>[]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
        <span style=color:#000>KUNIT_CASE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>example_add_test1</span><span style=color:#000;font-weight:700>),</span>
        <span style=color:#000>KUNIT_CASE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>example_add_test2</span><span style=color:#000;font-weight:700>),</span>
        <span style=color:#000>KUNIT_CASE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>example_add_test3</span><span style=color:#000;font-weight:700>),</span>
        <span style=color:#000;font-weight:700>{}</span>
<span style=color:#000;font-weight:700>};</span>

<span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>kunit_suite</span> <span style=color:#000>example_test_suite</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
        <span style=color:#000;font-weight:700>.</span><span style=color:#000>name</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;example&#34;</span><span style=color:#000;font-weight:700>,</span>
        <span style=color:#000;font-weight:700>.</span><span style=color:#000>init</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>example_test_init</span><span style=color:#000;font-weight:700>,</span>
        <span style=color:#000;font-weight:700>.</span><span style=color:#000>exit</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>example_test_exit</span><span style=color:#000;font-weight:700>,</span>
        <span style=color:#000;font-weight:700>.</span><span style=color:#000>test_cases</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>example_add_cases</span><span style=color:#000;font-weight:700>,</span>
<span style=color:#000;font-weight:700>};</span>
<span style=color:#000>kunit_test_suite</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>example_test_suite</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p>The API is pretty intuitive and thoroughly detailed in the <a href=https://01.org/linuxgraphics/gfx-docs/drm/dev-tools/kunit/usage.html>official documentation</a>.</p><p>KUnit is not the only tool used for testing Linux, there are tens of tools used to test Linux at any time:</p><ul><li>Test suites: Linux Test Project (collection of tools), static code analyzers (Coverity, coccinelle, smatch, sparse), module tests (KUnit), fuzzing tools (Trinity, Syzkaller) and subsystem tests.</li><li>Automatic testing: kisskb, 0Day, kernelci, Kerneltests.</li></ul><p>In the figure below, we can see that as more and better tools were developed we saw an increase in reported vulnerabilities.
There was a peak in 2017, after which a steady decrease which may be caused by the amount of tools used to verify patches before being upstreamed.</p><p><img src=/docs/sessions/06-testing-unikraft/images/linux_vulnerabilities.png alt="arch selection menu"></p><h3 id=osv-testing>OSV Testing</h3><p>Let&rsquo;s see how another unikernel does the testing.
OSv uses a different approach.
They&rsquo;re using the Boost test framework alongside tests consisting of standalone simple applications.
For example, to test <code>read</code> they have the following <a href=https://github.com/cloudius-systems/osv/blob/master/tests/tst-read.cc>standalone app</a>, whereas for <a href=https://github.com/cloudius-systems/osv/blob/master/tests/tst-vfs.cc>testing thevfs</a>, they use boost.</p><h3 id=user-space-testing>User Space Testing</h3><p>Right now, there are a plethora of existing testing frameworks for different programming languages.
For example, Google Test is a testing framework for C++ whereas JUnit for Java.
Let&rsquo;s take a quick look at how Google Test works:</p><p>We have the following C++ code for the factorial in a function.cpp:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>n</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>*=</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#000;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>To create a test file, we&rsquo;ll create a new C++ source that includes <code>gtest/gtest.h</code>
We can now define the tests using the <code>TEST</code> macro. We named this test <code>Negative</code> and added it to the <code>FactorialTest</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#000>TEST</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>FactorialTest</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Negative</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
<span style=color:#000;font-weight:700>...</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>Inside the test we can write C++ code as inside a function and use existing macros for adding test checks via macros such as <code>EXPECT_EQ</code>, <code>EXPECT_GT</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&#34;gtest/gtest.h&#34;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#000>TEST</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>FactorialTest</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Negative</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
      <span style=color:#000>EXPECT_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>));</span>
      <span style=color:#000>EXPECT_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>));</span>
      <span style=color:#000>EXPECT_GT</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>),</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>In order to run the test we add a main function similar to the one below to the test file that we have just created:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#a40000>∗∗</span><span style=color:#000>argv</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>testing</span><span style=color:#ce5c00;font-weight:700>::</span><span style=color:#000>InitGoogleTest</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>argv</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>RUN_ALL_TESTS</span><span style=color:#000;font-weight:700>();</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>Easy?
This is not always the case, for example this <a href=https://github.com/google/googletest/blob/master/googletest/samples/sample9_unittest.cc>sample</a> shows a more advanced and nested test.</p><h2 id=02-unikrafts-testing-framework>02. Unikraft&rsquo;s Testing Framework</h2><p>Unikraft&rsquo;s testing framework, <code>uktest</code>, has been inspired by KUnit and provides a flexible testing API.</p><h3 id=api-overview>API Overview</h3><p>To use the API you have to include <code>uk/test.h</code>.
To register a testsuite, we simply call <code>uk_testsuite_register</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#000>uk_testsuite_register</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>factorial_testsuite</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p>We use the macro <code>UK_TESTCASE</code> to both declare a test suite and add a test case to it:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#000>UK_TESTCASE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>testsuite_name</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>testcase1_name</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
	<span style=color:#000>UK_TEST_EXPECT_SNUM_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>some_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#000>UK_TESTCASE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>testsuite_name</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>testcase2_name</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
	<span style=color:#000>UK_TEST_EXPECT_SNUM_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>some_other_function</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>The entire API can be found <a href=https://github.com/unikraft/unikraft/blob/usoc21/lib/uktest/include/uk/test.h>here</a>.</p><h2 id=03-the-design-behind-unikrafts-testing-framework>03. The Design behind Unikraft&rsquo;s Testing Framework</h2><p>The key ideas that were followed when writing <code>uktest</code> are:</p><ul><li>Non-sophisticated. It should follow an existing framework (e.g. KUnit) in order to reuse the existing documentation and have a smaller learning curve</li><li>Ability to specify when to run the tests during the boot process</li><li>Written in C</li><li>Should not conflict with other unit test frameworks (e.g. the one used for testing libraries and apps such as Google Test)</li><li>BSD-compatible license</li><li>Have the ability to write tests as a whole file or as in-line tests above a method</li></ul><h3 id=how-tests-are-run>How Tests Are Run</h3><p>Unikraft boot process is centred around the idea of constructors.
Not to be confused with class constructors, Unikraft&rsquo;s constructors are simply functions registered in a special section inside the image and ran at boot time.
We use the <code>section</code> <a href=https://gcc.gnu.org/onlinedocs/gcc-3.2/gcc/Variable-Attributes.html>attribute</a> from GCC to tell the compiler to a specific section inside the binary, in our case <code>.uk_ctortab</code>.
Later at boot, we go through each value stored in the section and run it:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#000>uk_ctortab_foreach</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>ctorfn</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>__init_array_start</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>__init_array_end</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!*</span><span style=color:#000>ctorfn</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#204a87;font-weight:700>continue</span><span style=color:#000;font-weight:700>;</span>

  <span style=color:#000>uk_pr_debug</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Call constructor: %p()...</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>ctorfn</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>ctorfn</span><span style=color:#000;font-weight:700>)();</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>There are multiple such loops through the boot code found in <code>ukboot/boot.c</code>.
The testing framework simply registers the test function that needs to be called during the run.</p><h3 id=key-functions-and-data-structures>Key Functions and Data Structures</h3><p>The key structure used is <code>uk_testcase</code> defined as:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_testcase</span> <span style=color:#000;font-weight:700>{</span>
	<span style=color:#8f5902;font-style:italic>/* The name of the test case. */</span>
	<span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>name</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#8f5902;font-style:italic>/* Pointer to the method  */</span>
	<span style=color:#204a87;font-weight:700>void</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>func</span><span style=color:#000;font-weight:700>)(</span><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_testcase</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>self</span><span style=color:#000;font-weight:700>);</span>
	<span style=color:#8f5902;font-style:italic>/* The number of failed assertions in this case. */</span>
	<span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>failed_asserts</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#8f5902;font-style:italic>/* The number of assertions in this case. */</span>
	<span style=color:#204a87;font-weight:700>unsigned</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>total_asserts</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>};</span>
</code></pre></div><p>The macro that we&rsquo;re using to check conditions is <code>UK_TEST_ASSERT</code>.
It is a wrapper over <code>_uk_test_do_assert</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>inline</span> <span style=color:#204a87;font-weight:700>void</span>
<span style=color:#000>_uk_test_do_assert</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_testcase</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>esac</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>bool</span> <span style=color:#000>cond</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>fmt</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...)</span>
<span style=color:#000;font-weight:700>{</span>
	<span style=color:#000;font-weight:700>...</span>
	<span style=color:#000>esac</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>total_asserts</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>;</span>

	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>cond</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
		<span style=color:#000>esac</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>failed_asserts</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#000;font-weight:700>...</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>Basically, what the function does is to increment the number of failed asserts if the condition is false.</p><p>We&rsquo;ve seen that <code>uk_testsuite_register</code> is used to register tests.
What this call boils down to is:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#8f5902;font-style:italic>#define uk_test_at_initcall_prio(suite, class, prio)			\
</span><span style=color:#8f5902;font-style:italic>	static int UK_TESTSUITE_FN(suite)(void)				\
</span><span style=color:#8f5902;font-style:italic>	{								\
</span><span style=color:#8f5902;font-style:italic>		uk_testsuite_add(&amp;suite);				\
</span><span style=color:#8f5902;font-style:italic>		uk_testsuite_run(&amp;suite);				\
</span><span style=color:#8f5902;font-style:italic>		return 0;						\
</span><span style=color:#8f5902;font-style:italic>	}								\
</span><span style=color:#8f5902;font-style:italic>	uk_initcall_class_prio(UK_TESTSUITE_FN(suite), class, prio)
</span></code></pre></div><p>We can see that <code>uk_initcall_class_prio</code> registers the newly defined function as a constructor to be called at a specific time during the boot process.
<code>uk_testsuite_add</code> simply adds the test suite to a linked listed of available test suites.
<code>uk_testsuite_run</code> simply iterates runs all the test cases in the test suite.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#204a87;font-weight:700>int</span>
<span style=color:#000>uk_testsuite_run</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_testsuite</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>suite</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
	<span style=color:#000;font-weight:700>...</span>
	<span style=color:#8f5902;font-style:italic>/* Iterate through all the registered test cases */</span>
	<span style=color:#000>uk_testsuite_for_each_case</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>suite</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>testcase</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>

    <span style=color:#8f5902;font-style:italic>/* Run the test case function
</span><span style=color:#8f5902;font-style:italic>		testcase-&gt;func(testcase);
</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>		/* If one case fails, the whole suite fails. */</span>
		<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>testcase</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>failed_asserts</span> <span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>)</span>
			<span style=color:#000>suite</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>failed_cases</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#000;font-weight:700>}</span>
	<span style=color:#000;font-weight:700>...</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><h2 id=work-items>Work Items</h2><p>In this work session we will go over writing and running tests for Unikraft.
We will use <code>uktest</code> and <code>Google Test</code>.
Make sure you are on the <code>usoc21</code> branch on the core Unikraft repo and <code>staging</code> on all others.
<code>uktest</code> should be enabled from the Kconfig.</p><h3 id=support-files>Support Files</h3><p>Session support files are available <a href="https://drive.google.com/drive/folders/1PEDtvR5W-eMGQgbJusMcDPc6hS6ghYAl?usp=sharing">on Google Drive</a>.
You can use your own setup or the per cloned repos in <code>work.zip</code>.
Take a peek at the solutions in <code>sol.zip</code>.</p><h3 id=01-tutorial-testing-a-simple-application>01. Tutorial: Testing a Simple Application</h3><p>We will begin this session with a very simple example.
We can use the <code>app-helloworld</code> as a starting point.
In <code>main.c</code> remove all the existing code.
The next step is to include <code>uk/test.h</code> and define the factorial function:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;uk/test.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>n</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>*=</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#000;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>We are now ready to add a test suite with a test case:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#000>UK_TESTCASE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>factorial_testsuite</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>factorial_test_positive</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
       <span style=color:#000>UK_TEST_EXPECT_SNUM_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>),</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#000>uk_testsuite_register</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>factorial_testsuite</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p>When we run this application, we should see the following output.</p><pre><code>test: factorial_testsuite-&gt;factorial_test_positive
    :	expected `factorial(2)` to be 2 but was 2 ....................................... [ PASSED ]
</code></pre><p>Throughout this session we will extend this simple app that we have just written.</p><h3 id=02-adding-a-new-test-suite>02. Adding a New Test Suite</h3><p>For this task, you will have to modify the existing factorial application by adding a new function that computes if a number is prime.
Add a new testsuite for this function.</p><h3 id=03-tutorial-testing-vfscore>03. Tutorial: Testing vfscore</h3><p>We begin by adding a new file for the tests called <code>test_stat.c</code> in a newly created folder <code>tests</code> in the <code>vfscore</code> internal library:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>LIBVFSCORE_SRCS-$(CONFIG_LIBVFSCORE_TEST_STAT)</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#4e9a06>\
</span><span style=color:#4e9a06></span>    <span style=color:#204a87;font-weight:700>$(</span>LIBVFSCORE_BASE<span style=color:#204a87;font-weight:700>)</span>/tests/test_stat.c
</code></pre></div><p>We then add the menuconfig option in the <code>if LIBVFSCORE</code> block:</p><pre><code class=language-KConfig data-lang=KConfig>menuconfig LIBVFSCORE_TEST
    bool &quot;Test vfscore&quot;
    select LIBVFSCORE_TEST_STAT if LIBUKTEST_ALL
    default n

if LIBVFSCORE_TEST

config LIBVFSCORE_TEST_STAT
    bool &quot;test: stat()&quot;
    select LIBRAMFS
    default n

endif
</code></pre><p>And finally add a new testsuite with a test case.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;uk/test.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;fcntl.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;errno.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;unistd.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;sys/stat.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;sys/mount.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#204a87;font-weight:700>typedef</span> <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>vfscore_stat</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>rc</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>errcode</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>filename</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span> <span style=color:#000>vfscore_stat_t</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>vfscore_stat_t</span> <span style=color:#000>test_stats</span> <span style=color:#000;font-weight:700>[]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000;font-weight:700>{</span> <span style=color:#000;font-weight:700>.</span><span style=color:#000>rc</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span>    <span style=color:#000;font-weight:700>.</span><span style=color:#000>errcode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span>        <span style=color:#000;font-weight:700>.</span><span style=color:#000>filename</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#4e9a06>&#34;/foo/file.txt&#34;</span> <span style=color:#000;font-weight:700>},</span>
    <span style=color:#000;font-weight:700>{</span> <span style=color:#000;font-weight:700>.</span><span style=color:#000>rc</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span>    <span style=color:#000;font-weight:700>.</span><span style=color:#000>errcode</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>EINVAL</span><span style=color:#000;font-weight:700>,</span>    <span style=color:#000;font-weight:700>.</span><span style=color:#000>filename</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87>NULL</span> <span style=color:#000;font-weight:700>},</span>
<span style=color:#000;font-weight:700>};</span>

<span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>fd</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#000>UK_TESTCASE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>vfscore_stat_testsuite</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>vfscore_test_newfile</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
    <span style=color:#8f5902;font-style:italic>/* First check if mount works all right */</span>
    <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>mount</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;/&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;ramfs&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>);</span>
    <span style=color:#000>UK_TEST_EXPECT_SNUM_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>ret</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span>

    <span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>mkdir</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;/foo&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>S_IRWXU</span><span style=color:#000;font-weight:700>);</span>
    <span style=color:#000>UK_TEST_EXPECT_SNUM_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>ret</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span>

    <span style=color:#000>fd</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>open</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;/foo/file.txt&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>O_WRONLY</span> <span style=color:#ce5c00;font-weight:700>|</span> <span style=color:#000>O_CREAT</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>S_IRWXU</span><span style=color:#000;font-weight:700>);</span>
    <span style=color:#000>UK_TEST_EXPECT_SNUM_GT</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>);</span>

    <span style=color:#000>UK_TEST_EXPECT_SNUM_EQ</span><span style=color:#000;font-weight:700>(</span>
        <span style=color:#000>write</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;hello</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>sizeof</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;hello</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>)),</span>
        <span style=color:#204a87;font-weight:700>sizeof</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;hello</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#000;font-weight:700>);</span>
    <span style=color:#000>fsync</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>fd</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#8f5902;font-style:italic>/* Register the test suite */</span>
<span style=color:#000>uk_testsuite_register</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>vfscore_stat_testsuite</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p>We will be using a simple app without any main function to run the testsuite, the output should be similar with:</p><pre><code>test: vfscore_stat_testsuite-&gt;vfscore_test_newfile
    :	expected `ret` to be 0 but was 0 ................................................ [ PASSED ]
    :	expected `ret` to be 0 but was 0 ................................................ [ PASSED ]
    :	expected `fd` to be greater than 2 but was 3 .................................... [ PASSED ]
    :	expected `write(fd, &quot;hello\n&quot;, sizeof(&quot;hello\n&quot;))` to be 7 but was 7 ............ [ PASSED ]
</code></pre><h3 id=04-add-a-test-suite-for-nolibc>04. Add a Test Suite for nolibc</h3><p>Add a new test suite for nolibc with four test cases in it.
You can use any POSIX function from nolibc for this task.
Feel free to look over the <a href=https://github.com/lancs-net/unikraft/blob/nderjung/uktest/lib/uktest/include/uk/test.h>documentation</a> to write more complex tests.</p><h3 id=05-tutorial-running-google-test-on-unikraft>05. Tutorial: Running Google Test on Unikraft</h3><p>For this tutorial, we will use Google Test under Unikraft.
Aside from <code>lib-googletest</code>, we&rsquo;ll also need to have <code>libcxx</code>, <code>libcxxabi</code>, <code>libunwind</code>, <code>compiler-rt</code> and <code>newlib</code> because we&rsquo;re testing C++ code.</p><p>The second step is to enable the Google Test library and its config option <code>Build google test with main</code>.</p><p>We can now add a new cpp file, <code>main.cpp</code>.
Make sure that the files end in <code>.cpp</code> and not <code>.c</code>, otherwise you&rsquo;ll get lots of errors.
In the source file we&rsquo;ll include <code>gtest/gtest.h</code>
We will now be able to add our factorial function and test it.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>n</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span> <span style=color:#ce5c00;font-weight:700>&lt;=</span> <span style=color:#000>n</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>result</span> <span style=color:#ce5c00;font-weight:700>*=</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#000;font-weight:700>}</span>

  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>result</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#000>TEST</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>FactorialTest</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Negative</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#000>EXPECT_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>5</span><span style=color:#000;font-weight:700>));</span>
  <span style=color:#000>EXPECT_EQ</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>));</span>
  <span style=color:#000>EXPECT_GT</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>Factorial</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>10</span><span style=color:#000;font-weight:700>),</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>);</span>

<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>If we run our unikernel, we should see the following output:</p><pre><code>[==========] Running 1 test from 1 test case.
[----------] Global test environment set-up.
[----------] 1 test from FactorialTest
[ RUN      ] FactorialTest.Negative
[       OK ] FactorialTest.Negative (0 ms)
[----------] 1 test from FactorialTest (0 ms total)

[----------] Global test environment tear-down
[==========] 1 test from 1 test case ran. (0 ms total)
[  PASSED  ] 1 test.
</code></pre><p>We can see that in this case, the tests are being run after the main call, not before!</p><h3 id=06-tutorial-bonus-using-klee-for-symbolic-execution>06. Tutorial (Bonus): Using KLEE for Symbolic Execution</h3><p>One of the most popular symbolic execution engine is <a href=https://klee.github.io/>KLEE</a>.
For convenience, we&rsquo;ll be using Docker.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash>docker pull klee/klee:2.1
docker run --rm -ti --ulimit<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#4e9a06>&#39;stack=-1:-1&#39;</span> klee/klee:2.1
</code></pre></div><p>Let&rsquo;s look over this regular expression program, can you spot any bugs?
We&rsquo;ll create a file <code>ex.c</code> with this code:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;stdio.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>matchhere</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>,</span><span style=color:#204a87;font-weight:700>char</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>);</span>

<span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>matchstar</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>c</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>do</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>matchhere</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>text</span><span style=color:#000;font-weight:700>))</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#000;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>while</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#4e9a06>&#39;\0&#39;</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span><span style=color:#ce5c00;font-weight:700>++</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#000>c</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#000>c</span><span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#4e9a06>&#39;.&#39;</span><span style=color:#000;font-weight:700>));</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>static</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>matchhere</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#000;font-weight:700>)</span>
     <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#4e9a06>&#39;*&#39;</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>matchstar</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>],</span> <span style=color:#000>re</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>2</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>text</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#4e9a06>&#39;$&#39;</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>==</span><span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span><span style=color:#ce5c00;font-weight:700>!=</span><span style=color:#4e9a06>&#39;\0&#39;</span> <span style=color:#ce5c00;font-weight:700>&amp;&amp;</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>==</span><span style=color:#4e9a06>&#39;.&#39;</span> <span style=color:#ce5c00;font-weight:700>||</span> <span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]</span><span style=color:#ce5c00;font-weight:700>==*</span><span style=color:#000>text</span><span style=color:#000;font-weight:700>))</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>matchhere</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>text</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>match</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#4e9a06>&#39;^&#39;</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>matchhere</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#ce5c00;font-weight:700>+</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>text</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>do</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>matchhere</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>text</span><span style=color:#000;font-weight:700>))</span>
      <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
  <span style=color:#000;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>while</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>text</span><span style=color:#ce5c00;font-weight:700>++</span> <span style=color:#ce5c00;font-weight:700>!=</span> <span style=color:#4e9a06>&#39;\0&#39;</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#8f5902;font-style:italic>#define SIZE 7
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>**</span><span style=color:#000>argv</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
  <span style=color:#204a87;font-weight:700>char</span> <span style=color:#000>re</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>SIZE</span><span style=color:#000;font-weight:700>];</span>

  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>read</span><span style=color:#000;font-weight:700>(</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>re</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>SIZE</span> <span style=color:#ce5c00;font-weight:700>-</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#8f5902;font-style:italic>//klee_make_symbolic(re, sizeof re, &#34;re&#34;);
</span><span style=color:#8f5902;font-style:italic></span>
  <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>m</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>match</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>re</span><span style=color:#000;font-weight:700>,</span> <span style=color:#4e9a06>&#34;hello&#34;</span><span style=color:#000;font-weight:700>);</span>
  <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>m</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000>printf</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;Match</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>re</span><span style=color:#000;font-weight:700>);</span>

  <span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>Now, let&rsquo;s run this program symbolically.
To do this, we&rsquo;ll uncomment the <code>klee_make_symbol</code> line, and comment the line with <code>read</code> and <code>printf</code>.
We&rsquo;ll compile the program with <code>clang</code> this time:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash>clang -c -g -emit-llvm  ex.c
</code></pre></div><p>And run it with KLEE:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Bash data-lang=Bash>klee ex.bc
</code></pre></div><p>We&rsquo;ll see the following output:</p><pre><code>KLEE: output directory is &quot;/home/klee/klee-out-4&quot;
KLEE: Using STP solver backend
KLEE: ERROR: ex1.c:13: memory error: out of bound pointer
KLEE: NOTE: now ignoring this error at this location
KLEE: ERROR: ex1.c:15: memory error: out of bound pointer
KLEE: NOTE: now ignoring this error at this location

KLEE: done: total instructions = 5314314
KLEE: done: completed paths = 7692
KLEE: done: generated tests = 6804
</code></pre><p>This tells us that KLEE has found two memory errors.
It also gives us some info about the number of paths and instructions executed.
After the run, a folder <code>klee-last</code> has been generated that contains all the test cases.
We want to find the ones that generated memory errors:</p><pre><code>klee@affd7769bb39:~/klee-last$ ls | grep err
test000018.ptr.err
test000020.ptr.err
</code></pre><p>We look at testcase 18:</p><pre><code>klee@affd7769bb39:~/klee-last$ ktest-tool test000018.ktest
ktest file : 'test000018.ktest'
args       : ['ex1.bc']
num objects: 1
object 0: name: 're'
object 0: size: 7
object 0: data: b'^\x01*\x01*\x01*'
object 0: hex : 0x5e012a012a012a
object 0: text: ^.*.*.*
</code></pre><p>This is just a quick example of the power of symbolic execution, but it comes with one great problem: path explosion.
When we have more complicated programs that have unbounded loops, the number of paths grows exponentially and thus symbolic execution is not viable anymore.</p><h2 id=further-reading>Further Reading</h2><ul><li><a href=https://ocw.mit.edu/ans7870/6/6.005/s16/classes/03-testing/index.html#automated_testing_and_regression_testing>6.005 Reading 3: Test</a></li><li><a href=https://blog.cloudflare.com/a-gentle-introduction-to-linux-kernel-fuzzing/>A gentle introduction to Linux Kernel fuzzing</a></li><li><a href=https://adalogics.com/blog/symbolic-execution-with-klee>Symbolic execution with KLEE</a></li><li><a href=https://www.kernel.org/doc/html/latest/dev-tools/kunit/usage.html>Using KUnit</a></li></ul></div><div class=td-content style=page-break-before:always><h1 id=pg-e8257ea2e30401a82888d38de2231d40>9 - Session 07: Syscall Shim</h1><p>In this session we are going to understand how we can run applications using the binary compatibility layer as well as the inner workings of the system call shim layer.</p><p>One of the obstacles when trying to use Unikraft could be the porting effort of your application.
One way we can avoid this is through binary compatibility.
Binary compatibility is the possibility to take already compiled binaries and run them on top of Unikraft without porting effort and at the same time keeping the benefits of unikernels.
In our case, we support binaries compiled for the Linux kernel.</p><p>In order to achieve binary compatibility with the Linux kernel, we had to find a way to have support for system calls, for this, the <strong>system call shim layer</strong> (also called <strong>syscall shim</strong>) was created.
The system call shim layer provides Linux-style mappings of system call numbers to actual system call handler functions.</p><h2 id=reminders>Reminders</h2><h3 id=configuring-building-and-running-unikraft>Configuring, Building and Running Unikraft</h3><p>At this stage, you should be familiar with the steps of configuring, building and running any application within Unikraft and know the main parts of the architecture.
Below you can see a list of the commands you have used so far.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>kraft list</code></td><td>Get a list of all components that are available for use with kraft</td></tr><tr><td><code>kraft up -t &lt;appname> &lt;your_appname></code></td><td>Download, configure and build existing components into unikernel images</td></tr><tr><td><code>kraft run</code></td><td>Run resulting unikernel image</td></tr><tr><td><code>kraft init -t &lt;appname></code></td><td>Initialize the application</td></tr><tr><td><code>kraft configure</code></td><td>Configure platform and architecture (interactive)</td></tr><tr><td><code>kraft configure -p &lt;plat> -m &lt;arch></code></td><td>Configure platform and architecture (non-interactive)</td></tr><tr><td><code>kraft build</code></td><td>Build the application</td></tr><tr><td><code>kraft clean</code></td><td>Clean the application</td></tr><tr><td><code>kraft clean -p</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make clean</code></td><td>Clean the application</td></tr><tr><td><code>make properclean</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make distclean</code></td><td>Clean the application, also remove <code>.config</code></td></tr><tr><td><code>make menuconfig</code></td><td>Configure application through the main menu</td></tr><tr><td><code>make</code></td><td>Build configured application (in <code>.config</code>)</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image></code></td><td>Start the unikernel</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -e &lt;directory></code></td><td>Start the unikernel with a filesystem mapping of <code>fs0</code> id from <code>&lt;directory></code></td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -g &lt;port> -P</code></td><td>Start the unikernel in debug mode, with GDB server on port <code>&lt;port></code></td></tr></tbody></table><h3 id=system-calls>System Calls</h3><p>A system call is the programmatic way in which a process requests a privileged service from the kernel of the operating system.</p><p>A system call is not a function, but specific assembly instructions that do the following:</p><ul><li>setup information to identify the system call and its parameters</li><li>trigger a kernel mode switch</li><li>retrieve the result of a system call</li></ul><p>In Linux, system calls are identified by a system call ID (a number) and the parameters for system calls are machine word sized (32 or 64 bit).
There can be a maximum of 6 system call parameters.
Both the system call number and the parameters are stored in certain registers.</p><p>For example, on 32bit x86 architecture, the system call identifier is stored in the <code>EAX</code> register, while parameters in registers <code>EBX</code>, <code>ECX</code>, <code>EDX</code>, <code>ESI</code>, <code>EDI</code>, <code>EBP</code>.</p><p>Usually an application does not make a system call directly, but call functions in the system libraries (e.g. libc) that implement the actual system call.</p><p>Let&rsquo;s take an example that you can see in the below image:</p><ol><li>Application program makes a system call by invoking a wrapper function in the C library.</li><li>Each system call has a unique call number which is used by kernel to identify which system call is invoked.
The wrapper function again copies the system call number into specific CPU registers.</li><li>The wrapper function takes care of copying the arguments to the correct registers.</li><li>Now the wrapper function executes trap instruction (<code>int 0x80</code> or <code>syscall</code> or <code>sysenter</code>).
This instruction causes the processor to switch from <em>user mode</em> to <em>kernel mode</em>.</li><li>We reach a trap handler, that will call the correct kernel function based on the id we passed.</li><li>The system call service routine is called.</li></ol><p><img src=https://qph.fs.quoracdn.net/main-qimg-0cb5c3a6e1fd7642ac988badc7598c0c alt=system_call_image></p><p>Now, let&rsquo;s take a quick look at unikernels.
As stated above, in Linux, we use system calls to talk to the operating system, but there is a slight problem.
The system calling process adds some overhead to our application, because we have to do all the extra operations to switch from <em>user space</em> to <em>kernel space</em>.
In unikernels, because we don&rsquo;t have a delimitation between <em>kernel space</em> and <em>user space</em> we do not need system calls so everything can be done as simple function calls.
This is both good and bad.
It is good because we do not get the overhead that Linux does when doing a system call.
At the same time it is bad because we need to find a way to support applications that are compiled on Linux, so application that do system calls, even though we don&rsquo;t need them.</p><h2 id=overview>Overview</h2><h3 id=01-the-process-of-loading-and-running-an-application-with-binary-compatibility>01. The Process of Loading and Running an Application with Binary Compatibility</h3><p>For Unikraft to achieve binary compatibility there are two main objectives that need to be met:</p><ol><li>The ability to pass the binary to Unikraft.</li><li>The ability to load the binary into memory and jump to its entry point.</li></ol><p>For the first point we decided to use the initial ramdisk in order to pass the binary to the unikernel.
With <code>qemu-guest</code>, in order to pass an initial ramdisk to a virtual machine you have to use the <code>-initrd</code> option.
As an example, if we have a <code>helloworld</code> binary, we can pass it to the unikernel with the following command:</p><pre><code>sudo qemu-guest -kernel build/unikernel_image -initrd helloworld_binary
</code></pre><p>After the unikernel gets the binary the next step is to load it into memory.
The dominant format for executables is the <em>Executable and Linkable File</em> format (ELF), so, in order to run executables we need an ELF loader.
The job of the ELF Loader is to load the executable into the main memory.
It does so by reading the program headers located in the ELF formatted executable and acting accordingly.
For example, you can see the program headers of a program by running <code>readelf -l binary</code>:</p><pre><code>$ readelf -l helloworld_binary

Elf file type is DYN (Shared object file)
Entry point 0x8940
There are 8 program headers, starting at offset 64

Program Headers:
  Type           Offset             VirtAddr           PhysAddr
                 FileSiz            MemSiz              Flags  Align
  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x00000000000c013e 0x00000000000c013e  R E    0x200000
  LOAD           0x00000000000c0e40 0x00000000002c0e40 0x00000000002c0e40
                 0x00000000000053b8 0x0000000000006aa0  RW     0x200000
  DYNAMIC        0x00000000000c3c18 0x00000000002c3c18 0x00000000002c3c18
                 0x00000000000001b0 0x00000000000001b0  RW     0x8
  NOTE           0x0000000000000200 0x0000000000000200 0x0000000000000200
                 0x0000000000000044 0x0000000000000044  R      0x4
  TLS            0x00000000000c0e40 0x00000000002c0e40 0x00000000002c0e40
                 0x0000000000000020 0x0000000000000060  R      0x8
  GNU_EH_FRAME   0x00000000000b3d00 0x00000000000b3d00 0x00000000000b3d00
                 0x0000000000001afc 0x0000000000001afc  R      0x4
  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000
                 0x0000000000000000 0x0000000000000000  RW     0x10
  GNU_RELRO      0x00000000000c0e40 0x00000000002c0e40 0x00000000002c0e40
                 0x00000000000031c0 0x00000000000031c0  R      0x1

 Section to Segment mapping:
  Segment Sections...
   00     .note.ABI-tag .note.gnu.build-id .gnu.hash .dynsym .dynstr .rela.dyn .rela.plt .init .plt .plt.got .text __libc_freeres_fn __libc_thread_freeres_fn .fini .rodata .stapsdt.base .eh_frame_hdr .eh_frame .gcc_except_table
   01     .tdata .init_array .fini_array .data.rel.ro .dynamic .got .data __libc_subfreeres __libc_IO_vtables __libc_atexit __libc_thread_subfreeres .bss __libc_freeres_ptrs
   02     .dynamic
   03     .note.ABI-tag .note.gnu.build-id
   04     .tdata .tbss
   05     .eh_frame_hdr
   06
   07     .tdata .init_array .fini_array .data.rel.ro .dynamic .got
</code></pre><p>As an overview of the whole process, when we want to run an application on Unikraft using binary compatibility, the first step is to pass the application to the unikernel as an initial ram disk.
Once the unikernel gets the application, the loader reads the executable segments and loads them accordingly.
After the program is loaded, the last step is to jump to its entry point and start executing.</p><p>The loader that we currently have implemented in Unikraft only supports executables that are static (so all the libraries are part of the executables) and also position-independent.
A position independent binary is a binary that can run correctly independent of the address at which it was loaded.
So we need executables that are built using the <code>-static-pie</code> compiler / linker option, available in GCC since version 8.</p><h3 id=02-unikraft-syscall-shim>02. Unikraft Syscall Shim</h3><p>As stated previously, the system call shim layer in Unikraft is what we use in order to achieve the same system call behaviour as the Linux kernel.</p><p>Let&rsquo;s take a code snippet that does a system call from a binary:</p><pre><code>mov	edx,4		; message length
mov	ecx,msg		; message to write
mov	ebx,1		; file descriptor (stdout)
mov	eax,4		; system call number (sys_write)
syscall		    ; call kernel
</code></pre><p>In this case, when the <code>syscall</code> instruction gets executed, we have to reach the write function inside our unikernel.
In our case, when the <code>syscall</code> instruction gets called there are a few steps taken until we reach the <strong>system call</strong> inside Unikraft:</p><ol><li><p>After the <code>syscall</code> instruction gets executed we reach the <code>ukplat_syscall_handler</code>.
This function has an intermediate role, printing some debug messages and passing the correct parameters further down.
The next function that gets called is the <code>uk_syscall6_r</code> function.</p><pre><code>void ukplat_syscall_handler(struct __regs *r)
{
	UK_ASSERT(r);

	uk_pr_debug(&quot;Binary system call request \&quot;%s\&quot; (%lu) at ip:%p (arg0=0x%lx, arg1=0x%lx, ...)\n&quot;,
         uk_syscall_name(r-&gt;rsyscall), r-&gt;rsyscall,
         (void *) r-&gt;rip, r-&gt;rarg0, r-&gt;rarg1);
	r-&gt;rret0 = uk_syscall6_r(r-&gt;rsyscall,
              r-&gt;rarg0, r-&gt;rarg1, r-&gt;rarg2,
              r-&gt;rarg3, r-&gt;rarg4, r-&gt;rarg5);
}
</code></pre></li><li><p>The <code>uk_syscall6_r</code> is the function that redirects the flow of the program to the actual <strong>system call</strong> function inside the kernel.</p><pre><code>switch (nr) {
	case SYS_brk:
     return uk_syscall_r_brk(arg1);
	case SYS_arch_prctl:
     return uk_syscall_r_arch_prctl(arg1, arg2, arg3);
	case SYS_exit:
     return uk_syscall_r_exit(arg1);
    ...
</code></pre></li></ol><p>All the above functions are generated, so the only thing that we have to do when we want to register a system call to the system call shim layer is to use the correct macros.</p><p>There are four definition macros that we can use in order to add a system call to the system call shim layer:</p><ul><li><code>UK_SYSCALL_DEFINE</code> - to implement the libc style system calls. That returns <code>-1</code> and sets the <code>errno</code> accordingly.</li><li><code>UK_SYSCALL_R_DEFINE</code> - to implement the raw variant which returns a negative error value in case of errors. <code>errno</code> is not used at all.</li></ul><p>The above two macros will generate the following functions:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#8f5902;font-style:italic>/* libc-style system call that returns -1 and sets errno on errors */</span>
<span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>uk_syscall_e_</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>syscall_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg1_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg2_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...);</span>

<span style=color:#8f5902;font-style:italic>/* Raw system call that returns negative error codes on errors */</span>
<span style=color:#204a87;font-weight:700>long</span> <span style=color:#000>uk_syscall_r_</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>syscall_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>long</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg1_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>long</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg2_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...);</span>

<span style=color:#8f5902;font-style:italic>/* libc-style wrapper (the same as uk_syscall_e_&lt;syscall_name&gt; but with actual types) */</span>
<span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>return_type</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>syscall_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg1_type</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg1_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>,</span>
                              <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg2_type</span><span style=color:#ce5c00;font-weight:700>&gt;</span> <span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>arg2_name</span><span style=color:#ce5c00;font-weight:700>&gt;</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000;font-weight:700>...);</span>
</code></pre></div><p>For the case that the libc-style wrapper does not match the signature and return type of the underlying system call, a so called low-level variant of these two macros are available: <code>UK_LLSYSCALL_DEFINE</code>, <code>UK_LLSYSCALL_R_DEFINE</code>.
These macros only generate the <code>uk_syscall_e_&lt;syscall_name></code> and <code>uk_syscall_r_&lt;syscall_name></code> symbols. You can then provide the custom libc-style wrapper on top.</p><p>Apart from using the macro to define the function, we also have to register the system call by adding it to <code>UK_PROVIDED_SYSCALLS-y</code> withing the corresponding <code>Makefile.uk</code> file.
Let&rsquo;s see how this is done with an example for the write system call.
We have the following definition of the write system call:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#000>ssize_t</span> <span style=color:#000>write</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>size_t</span> <span style=color:#000>count</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>ssize_t</span> <span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span>

    <span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>vfs_do_write</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>count</span><span style=color:#000;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
        <span style=color:#000>errno</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>EFAULT</span><span style=color:#000;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#000;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>The next step is to define the function using the correct macro:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C><span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;uk/syscall.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic></span>
<span style=color:#000>UK_SYSCALL_DEFINE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>ssize_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>write</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>size_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>count</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
    <span style=color:#000>ssize_t</span> <span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span>

    <span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>vfs_do_write</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>count</span><span style=color:#000;font-weight:700>);</span>
    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
        <span style=color:#000>errno</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>EFAULT</span><span style=color:#000;font-weight:700>;</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#000;font-weight:700>}</span>
    <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>And the raw variant:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C data-lang=C>    <span style=color:#8f5902;font-style:italic>#include</span> <span style=color:#8f5902;font-style:italic>&lt;uk/syscall.h&gt;</span><span style=color:#8f5902;font-style:italic>
</span><span style=color:#8f5902;font-style:italic></span>
    <span style=color:#000>UK_SYSCALL_R_DEFINE</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>ssize_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>write</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>int</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>const</span> <span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>size_t</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>count</span><span style=color:#000;font-weight:700>)</span>
    <span style=color:#000;font-weight:700>{</span>
        <span style=color:#000>ssize_t</span> <span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span>

        <span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>vfs_do_write</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>fd</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>buf</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>count</span><span style=color:#000;font-weight:700>);</span>
        <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>ret</span> <span style=color:#ce5c00;font-weight:700>&lt;</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
            <span style=color:#204a87;font-weight:700>return</span> <span style=color:#ce5c00;font-weight:700>-</span><span style=color:#000>EFAULT</span><span style=color:#000;font-weight:700>;</span>
        <span style=color:#000;font-weight:700>}</span>
        <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>ret</span><span style=color:#000;font-weight:700>;</span>
    <span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>The last step is to add the system call to <code>UK_PROVIDED_SYSCALLS-y</code> in the <code>Makefile.uk</code> file.
The format is:</p><p><code>UK_PROVIDED_SYSCALLS-$(CONFIG_&lt;YOURLIB>) += &lt;syscall_name>-&lt;number_of_arguments></code></p><p>So, in our case:</p><p><code>UK_PROVIDED_SYSCALLS-$(CONFIG_LIBWRITESYS) += write-3</code></p><h2 id=summary>Summary</h2><p>The binary compatibility layer is a very important part of the Unikraft unikernel.
It helps us run applications that were not build for Unikraft while, at the same time, keeps the classic benefits of Unikraft: speed, security and small memory footprint.</p><h2 id=practical-work>Practical Work</h2><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/07-syscall-shim/

$ ls -F
demo/  images/  index.md  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd content/en/docs/sessions/07-syscall-shim/

$ ls -F
demo/  images/  index.md  work/
</code></pre><h3 id=00-setup>00. Setup</h3><p>For the practical work we will need the following prerequisites:</p><ul><li><p><strong>gcc version >= 8</strong> - installation guide <a href=https://linuxize.com/post/how-to-install-gcc-compiler-on-ubuntu-18-04/>here</a>.</p></li><li><p><strong>the elfloader application</strong> - this is the implementation of our loader which is build like a normal Unikraft application.
You can clone the <a href=https://github.com/skuenzer/app-elfloader/>ELF Loader repository</a>, on the <code>usoc21</code> branch.
This cloned repo should go into the <code>apps</code> folder in your Unikraft directory structure.</p></li><li><p><strong>the configuration file</strong> - you can find the <code>config</code> files in the <code>demo/01</code> and <code>demo/03</code> folder of this session.</p></li><li><p><strong>lwip, zydis, libelf libs</strong> - we have to clone all the repos corresponding to the previously mentioned libraries into the <code>libs</code> folder.
All of them have to be on the <code>staging</code> branch.</p><ul><li><a href=https://github.com/unikraft/lwip.git>lwip</a></li><li><a href=https://github.com/unikraft/lib-zydis.git>zydis</a></li><li><a href=https://github.com/unikraft/lib-libelf.git>libelf</a></li></ul></li><li><p><strong>unikraft</strong> - the <a href=https://github.com/unikraft/unikraft>Unikraft repository</a> must also be cloned and checked out on the <code>usoc21</code> branch.</p></li></ul><p>Set the repositories in a directory of your choosing.
We&rsquo;ll call this directory <code>&lt;WORKDIR></code>.
The final directory structure for this session should look like this:</p><pre><code>workdir/
`-- apps/
|   `-- app-elfloader/ [usoc21]
`-- libs/
|   |-- lwip/ [staging]
|   |-- libelf/ [staging]
|   `-- zydis/ [staging]
`-- unikraft/ [usoc21]
</code></pre><h3 id=01-compiling-the-elf-loader-application>01. Compiling the ELF Loader Application</h3><p>The goal of this task is to make sure that our setup is correct.
The first step is to copy the correct <code>.config</code> file into our application.</p><pre><code>$ cp demo/01/config &lt;WORKDIR&gt;/apps/app-elfloader/.config
</code></pre><p>To check that the config file is the correct one, go to the <code>app-elfloader/</code> directory and configure it:</p><ol><li><p>Change the directory to <code>&lt;WORKDIR>/apps/app-elfloader/</code>.</p></li><li><p>Run <code>make menuconfig</code>.</p></li><li><p>Select <code>library configuration</code>.
It should look like the below picture.
Take a moment and inspect all the sub-menus, especially the syscall-shim one.</p><p><img src=images/config-image alt="Libraries configuration"></p></li></ol><p>If everything is correct, we can run <code>make</code> and the image for our unikernel should be compiled.
In the <code>build</code> folder you should have the <code>elfloader_kvm-x86_64</code> binary.
To also test if it runs correctly:</p><pre><code>.../&lt;WORKDIR&gt;/apps/app-elfloader$ qemu-guest -k build/elfloader_kvm-x86_64

SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                  Tethys 0.5.0~825b1150
[    0.105192] ERR:  &lt;0x3f20000&gt; [appelfloader] No image found (initrd parameter missing?)
</code></pre><p>Because we did not pass an initial ramdisk, the loader does not have anything to load, so that&rsquo;s where the error comes from.</p><h3 id=02-compile-a-static-pie-executable-and-run-it-on-top-of-unikraft>02. Compile a Static-Pie Executable and Run It On Top of Unikraft</h3><p>The next step is to get an executable with the correct format.
We require a static executable that is also PIE (<em>Position-Independent Executable</em>).</p><p>We go to the <code>apps/app-elfloader/example/helloworld</code> directory.
We can see that the directory has a <code>helloworld.c</code> (a simple helloworld program) and a <code>Makefile</code>.
The program will be compiled as a static PIE:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>RM</span> <span style=color:#ce5c00;font-weight:700>=</span> rm -f
<span style=color:#000>CC</span> <span style=color:#ce5c00;font-weight:700>=</span> gcc
<span style=color:#000>CFLAGS</span> <span style=color:#ce5c00;font-weight:700>+=</span> -O2 -g -fpie <span style=color:#8f5902;font-style:italic># fpie generates position independet code in the object file</span>
<span style=color:#000>LDFLAGS</span> <span style=color:#ce5c00;font-weight:700>+=</span> -static-pie <span style=color:#8f5902;font-style:italic># static-pie makes the final linking generate a static and a pie executable</span>
<span style=color:#000>LDLIBS</span> <span style=color:#ce5c00;font-weight:700>+=</span>

<span style=color:#000>all</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>helloworld</span>

<span style=color:#000>%.o</span><span style=color:#ce5c00;font-weight:700>:</span> %.<span style=color:#000>c</span>
	<span style=color:#204a87;font-weight:700>$(</span>CC<span style=color:#204a87;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>$(</span>CFLAGS<span style=color:#204a87;font-weight:700>)</span> -c $&lt; -o <span style=color:#000>$@</span>

<span style=color:#000>%</span><span style=color:#ce5c00;font-weight:700>:</span> %.<span style=color:#000>o</span>
	<span style=color:#204a87;font-weight:700>$(</span>CC<span style=color:#204a87;font-weight:700>)</span> <span style=color:#204a87;font-weight:700>$(</span>LDFLAGS<span style=color:#204a87;font-weight:700>)</span> $^ <span style=color:#204a87;font-weight:700>$(</span>LDLIBS<span style=color:#204a87;font-weight:700>)</span> -o <span style=color:#000>$@</span>

<span style=color:#000>helloworld</span><span style=color:#ce5c00;font-weight:700>:</span> <span style=color:#000>helloworld</span>.<span style=color:#000>o</span>

<span style=color:#000>clean</span><span style=color:#ce5c00;font-weight:700>:</span>
	<span style=color:#204a87;font-weight:700>$(</span>RM<span style=color:#204a87;font-weight:700>)</span> *.o *~ core helloworld
</code></pre></div><p>We can now run <code>make</code> so we can get the <code>helloworld</code> executable:</p><pre><code>.../&lt;WORKDIR&gt;/apps/app-elfloader/example/helloworld$ make
gcc -O2 -g -fpie -c helloworld.c -o helloworld.o
gcc -static-pie helloworld.o  -o helloworld

.../&lt;WORKDIR&gt;/apps/app-elfloader/example/helloworld$ ldd helloworld
	statically linked

.../&lt;WORKDIR&gt;/apps/app-elfloader/example/helloworld$ checksec helloworld
[*] '/home/daniel/Faculty/BachelorThesis/apps/app-elfloader/example/helloworld/helloworld'
    Arch:     amd64-64-little
    RELRO:    Full RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      PIE enabled
</code></pre><p>We can see above from the <code>ldd</code> and <code>checksec</code> output that the <code>helloworld</code> executable is a static PIE.</p><p>Now, the last part is to pass this executable to our unikernel.
We can use the <code>-i</code> option to pass the initial ramdisk to the virtual machine.</p><pre><code>.../&lt;WORKDIR&gt;/apps/app-elfloader$ qemu-guest -k build/elfloader_kvm-x86_64 -i example/helloworld/helloworld

SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                  Tethys 0.5.0~825b1150
Hello world!
</code></pre><p>We can see that the binary is successfully loaded and executed.</p><h3 id=03-diving-deeper>03. Diving Deeper</h3><p>Now that we saw how we can run an executable on top of Unikraft through binary compatibility, let&rsquo;s take a look at what happens behind the scenes.
For this we have to compile the unikernel with debug printing.</p><p>Copy the <code>config_debug</code> file to our application folder:</p><pre><code>$ cp demo/03/config_debug &lt;WORKDIR&gt;/apps/app-elfloader/.config
</code></pre><p>Now, recompile the unikernel:</p><pre><code>.../&lt;WORKDIR&gt;/apps/app-elfloader$ make properclean
[...]
.../&lt;WORKDIR&gt;/apps/app-elfloader$ make
</code></pre><p>Now, let&rsquo;s rerun the previously compiled executable on top of Unikraft:</p><pre><code>.../&lt;WORKDIR&gt;/apps/app-elfloader$ qemu-guest -k build/elfloader_kvm-x86_64 -i example/helloworld/helloworld

SeaBIOS (version 1.10.2-1ubuntu1)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                  Tethys 0.5.0~825b1150
[    0.153848] dbg:  &lt;0x3f20000&gt; [libukboot] Call constructor: 0x10b810()...
[    0.156271] dbg:  &lt;0x3f20000&gt; [appelfloader] Searching for image...
[    0.159115] dbg:  &lt;0x3f20000&gt; [appelfloader] Load image...
[    0.161569] dbg:  &lt;0x3f20000&gt; [appelfloader] build/elfloader_kvm-x86_64: ELF machine type: 62
[    0.164844] dbg:  &lt;0x3f20000&gt; [appelfloader] build/elfloader_kvm-x86_64: ELF OS ABI: 3
[    0.167843] dbg:  &lt;0x3f20000&gt; [appelfloader] build/elfloader_kvm-x86_64: ELF object type: 3
[...]
</code></pre><p>We now have a more detailed output to see exactly what happens.
The debug output is divided as follows:</p><ol><li>Debug information that comes from when the unikernel is executing.</li><li>Debug information that comes from when the binary is executing.</li></ol><p>When the unikernel is executing (so our loader application) there are two phases:</p><ol><li><p>The <em>loading phase</em>: copies the contents of the binary at certain memory zones, as specified by the ELF header.
You can see the loading phase in the debug output:</p><pre><code>[appelfloader] Load image...
[...]
[appelfloader] build/elfloader_kvm-x86_64: Program/Library memory region: 0x3801000-0x3ac88e0 &lt;- this is the memory zone where our binary will be mapped
[appelfloader] build/elfloader_kvm-x86_64: Copying 0x171000 - 0x23113e -&gt; 0x3801000 - 0x38c113e &lt;- actual copying of the binary
[appelfloader] build/elfloader_kvm-x86_64: Zeroing 0x38c113e - 0x38c113e &lt;- zeroing out zones of the binary, like the bss
[...]
</code></pre></li><li><p>The <em>execution phase</em>: sets the correct information on the stack (for example environment variables) and jumps to the program entry point.</p><pre><code>[appelfloader] Execute image...
[appelfloader] build/elfloader_kvm-x86_64: image:          0x3801000 - 0x3ac88e0
[appelfloader] build/elfloader_kvm-x86_64: start:          0x3801000
[appelfloader] build/elfloader_kvm-x86_64: entry:          0x3809940
[appelfloader] build/elfloader_kvm-x86_64: ehdr_phoff:     0x40
[appelfloader] build/elfloader_kvm-x86_64: ehdr_phnum:     8
[appelfloader] build/elfloader_kvm-x86_64: ehdr_phentsize: 0x38
[appelfloader] build/elfloader_kvm-x86_64: rnd16 at 0x3f1ff20
[appelfloader] Jump to program entry point at 0x3809940...
</code></pre></li></ol><p>From this point forward, the binary that we passed in the initial ramdisk starts executing.
Now all the debug messages come from an operation that happened in the binary.
We can also now see the syscall shim layer in action:</p><pre><code>[libsyscall_shim] Binary system call request &quot;write&quot; (1) at ip:0x3851c21 (arg0=0x1, arg1=0x3c01640, ...)
Hello world!
</code></pre><p>In the above case, the binary used a <code>write</code> system call in order to write <em>Hello world!</em> to standard output.</p><h3 id=04-solve-the-missing-syscall>04. Solve the Missing Syscall</h3><p>For the last part of today&rsquo;s session we will try to run another binary on top of Unikraft.
You can find the C program in the <code>04-missing-syscall/</code> directory.
Try compiling it as static-pie and then run it on top of Unikraft.</p><pre><code>[libsyscall_shim] Binary system call request &quot;getcpu&quot; (309) at ip:0x3851926 (arg0=0x3f1fc14, arg1=0x0, ...)
[libsyscall_shim] syscall &quot;getcpu&quot; is not available
[libsyscall_shim] Binary system call request &quot;write&quot; (1) at ip:0x3851cb1 (arg0=0x1, arg1=0x3c01640, ...)
Here we are in the binary, calling getcpu
Getcpu returned: -1
</code></pre><p>Your task is to print a debug message between the <code>Here we are in the binary</code> and <code>Getcpu returned</code> message above and also make the <code>sched_getcpu()</code> return 0.</p><p><strong>Hint 1</strong>: <a href=http://docs.unikraft.org/developers-app.html#syscall-shim-layer>Syscall Shim Layer</a></p><p><strong>Hint 2</strong>: Check the <code>brk.c</code>, <code>Makefile.uk</code> and <code>exportsyms.uk</code> files in the <code>app-elfloader</code> directory.
You do not have to use <code>UK_LLSYSCALL_R_DEFINE</code>, instead, use the two other macros previously described in the session (eg. <code>UK_SYSCALL_DEFINE</code> and <code>UK_SYSCALL_R_DEFINE</code>).</p><h3 id=05-inspect-the-program-flow-of-an-application>05. Inspect the program flow of an application.</h3><p>Take the above C program and compile it directly into Unikraft.
Inspect the flow of the program, see how we get from the application code to the library code and then to the unikernel code.
After you see all the functions that get called, modify the program to skip the library code but still keep the same functionality.</p><p><strong>Hint 1</strong>: You should call a function that is generated with the syscall shim macros.</p><h3 id=06-give-us-feedback>06. Give Us Feedback</h3><p>We want to know how to make the next sessions better. For this we need your <a href=https://forms.gle/cY75bQ3x4wdpxWKKA>feedback</a>. Thank you!</p><h2 id=further-reading>Further Reading</h2><p><a href=https://dtrugman.medium.com/elf-loaders-libraries-and-executables-on-linux-e5cfce318f94>Elf Loaders, Libraries and Executables on Linux</a></p></div><div class=td-content style=page-break-before:always><h1 id=pg-0cf305157c0d79c36b53cb269a783170>10 - Session 08: Basic App Porting</h1><h2 id=reminders>Reminders</h2><h3 id=configuring-building-and-running-unikraft>Configuring, Building and Running Unikraft</h3><p>At this stage, you should be familiar with the steps of configuring, building and running any application within Unikraft and know the main parts of the architecture.
Below you can see a list of the commands you have used so far.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>kraft list</code></td><td>Get a list of all components that are available for use with kraft</td></tr><tr><td><code>kraft up -t &lt;appname> &lt;your_appname></code></td><td>Download, configure and build existing components into unikernel images</td></tr><tr><td><code>kraft run</code></td><td>Run resulting unikernel image</td></tr><tr><td><code>kraft init -t &lt;appname></code></td><td>Initialize the application</td></tr><tr><td><code>kraft configure</code></td><td>Configure platform and architecture (interactive)</td></tr><tr><td><code>kraft configure -p &lt;plat> -m &lt;arch></code></td><td>Configure platform and architecture (non-interactive)</td></tr><tr><td><code>kraft build</code></td><td>Build the application</td></tr><tr><td><code>kraft clean</code></td><td>Clean the application</td></tr><tr><td><code>kraft clean -p</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make clean</code></td><td>Clean the application</td></tr><tr><td><code>make properclean</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make distclean</code></td><td>Clean the application, also remove <code>.config</code></td></tr><tr><td><code>make menuconfig</code></td><td>Configure application through the main menu</td></tr><tr><td><code>make</code></td><td>Build configured application (in <code>.config</code>)</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image></code></td><td>Start the unikernel</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -e &lt;directory></code></td><td>Start the unikernel with a filesystem mapping of <code>fs0</code> id from <code>&lt;directory></code></td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -g &lt;port> -P</code></td><td>Start the unikernel in debug mode, with GDB server on port <code>&lt;port></code></td></tr></tbody></table><h2 id=overview>Overview</h2><p>In previous sessions, you have learnt how to retrieve, configure and build applications which are already supported by Unikraft.
The applications which are supported by Unikraft are located on <a href=https://github.com/unikraft>Unikraft&rsquo;s Github organization</a> and are prefixed with <code>app-</code> (known colloquially as <em>app repos</em> or <code>app-*</code> as <em>app star repos</em>).
Alternatively, when you have used the Unikraft companion command-line client <a href=https://github.com/unikraft/kraft><code>kraft</code></a>, you can view these supported applications by running:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft list add https://github.com/unikraft/app-*
$ kraft list update
$ kraft list --apps
</code></pre></div><p>In this session, we dive into the ways in which you can bring an application which does not already exist within the Unikraft ecosystem.
You wish to make a traditional Linux user space application (which you have access to its source code) to run using Unikraft and to be listed in the command above, and, of course, be run as a single, specialized unikernel.
This tutorial shows you exactly how to do this.</p><h3 id=the-unikraft-build-lifecycle>The Unikraft Build Lifecycle</h3><p>The lifecycle of the construction of a Unikraft unikernel includes several distinct steps:</p><p style=text-align:center><img src=/docs/sessions/08-basic-app-porting/unikraft-overview.svg style=max-width:700px;display:block;margin:auto alt="Diagram of the overview of the Unikraft Build Process">
<strong style=margin-top:20px;display:inline-block>Overview of the Unikraft build process.</strong></p><ol><li>Configuring the Unikraft unikernel application with compile-time options;</li><li>Fetching the remote &ldquo;origin&rdquo; code of libraries;</li><li>Preparing the remote &ldquo;origin&rdquo; code of libraries;</li><li>Compiling the libraries and the core Unikraft code; and,</li><li>Finally, linking a final unikernel executable binary together.</li></ol><p>The above steps are displayed in the diagram.
The Unikraft unikernel targets a specific platform and hardware architecture, which are set during the configuration step of the lifecycle.</p><p>The steps in the lifecycle above are discussed in this tutorial in greater depth.
Particularly, we cover <code>fetch</code>ing, <code>prepare</code>ing and compiling (<code>build</code>ing) &ldquo;external&rdquo; code which is to be used as a Unikraft unikernel application (or library for that matter).</p><h3 id=identifying-a-candidate-application>Identifying a Candidate Application</h3><p>The scope of this tutorial only covers how to bring an application to Unikraft &ldquo;from first principles&rdquo;;
that is, before you use Unikraft, you can access the source files of the application and compile the application natively for Linux user space.
You wish to compile this application against the Unikraft core and any auxiliary necessary third-party libraries in order to make it a unikernel.
Classic examples of these types of applications are open-source ones, such as NGINX, Redis, etc.
Of course, you can work with code which is not open-source, but again, you must be able to access the source files and the build system before you can begin.</p><p>For the sake of simplicity, this tutorial will only be targeting applications which are C/C++-based.
Unikraft supports other compile-time languages, such as Golang, Rust and WASM.
However, the scope of this tutorial only follows an example with a C/++-based program.
Many of the principles in this tutorial, however, can be applied in the same way for said languages, with a bit of context-specific work.
Namely, this may include additional build rules for target files, using specific compilers and linkers, etc.</p><p>It is worth noting that we are only targeting compile-time applications in this tutorial.
Applications written a runtime language, such as Python or Lua, require an interpreter which must be brought to Unikraft first.
There are already lots of these high-level languages supported by Unikraft.
If you wish to run an application written in such a language, please check out the list of available applications.
However, if the language you wish to run is interpreted and not yet available on Unikraft, porting the interpreter would be in the scope of this tutorial, as the steps here would cover the ones needed to bring the interpreter, which is a program after all, as a Unikraft unikernel application.</p><p><strong>Note:</strong> In the case of higher-level languages which are interpreted, you do not need to follow this tutorial.
Instead, simply mount the application code with the relevant Unikernel binary.
For example, mounting a directory with python code to the python Unikraft unikernel.
Please review <a href=/docs/sessions/04-complex-applications/index.md>Session 04: Complex Applications</a> for more information on this topic.</p><h3 id=starting-with-a-linux-user-space-build>Starting with a Linux User Space Build</h3><p>For the remainder of this tutorial, we will be targeting the network utility program <a href=https://github.com/esnet/iperf><code>iperf3</code></a> as our application example we wish to bring to Unikraft.
<code>iperf3</code> is a benchmarking tool, and is used to determine the bandwidth between a client and server.
It makes for an excellent application to be run as a Unikernel because:</p><ul><li>It can run as a &ldquo;server-type&rdquo; application, receiving and processing requests for clients;</li><li>It is a standalone tool which does one thing;</li><li>It&rsquo;s <a href=https://www.gnu.org/software/make/>GNU Make</a> and C-based; and,</li><li>It&rsquo;s quite useful :)</li></ul><p>Bringing an application to Unikraft will involve understanding some of the way in which the application works, especially how it is built.
Usually during the porting process we also end up diving through the source code, and in the worst-case scenario, have to make a change to it.
More on this is covered <a href=#patching-the-application>later in this tutorial</a>.</p><p>We start by simply trying to follow the steps to compile the application from source.</p><h3 id=compiling-the-application-from-source>Compiling the Application from Source</h3><p>The <a href=https://github.com/esnet/iperf/blob/master/README.md><code>README</code></a> for the <code>iperf3</code> program has relatively simple build instructions, and uses GNU Make which is a first good sign.
Unikraft uses GNU Make to handle its internal builds and so when we see an application using Make, it makes porting a little easier.
For non-Make type build systems, such as CMake, Bazel, etc., it is still possible to bring this application to Unikraft, but the flags, files, and compile-time options, etc. will have to be considered with more care as they do not necessarily align in the same ways.
It is still possible to bring an application using an alternative build system, but you must closely follow how the program is built in order to bring it to Unikraft.</p><p>Let&rsquo;s walk through the build process of <code>iperf3</code> from its <code>README</code>:</p><ol><li><p>First we obtain the source code of the application:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ git clone https://github.com/esnet/iperf.git
</code></pre></div></li><li><p>Then, we are asked to configure and build the application:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> ./iperf
$ ./configure<span style=color:#000;font-weight:700>;</span>
$ make
</code></pre></div></li></ol><p>If this has worked for you, your terminal will be greeted with several pieces of useful information:</p><ol><li><p>The first thing we did was run <code>./configure</code>: an auto-generated utility program part of the <a href=https://www.gnu.org/software/automake/><code>automake</code></a> build system.
Essentially, it checks the compatibility of your system and the program in question.
If everything went well, it will tell us information about what it checked and what was available.
Usually this &ldquo;<code>./configure</code>"-type program will raise any issues when it finds something missing.
One of the things it is checking is whether you have relevant shared libraries (e.g. <code>.so</code> files) installed on your system which are necessary for the application to run.
The application will be dynamically linked to these shared libraries and they will be referenced at runtime in a traditional Linux user space manner.
If something is missing, usually you must use your Linux-distro&rsquo;s package manager to install this dependency, such as via <code>apt-get</code>.</p><p>The <code>./configure</code> program also comes with a useful <code>--help</code> page where we can learn about which features we would like to turn on and off before the build.
It&rsquo;s useful to study this page and see what is available, as these can later become build options (see <a href=#02-add-fortunes-to-unikrafts-boot-sequence>exercise 2</a>) for the application when it is brought to the Unikraft ecosystem. The only thing to notice for the case of <code>iperf3</code> is that it uses <a href=https://www.openssl.org>OpenSSL</a>.
<a href=https://github.com/unikraft/lib-openssl>Unikraft already has a port of OpenSSL</a>, which means we do not have to port this before starting.
<strong>If, however, there are library dependencies for the target application which do not exist within the Unikraft ecosystem, then these library dependencies will need to be ported first before continuing.</strong>
The remainder of this tutorial also applies to porting libraries to Unikraft.</p></li><li><p>When we next run <code>make</code> in the sequence above, we can see the intermediate object files which are compiled during the compilation process before <code>iperf3</code> is finally linked together to form a final Linux user space binary application.
It can be useful to note these files down, as we will be compiling these files with respect to Unikraft&rsquo;s build system.</p></li></ol><p>You have now built <code>iperf3</code> for Linux user space and we have walked through the build process for the application itself.
In the next section, we prepare ourselves to bring this application to Unikraft.</p><h3 id=setting-up-your-workspace>Setting up Your Workspace</h3><p>Applications which are brought to Unikraft are actually libraries.
Everything in Unikraft is &ldquo;libracized&rdquo;, so it is no surprise to find out that even applications are a form of library: they are a single component which interact with other components; have their own options and build files; and, interact in the same ways in which other libraries interact with each other.
The &ldquo;main&rdquo; difference between actual libraries and applications, is that we later invoke the application&rsquo;s <code>main</code> method.
The different ways to do this are <a href=#invoking-the-applications-main-method>covered later in this tutorial</a>.</p><h3 id=creating-a-boilerplate-microlibrary-for-your-application>Creating a Boilerplate Microlibrary for Your Application</h3><p>To get started, we must create a new library for our application.
The premise here is that we are going to &ldquo;wrap&rdquo; or &ldquo;decorate&rdquo; the source code of <code>iperf3</code> with the <em>lingua franca</em> of Unikraft&rsquo;s build system.
That is, when we eventually build the application, the Unikraft build system will understand where to get the source code files, which ones to compile and how, with respect to the rest of Unikraft&rsquo;s internals and other dependencies.</p><p>Let&rsquo;s first start by initializing a working environment for ourselves:</p><ol><li><p>Let&rsquo;s create a workspace with a typical Unikraft structure using <code>kraft</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> ~/workspace
$ <span style=color:#204a87>export</span> <span style=color:#000>UK_WORKDIR</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#204a87;font-weight:700>$(</span><span style=color:#204a87>pwd</span><span style=color:#204a87;font-weight:700>)</span>
$ kraft list update
$ kraft list pull unikraft@staging
</code></pre></div><p>This will generate the necessary directory structure to build a new Unikraft application, and will also download the latest <code>staging</code> branch of Unikraft&rsquo;s core.
When we list the directories, we should get something like this:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>tree -L <span style=color:#0000cf;font-weight:700>1</span>
</code></pre></div><pre><code>.
├── apps
├── archs
├── libs
├── plats
└── unikraft

5 directories, 0 files
</code></pre></li><li><p>Let&rsquo;s now create a library for <code>iperf3</code>.
We can use <code>kraft</code> to initialize some boilerplate for us too.
To do this, we must first retrieve some information about the program itself.
First, we need to identify the latest version number of <code>iperf3</code>.
GitHub tells us (as of the time of writing this tutorial) that this is <code>3.10.1</code>.</p><p>Unikraft relies on the ability to download the source code of the &ldquo;origin&rdquo; code which is about to be compiled.
Usually these are tarballs or zips.
Ideally, we want to have a version number in the URL so we can safely know the version being downloaded.
However, if the source code is on GitHub, which it is in the case of <code>iperf3</code>, then <code>kraft</code> can figure this out for us.</p><p>We can now use <code>kraft</code> to initialize a template library for us:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> ~/workspace/libs
$ kraft lib init <span style=color:#4e9a06>\
</span><span style=color:#4e9a06></span>   --no-prompt <span style=color:#4e9a06>\
</span><span style=color:#4e9a06></span>   --author-name <span style=color:#4e9a06>&#34;Your Name&#34;</span> <span style=color:#4e9a06>\
</span><span style=color:#4e9a06></span>   --author-email <span style=color:#4e9a06>&#34;your@email.com&#34;</span> <span style=color:#4e9a06>\
</span><span style=color:#4e9a06></span>   --version 3.10.1 <span style=color:#4e9a06>\
</span><span style=color:#4e9a06></span>   --origin https://github.com/esnet/iperf <span style=color:#4e9a06>\
</span><span style=color:#4e9a06></span>   iperf3
</code></pre></div><p><code>kraft</code> will have now generated a new Git repository in <code>~/workspace/libs/iperf3</code> which contains some of the necessary files used to create an external library.
It has also checked out the repository with a default branch of <code>staging</code> and created a blank (empty) commit as the base of the repository.
This is standard practice for Unikraft repositories.</p><p><strong>Note:</strong> Our new library is called <code>libiperf3</code> to Unikraft.
The last argument of <code>kraft lib init</code> will simply prepend <code>lib</code> to whatever string name you give it.
If you are porting a library which is called <code>libsomething</code>, still pass the full name to <code>kraft</code>, it will replace instances of <code>liblibsomething</code> with <code>libsomething</code> during the initialization of the project where appropriate.</p></li><li><p>The next step is to register this library with <code>kraft</code> such that we can use it and manipulate it with the <code>kraft</code> toolchain. To do this, simply add the path of the newly initialized library like so:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft list add ~/workspace/libs/iperf3
</code></pre></div><p>This will modify your <code>.kraftrc</code> file with a new local library.
When you have added this library directory, run the update command so that <code>kraft</code> can realize it:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft list update
</code></pre></div></li><li><p>You should now be able to start using this boilerplate library with Unikraft and <code>kraft</code>.
To view basic information about the library and to confirm everything has worked, you can run:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft list show iperf3
</code></pre></div></li></ol><h3 id=using-your-library-in-a-unikraft-unikernel-application>Using Your Library in a Unikraft Unikernel Application</h3><p>Now that we have a library set up in <code>iperf3</code>&rsquo;s name, located at <code>~/workspace/libs/iperf3</code>, we should immediately start using it so that we can start the porting effort.</p><p>To do this, we create a parallel application which uses both the library we are porting and the Unikraft core source code.</p><ol><li><p>First start by creating a new application structure, which we can do by initializing a blank project:</p><pre><code>$ cd ~/workspace/apps
$ kraft init iperf3
</code></pre></li><li><p>We will now have a &ldquo;empty&rdquo; initialized project;
you&rsquo;ll find boilerplate in this directory, including a <code>kraft.yaml</code> file which will look something like this:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> ~/workspace/apps/iperf3
$ cat kraft.yaml
</code></pre></div><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=color:#204a87;font-weight:700>specification</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#4e9a06>&#39;0.5&#39;</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>unikraft</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>staging</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline></span><span style=color:#204a87;font-weight:700>targets</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>   </span>- <span style=color:#204a87;font-weight:700>architecture</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>x86_84</span><span style=color:#f8f8f8;text-decoration:underline>
</span><span style=color:#f8f8f8;text-decoration:underline>     </span><span style=color:#204a87;font-weight:700>platform</span><span style=color:#000;font-weight:700>:</span><span style=color:#f8f8f8;text-decoration:underline> </span><span style=color:#000>kvm</span><span style=color:#f8f8f8;text-decoration:underline>
</span></code></pre></div></li><li><p>After setting up your application project, we should add the new library we are working on to the application.
This is done via:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft lib add iperf3@staging
</code></pre></div><p><strong>Note:</strong> Remember that the default branch of the library is <code>staging</code> from the <code>kraft lib init</code> command used above.
If you change branch or use an alternative <code>--initial-branch</code>, set it in this step.</p><p>This command will update your <code>kraft.yaml</code> file:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-diff data-lang=diff><span style=color:navy;font-weight:700>diff --git a/kraft.yaml b/kraft.yaml
</span><span style=color:navy;font-weight:700>index 33696bb..c14e480 100644
</span><span style=color:navy;font-weight:700></span><span style=color:#a40000>--- a/kraft.yaml
</span><span style=color:#a40000></span><span style=color:#00a000>+++ b/kraft.yaml
</span><span style=color:#00a000></span><span style=color:purple;font-weight:700>@@ -6,3 +6,6 @@ unikraft:
</span><span style=color:purple;font-weight:700></span>targets:
   - architecture: x86_64
     platform: kvm
<span style=color:#00a000>+libraries:
</span><span style=color:#00a000>+  iperf3:
</span><span style=color:#00a000>+    version: staging
</span></code></pre></div></li><li><p>We are ready to configure the application to use the library.
It should be possible to now see the boilerplate <code>iperf3</code> library within the <a href=https://en.wikipedia.org/wiki/Menuconfig><code>menuconfig</code></a> system by running:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft menuconfig
</code></pre></div><p>within the application folder.
However, it will also be selected automatically since it is in the <code>kraft.yaml</code> file now if you run the configure step:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft configure
</code></pre></div><p>By default, the application targets <code>kvm</code> on <code>x86_64</code>.
Adjust appropriately for your use case either by updating the <code>kraft.yaml</code> file or by setting it the <code>menuconfig</code>.</p></li></ol><p>In the next section, we study the necessary files in the workspace and how we can modify them to bring <code>iperf3</code> into life with Unikraft.</p><h3 id=providing-build-files>Providing Build Files</h3><p>Now we have everything set up.
We can start an iterative process of building the target unikernel with the application.
This process is usually very iterative because it requires building the unikernel step-by-step, including new files to the build, making adjustments, and re-building, etc.</p><ol><li><p>The first thing we must do before we start is to check that <code>fetch</code>ing the remote code for <code>iperf3</code> is possible.
Let&rsquo;s try and do this by running in our application workspace:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> ~/workspace/apps/iperf3
$ kraft fetch
</code></pre></div><p>If this is successful, we should see it download the remote zip file and we should see it saved within our Unikraft application&rsquo;s <code>build/</code>.
The directory with the extracted contents should be located at:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ ls -lsh build/libiperf3/origin/iperf-3.10.1/
</code></pre></div><pre><code>total 988K
 12K -rw-r--r-- 1 root root 9.3K Jun  2 22:29 INSTALL
 12K -rw-r--r-- 1 root root  12K Jun  2 22:29 LICENSE
4.0K -rw-r--r-- 1 root root   23 Jun  2 22:29 Makefile.am
 28K -rw-r--r-- 1 root root  26K Jun  2 22:29 Makefile.in
8.0K -rw-r--r-- 1 root root 6.5K Jun  2 22:29 README.md
 32K -rw-r--r-- 1 root root  31K Jun  2 22:29 RELNOTES.md
368K -rw-r--r-- 1 root root 365K Jun  2 22:29 aclocal.m4
4.0K -rwxr-xr-x 1 root root 2.0K Jun  2 22:29 bootstrap.sh
   0 drwxr-xr-x 2 root root  260 Jun  2 22:29 config
496K -rwxr-xr-x 1 root root 494K Jun  2 22:29 configure
 12K -rw-r--r-- 1 root root  11K Jun  2 22:29 configure.ac
   0 drwxr-xr-x 2 root root  140 Jun  2 22:29 contrib
   0 drwxr-xr-x 3 root root  280 Jun  2 22:29 docs
   0 drwxr-xr-x 2 root root  120 Jun  2 22:29 examples
4.0K -rw-r--r-- 1 root root 3.0K Jun  2 22:29 iperf3.spec.in
4.0K -rwxr-xr-x 1 root root 1.2K Jun  2 22:29 make_release
   0 drwxr-xr-x 2 root root  980 Jun  2 22:29 src
4.0K -rwxr-xr-x 1 root root 1.9K Jun  2 22:29 test_commands.sh
</code></pre><p>If this has not worked, you must fiddle with the preamble at the top of the library&rsquo;s <code>Makefile.uk</code> to ensure that correct paths are being set.
Remove the <code>build/</code> directory and try <code>fetch</code>ing again.</p></li><li><p>Now that we can fetch the remote sources, <code>cd</code> into this directory and perform the <code>./configure</code> step as above.
This will do two things for us.
The first is that it will generate (and this is very common for C-based programs) a <code>config.h</code> file.
This file is a list of macro flags which are used to include or exclude lines of code by the preprocessor.
If the program has one of these, we need it.</p><p><code>iperf3</code> has an <code>iperf_config.h</code> file, so let&rsquo;s copy this file into our Unikraft port of the application.
Make an <code>include/</code> directory in the library&rsquo;s repository and copy the file:</p><pre><code>$ mkdir ~/workspace/libs/iperf3/include
$ cp build/libiperf3/origin/iperf-3.10.1/src/iperf_config.h ~/workspace/libs/iperf3/include
</code></pre><p>Let&rsquo;s indicate in the <code>Makefile.uk</code> of the Unikraft library for <code>iperf3</code> that
this directory exists:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>LIBIPERF3_CINCLUDES-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> -I<span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_BASE<span style=color:#204a87;font-weight:700>)</span>/include
</code></pre></div><p>We&rsquo;ll come back to <code>iperf_config.h</code>: likely it needs edits from us to turn features on or off depending on availability or applicability based on the unikernel-context.
We can also wrap build options here (see <a href=#02-add-fortunes-to-unikrafts-boot-sequence>exercise 2</a>).</p></li><li><p>Next, let&rsquo;s run <code>make</code> with a special flag:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> build/libiperf3/origin/iperf-3.10.1/
$ make -n
</code></pre></div><p>This flag, <code>-n</code>, has just shown us what <code>make</code> will run; the full commands for <code>gcc</code> including flags.
What&rsquo;s interesting here is any line which start with:</p><pre><code>$ echo &quot;  CC      &quot;
</code></pre><p>These are lines which invoke <code>gcc</code>.
We can gather a few pieces of information here, namely the flags and list of files we need to make <code>iperf3</code> a reality.</p></li><li><p>Let&rsquo;s start by setting global flags for <code>iperf3</code>.
The rule of thumb here is that we copy the flags which are used in all invocations of <code>gcc</code> and place them within the <code>Makefile.uk</code>.
We should ignore flags to do with optimization, PIE, shared libraries and standard libraries as Unikraft has global build options for these.
Flags which are usually interesting are to do with suppressing warnings, e.g. things that start with <code>-W</code>, and are application-specific.
There doesn&rsquo;t seem to be anything immediately obvious for <code>iperf3</code>.
However, in a later step, we&rsquo;ll find out that we can set some flags.
If you do have flags which are immediately obvious, you set them like so in the library port&rsquo;s <code>Makefile.uk</code>, for example:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>LIBIPERF3_CFLAGS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> -Wno-unused-parameter
</code></pre></div></li><li><p>We have a full list of files for <code>iperf3</code> from step 3.
We can add them as known source files like so to the Unikraft port of <code>iperf3</code>&rsquo;s <code>Makefile.uk</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>LIBIPERF3_SRCS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_SRC<span style=color:#204a87;font-weight:700>)</span>/main.c
<span style=color:#000>LIBIPERF3_SRCS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_SRC<span style=color:#204a87;font-weight:700>)</span>/cjson.c
<span style=color:#000>LIBIPERF3_SRCS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_SRC<span style=color:#204a87;font-weight:700>)</span>/iperf_api.c
<span style=color:#000>LIBIPERF3_SRCS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_SRC<span style=color:#204a87;font-weight:700>)</span>/iperf_error.c
<span style=color:#a40000>...</span>
</code></pre></div><p><strong>Note:</strong> The path in the variable <code>LIBIPERF3_SRC</code> may need to be adjusted from the boilerplate code to match the layout of the application you are porting.</p><p><strong>Tip:</strong> It&rsquo;s best to add these files iteratively, i.e. one-by-one, and attempt the compilation process (step 5) in between adding all files.
This will show you errors about what&rsquo;s missing and you can accurately determine which files are truly necessary for the build.
In addition to this, we can also find intermittent errors which will be the result of incompatibilities between Unikraft and the application in question (covered in the next section on making patches).</p></li><li><p>Now that we have added all the source files, let&rsquo;s try and build the application! This step, again, usually occurs iteratively along with the previous step of adding a new file one-by-one.
Because the application has been <code>configure</code>d and we have <code>fetch</code>ed the contents, we can simply try running the build in the Unikraft application directory:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> ~/workspace/apps/iperf3
$ kraft build
</code></pre></div></li><li><p>(Optional) This step occurs less frequently, but is still useful to discuss in the context of porting an application to Unikraft.
Remember in <a href=#the-unikraft-build-lifecycle>the Unikraft build lifecycle</a> that there is a step which occurs between fetching the remote origin code and compiling it. This step (3), known as <code>prepare</code>, is used to make modifications to the origin code before it is compiled.
This may be useful for applications which have complex build systems or auxiliary files which need to be created or modified before they are built.
Examples for <code>prepare</code>ing include:</p><ul><li>Running scripts which generate new source files from templates;</li><li>Compiling files preemptively before Unikraft starts <code>build</code>ing source files;</li><li>Checking for additional tools or building additional tools which are required to build the library; and,</li><li>Advanced patching techniques to the source files of the library which make changes to it in a non-standard way.</li></ul><p>Preparation is done by adding Make targets to the <code>UK_PREPARE</code> variable:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>UK_PREPARE</span> <span style=color:#ce5c00;font-weight:700>+=</span> mytarget
</code></pre></div><p>Checking whether the library has been <code>prepare</code>d or adding a target which requires preparation before it can be executed is as simple as checking whether the following target exists:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#204a87;font-weight:700>$(</span><span style=color:#000>LIBIPERF</span>3<span style=color:#000>_BUILD</span><span style=color:#204a87;font-weight:700>)</span><span style=color:#a40000>/.patched</span>
</code></pre></div><p>The <code>prepare</code> step is called naturally because of this target.
However, it can be called separately from <code>kraft</code> via:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ kraft prepare
</code></pre></div></li></ol><p>The steps outlined above helped us begin the process of porting a simple application to Unikraft.
It covers the major steps involved in the process of porting &ldquo;from first principles,&rdquo; including addressing all the steps in the construction lifecycle of Unikraft unikernels.</p><p>There are occasional caveats to this process, however.
This is to do with context of the &ldquo;unikernel model,&rdquo; that is, single-purpose OSes with a single address space, acting in a single process without context switches or costly syscalls.
Applications developed for Linux user space make a number of assumptions about its runtime, for example:</p><ul><li>That all syscalls are available (which is not the case for Unikraft, although there is significant work being done to bring more syscalls to Unikraft);</li><li>That the filesystem is complete;</li><li>That P in POSIX is <em>not</em> silent: Unfortunately it is and Unix-type systems do not always adhere to standards and make their own assumptions.
For example, oftentimes there are differences between Linux and BSD-type OSes which need to be accounted for; and,</li><li>That all features are necessary.</li></ul><p>In the next section we address how we can make changes to the application before it is compiled by the Unikraft build system in order to address the points above.</p><h3 id=invoking-the-applications-main-method>Invoking the Application&rsquo;s <code>main</code> Method</h3><p>Traditionally, and by explicit design, Linux user space code invokes a <code>main</code> method (or symbol) for the start-of-execution of application logic.
Unikraft is similar and invokes a <a href=https://gcc.gnu.org/onlinedocs/gcc-4.3.5/gcc/Function-Attributes.html><code>weak</code>-ly attributed symbol</a> for <code>main</code> in <a href=https://github.com/unikraft/unikraft/blob/staging/lib/ukboot/boot.c#L75>its main thread</a>.
This is done so that it can be easily overwritten so as to invoke true application-level functionality.
Without any <code>main</code> method, the unikernel will simply boot and exit.</p><p>All applications must implement the following standard prototype for <code>main</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/* Definition 1 */</span>
<span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>__</span><span style=color:#000;font-weight:700>((</span><span style=color:#000>attribute</span> <span style=color:#000>unused</span><span style=color:#000;font-weight:700>))</span><span style=color:#000>__</span> <span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>__</span><span style=color:#000;font-weight:700>((</span><span style=color:#000>attribute</span> <span style=color:#000>unused</span><span style=color:#000;font-weight:700>))</span><span style=color:#000>__</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>argv</span><span style=color:#000;font-weight:700>[]);</span>
<span style=color:#8f5902;font-style:italic>/* Definition 2 */</span>
<span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>argv</span><span style=color:#000;font-weight:700>[]);</span>
<span style=color:#8f5902;font-style:italic>/* Definition 3 */</span>
<span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><ol><li>The first definition simply indicates that the parameters may be unused within the function body, i.e. no command-line arguments <em>may</em> be passed as the application makes no use of them.</li><li>The second is probably more familiar, with explicit use of command-line arguments.</li><li>Lastly, the third definition explicitly forgoes the use command-line arguments.</li></ol><p>There are two ways to invoke the functionality of the application being ported to Unikraft.</p><h4 id=do-nothing-and-let-main-be-invoked-automatically>Do Nothing and Let <code>main</code> be Invoked Automatically</h4><p>If the application has a relatively simple <code>main</code> method with one of the prototypes defined above, we could simply leave it and it will be automatically invoked since it represents the only symbol named <code>main</code> in the final binary.
This requires the file to be recognised and compiled however, which is done by simply adding the file with the <code>main</code> method to the Unikraft port of the library&rsquo;s <code>Makefile.uk</code> as a new <code>_SRC-y</code> entry.</p><p>For <code>iperf3</code>, this is done by compiling in <code>main.c</code> which contains the <code>main</code> method:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>LIBIPERF3_SRCS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_SRC<span style=color:#204a87;font-weight:700>)</span>/main.c
</code></pre></div><h4 id=manually-invoking-main-with-glue-code>Manually Invoking <code>main</code> with Glue Code</h4><p>To increase extensibility or adapt the application to the context of a unikernel, we can perform a small trick to conditionally invoke the <code>main</code> method of the application as a compile-time option.
This is useful in different cases, for instance:</p><ul><li><p>In some cases where the <code>main</code> method for the application may be relatively complex and includes boilerplate code which is not applicable to the use case of a unikernel, it is possible invoke the relevant application-level functionality by calling another method within the application&rsquo;s source code (this is true in the case of, for example, the <a href=https://github.com/unikraft/lib-python3/blob/staging/main.c>Unikraft port of Python3</a>).</p></li><li><p>In other cases, we may wish to perform additional initialisation before the invocation of the application&rsquo;s <code>main</code> method (this is true in the case of, for example, the <a href=https://github.com/unikraft/lib-redis/blob/staging/main.c>Unikraft port of Redis</a>).</p></li><li><p>We wish to use the application as a library in the future for another application, and call APIs which it may expose.
In this case, we do not wish to invoke the <code>main</code> method as it will conflict with the other application&rsquo;s <code>main</code> method.</p></li></ul><p>In any case, we can rename the default <code>main</code> symbol in the application by using the <code>gcc</code> flag <a href=https://www.rapidtables.com/code/linux/gcc/gcc-d.html><code>-D</code></a> during the pre-processing of the file which contains the method. This flag allows us to define macros in-line, and we can simply introduce a macro which renames the <code>main</code> method to something else.</p><p>With <code>iperf3</code>, for example, we can rename the <code>main</code> method to <code>iperf3_main</code> by adding a new library-specific <code>_FLAGS-y</code> entry in <code>Makefile.uk</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>LIBIPERF3_IPERF3_FLAGS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> -Dmain<span style=color:#ce5c00;font-weight:700>=</span>iperf3_main
</code></pre></div><p>The resulting object file for <code>main.c</code> will no longer include a symbol named <code>main</code>.
At this point, when the final unikernel binary is linked, it will simply quit. We must now provide another <code>main</code> method.</p><p>To conditionally invoke the application&rsquo;s now renamed <code>main</code> method, it is common to provide a new KConfig in the Unikraft library representing the port of the application&rsquo;s <code>Config.uk</code> file, asking whether to &ldquo;provide the main method&rdquo;.
For example, with <code>iperf3</code>:</p><pre><code class=language-KConfig data-lang=KConfig>if LIBIPERF3
config LIBIPERF3_MAIN_FUNCTION
	bool &quot;Provide main function&quot;
	default n
endif
</code></pre><p>When this option is enabled, we can either:</p><ol><li><p>Disable the use of the <code>-D</code> flag as indicated above, conditionally in the <code>Makefile.uk</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#a40000>ifneq(</span><span style=color:#204a87;font-weight:700>$(</span><span style=color:#000>CONFIG_LIBIPERF</span>3<span style=color:#000>_MAIN_FUNCTION</span><span style=color:#204a87;font-weight:700>)</span><span style=color:#a40000>,y)</span>
<span style=color:#000>LIBIPERF3_IPERF3_FLAGS-y</span> <span style=color:#ce5c00;font-weight:700>+=</span> -Dmain<span style=color:#ce5c00;font-weight:700>=</span>iperf3_main
<span style=color:#a40000>endif</span>
</code></pre></div></li><li><p>Or more commonly, introduce a conditional file which provides <code>main</code> and invokes the renamed <code>main</code> (now <code>iperf3_main</code>) method from the library, for example:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#000>LIBIPERF3_SRCS-$(CONFIG_LIBIPERF3_MAIN_FUNCTION)</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_BASE<span style=color:#204a87;font-weight:700>)</span>/main.c<span style=color:#000;font-weight:700>|</span>unikraft
</code></pre></div><p>Notice how the filename is includes the suffix <code>|unikraft</code>.
This is used to simply rename the resulting object file, which will become <code>main.unikraft.io</code>.</p><p>The new <code>main.c</code> file as part of the library simply calls the renamed method:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>main</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>int</span> <span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87;font-weight:700>char</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>argv</span><span style=color:#000;font-weight:700>[])</span>
<span style=color:#000;font-weight:700>{</span>
   <span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>iperf3_main</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>argc</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>argv</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div></li></ol><h3 id=patching-the-application>Patching the Application</h3><p>Patching the application occasionally must occur to address incompatibilities with the context of a Linux user space application and that of the unikernel model.
It can also be used to introduce new features to the application, although this is more rare (although, <a href=https://github.com/unikraft/lib-newlib/blob/staging/patches/0010-enable-per-library-allocator-statistics.patch>here is an example</a>).</p><h4 id=identifying-a-change-to-the-application>Identifying a Change to the Application</h4><p>Identifying a change to the application which requires a patch is sometimes quite subtle.
The process usually occurs during <a href=#providing-build-files>steps 5 and 6 of providing build files</a> of the application or library in question.
During this process, we are expected to see compile-time and link-time errors from <code>gcc</code> as we add new files to the build and make fixes.</p><p>The <code>iperf3</code> application port to Unikraft has four patches in order to make it work.
Let&rsquo;s discuss them and what they mean.
The next section discusses how to create one of these patches.</p><ol><li><p><a href=https://github.com/lancs-net/lib-iperf3/blob/staging/patches/0001-Fix-duplicate-import-of-netinet-tcp.h.patch>The first patch</a> comes from an error which is thrown when compiling the <code>iperf_api.c</code> source file.
This file is 3rd to be compiled from the list of complete source files.
In this file, we are receiving a duplicate import of <code>&lt;netinent/tcp.h></code>, simply removing this import fixes it, so the patch addresses this issue.</p></li><li><p><a href=https://github.com/lancs-net/lib-iperf3/blob/staging/patches/0002-Disable-SO_SNDBUF-and-SO_RCVBUF-checks.patch>The second patch</a> comes as a result of <a href=https://github.com/lwip-tcpip/lwip/blob/b0e347158d8db640c6891f9f31f4e6d19dca200b/src/include/lwip/sockets.h#L220>missing functionality from LwIP</a>.
The issue was discovered once the application was fully ported and was able to boot and run.
When the initialization sequence was on-going between the client and server of <code>iperf3</code>, it would crash during this sequence because LwIP does not support setting this option.
A patch was created simply to remove setting this option.
(Note: this may not be the most sensible approach)</p></li><li><p><a href=https://github.com/lancs-net/lib-iperf3/blob/staging/patches/0003-Set-the-temp-path-to-the-root.patch>The third patch</a> arises from an assumption about the host environment and the difference between Linux user space and a unikernel.
With a traditional host OS, we have a filesystem populated with known paths, for example <code>/tmp</code>.
<code>iperf3</code> assumed this path exists, however, in the case of where no filesystem is provided to the unikernel during boot, which should be possible in some cases, the <code>iperf3</code> application would crash since <code>/tmp</code> does not exist beforehand.
The patch solves this by setting the temporary (ramfs) path to <code>/</code>.
An alternative solution is to make this path at boot.</p></li><li><p>Finally, <a href=https://github.com/lancs-net/lib-iperf3/blob/staging/patches/0004-Disable-use-of-mmap-and-replace-with-mmalloc-and-fr.patch>the fourth patch</a> is once again to do with missing functionality from Unikraft.
In this case, the syscalls <a href=https://linux.die.net/man/2/mmap><code>mmap</code></a> and <a href=https://linux.die.net/man/2/munmap><code>munmap</code></a> are missing.
In this case, <code>iperf3</code>, used <code>mmap</code> simply to statically allocate a region of memory.
The trick used here is to simply replace instances of <code>mmap</code> with <code>malloc</code> and instances of <code>munmap</code> with <code>free</code>.</p><p><strong>Note:</strong> At the time writing this tutorial, <a href=https://github.com/unikraft/unikraft/pull/247><code>mmap</code> and <code>munmap</code> are being actively worked on to be made available as syscalls in Unikraft</a>.</p></li></ol><p>The above patches represent example use cases where patches may be necessary to fix the application when bringing it to Unikraft.
The possibilities presented in this tutorial are non-exhaustive, so take care.</p><p>The next section discusses in detail how to create a patch for the target
application or library.</p><h4 id=preparing-a-patch-for-the-application>Preparing a Patch for the Application</h4><p>When a change is identified and is to be provided as a patch to the application or library during the compilation, it can be done using the procedure identified in this section.
Note that providing patches are an unfortunate workaround to the inherent differences between Linux user space applications and libraries and unikernels.</p><p><strong>Note:</strong> When patches are created, they are also version-specific.
As such, if you update the library or application&rsquo;s code (i.e. by updating, for example, the version number of <code>LIBIPER3_VERSION</code>), patches may no longer be apply-able and will then need to be updated accordingly.</p><p>To make a patch:</p><ol><li><p>First, ensure that the remote origin code has been downloaded to the application&rsquo;s <code>build/</code> folder:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> ~/workspace/apps/iperf3
$ kraft fetch
</code></pre></div></li><li><p>Once the source files have been downloaded, turn it into a Git repository and save everything to an initial commit, in the case of <code>iperf3</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> build/libiperf3/origin/iperf-3.10.1
$ git init
$ git add .
$ git commit -m <span style=color:#4e9a06>&#34;Initial commit&#34;</span>
</code></pre></div><p>This will allow us to make changes to the source files and save those differences.</p></li><li><p>After making changes, create a Git commit, where you briefly describe the change you made and why.
This can be done through a number of successive steps, for example, as a result of having to make several changes to the application.</p></li><li><p>After your changes have been saved to the git log, export them as patches.
For example, if you have made one (<code>1</code>) patch only, export it like so:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>git format-patch HEAD~1
</code></pre></div><p>This will save a new <code>.patch</code> file in the current directory; which should be the origin source files of <code>iperf3</code>.</p></li><li><p>The next step is to create a <code>patches/</code> folder within the Unikraft port of the library and to move the new <code>.patch</code> file into this folder:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>mkdir ~/workspace/libs/iperf3/patches
mv ~/workspace/apps/iperf3/build/libiperf3/origin/iperf-3.10.1/*.patch ~/workspace/libs/iperf3/patches
</code></pre></div></li><li><p>To register patches against Unikraft&rsquo;s build system such that they are applied before the compilation of all source files, simply indicate it in the library&rsquo;s <code>Makefile.uk</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Makefile data-lang=Makefile><span style=color:#8f5902;font-style:italic># Add or edit ~/workspace/libs/iperf3/Makefile.uk
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#000>LIBIPERF3_PATCHDIR</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#204a87;font-weight:700>$(</span>LIBIPERF3_BASE<span style=color:#204a87;font-weight:700>)</span>/patches
</code></pre></div></li></ol><p>This concludes the necessary steps to port an application to Unikraft &ldquo;from first principles&rdquo;.</p><h2 id=work-items>Work Items</h2><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/08-basic-app-porting/

$ ls -F
index.md  sol/  unikraft-overview.svg  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd content/en/docs/sessions/08-basic-app-porting/

$ ls -F
ndex.md  sol/  unikraft-overview.svg  work/
</code></pre><h3 id=01-port-libfortune-to-unikraft>01. Port <code>libfortune</code> to Unikraft</h3><p>(Uni)kernel developers often seek guidance from elders, lost <code>man</code> pages, wizards, source code comments and occasionally swear by the reproducible environment. But the unfortunate truth is that &ldquo;bitshifts happen,&rdquo; and we cannot always <a href=https://www.ggbuddy.com/img/post/oymiswgv/midgvf/3245543291_ac5d471739d22f258621e4e7cbdcb98f_309e11564f795_m.jpg>leverage guidance from mysterious forces</a>.</p><p>A shared library called <a href=https://github.com/nderjung/libfortune><code>libfortune</code></a> can offer solace in such times, providing much needed guidance to those who find themselves in the position of requiring fast boot times and secure memory isolation of an application.
This library is no joke, it will save us all.</p><p>In this mission, if you choose to accept it, port <code>libfortune</code> to Unikraft using the steps in the tutorial above.
<code>libfortune</code> is a simple shared library and should also demonstrate how it is possible to build a library which can be used for both Linux user space as well as Unikraft with a little bit of glue.
If you are successful in porting this library, you should be able to run the <a href=https://github.com/unikraft/summer-of-code-2021/content/en/docs/sessions/08-basic-app-porting/work/01-app-fortune><code>app-fortune</code></a> located in this session&rsquo;s repository folder:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ git clone https://github.com/unikraft/summer-of-code-2021.git
$ <span style=color:#204a87>cd</span> summer-of-code-2021/content/en/docs/sessions/08-basic-app-porting/work/01-app-fortune
$ kraft configure
$ kraft build
$ kraft run
</code></pre></div><pre><code>[...]

SeaBIOS (version rel-1.12.0-59-gc9ba5276e321-prebuilt.qemu.org)
Booting from ROM...
Powered by
o.   .o       _ _               __ _
Oo   Oo  ___ (_) | __ __  __ _ ' _) :_
oO   oO ' _ `| | |/ /  _)' _` | |_|  _)
oOo oOO| | | | |   (| | | (_) |  _) :_
 OoOoO ._, ._:_:_,\_._,  .__,_:_, \___)
                   Tethys 0.5.0~825b115

&quot;It always seems impossible until it is done.&quot;
        -- Nelson Mandela
</code></pre><h3 id=02-add-fortunes-to-unikrafts-boot-sequence>02. Add Fortunes to Unikraft&rsquo;s Boot Sequence</h3><p>In this task, we are diving a little deeper into Unikraft&rsquo;s core and finding an opportunity to meddle with internal features which can prove handy for certain application contexts.
In this case, we are going to play with Unikraft&rsquo;s extensible boot sequence to provide fortunes during the boot of an application.
After word got out, we found that everybody wanted fortunes, right before the application started and <code>main()</code> was called.
This will provide the runtime of the unikernel with good fortune and save it from crashes.</p><p>Unikraft calls various &ldquo;constructor&rdquo; (<code>ctor</code>) and &ldquo;initialiser&rdquo; (<code>init</code>) methods during its boot sequence.
These constructors and initialisers are located in a static section of the final binary image, <code>ctortab</code> and <code>inittab</code>, respectively.
There are 7 entry points during the boot sequence:</p><table><thead><tr><th style=text-align:right>Order</th><th style=text-align:right>Level</th><th>Registering method</th><th>Type</th></tr></thead><tbody><tr><td style=text-align:right>1</td><td style=text-align:right>1</td><td><code>UK_CTOR_PRIO(fn, prio)</code></td><td><code>ctor</code></td></tr><tr><td style=text-align:right>2</td><td style=text-align:right>1</td><td><code>uk_early_initcall_prio(fn, prio)</code></td><td><code>init</code></td></tr><tr><td style=text-align:right>3</td><td style=text-align:right>2</td><td><code>uk_plat_initcall_prio(fn, prio)</code></td><td><code>init</code></td></tr><tr><td style=text-align:right>4</td><td style=text-align:right>3</td><td><code>uk_lib_initcall_prio(fn, prio)</code></td><td><code>init</code></td></tr><tr><td style=text-align:right>5</td><td style=text-align:right>4</td><td><code>uk_rootfs_initcall_prio(fn, prio)</code></td><td><code>init</code></td></tr><tr><td style=text-align:right>6</td><td style=text-align:right>5</td><td><code>uk_sys_initcall_prio(fn, prio)</code></td><td><code>init</code></td></tr><tr><td style=text-align:right>7</td><td style=text-align:right>6</td><td><code>uk_late_initcall_prio(fn, prio)</code></td><td><code>init</code></td></tr></tbody></table><p>New constructors and initialisers can be registered using the methods defined above at various levels (meaning they are called in that order) and at various priorities (between <code>0</code> and <code>9</code>); allowing the registration of numerous constructors or initialisers at the same level.
This allows application developers or library developers to correctly set up the unikernel by registering a constructor or initialiser at the right time or before or after others.</p><p>Initialisers have 6 different levels, allowing code to be injected before certain operations occur during the boot sequence.
This includes, in order: before and after the <code>plat</code>form drivers are initialised; before and after all <code>lib</code>raries are initialised; before and after all filesystems (<code>rootfs</code>) are initialised; and, before and after various &ldquo;<code>sys</code>tem&rdquo; methods are called.</p><p>The source code for this sequence is defined in <a href=https://github.com/unikraft/unikraft/blob/staging/lib/ukboot/boot.c><code>ukboot</code></a>.</p><p>In this task, add a new KConfig option to the Unikraft port of <code>libfortune</code> which allows you to enable or disable the ability to introduce a fortune during the boot sequence of a Unikernel.
Demonstrate the ability of using this library by building the Unikraft port of <code>libfortune</code> to the Unikraft port of <a href=https://github.com/unikraft/app-python3>python3</a> and show a fortune before the Unikraft banner.</p><h3 id=03-create-a-patch-to-introduce-a-new-fortune>03. Create a Patch to Introduce a New Fortune</h3><p>There is a well-known kernel quote, which should be introduced to this library as an Easter egg for unikernel users:</p><p>&ldquo;<a href=https://twitter.com/avsm/status/1265666433914191876>Kernel hacking: where the time to solve a problem is inversely proportional to the size of the resulting diff</a>&rdquo;</p><p>&ndash; Anil Madhavapeddy</p><p>Please add this quote to <code>libfortune</code> as a patch so it is only available when used with unikernels.</p><h3 id=04-give-us-feedback>04. Give Us Feedback</h3><p>We want to know how to make the next sessions better.
For this <a href=https://forms.gle/RY5sZbDqCXyAXH6v6>we need your feedback</a>!</p></div><div class=td-content style=page-break-before:always><h1 id=pg-f352576afa36c9b30f15b2be6533c580>11 - Session 09: Advanced App Porting</h1><h2 id=reminders>Reminders</h2><p>At this stage, you should be familiar with the steps of configuring, building and running any application within Unikraft and know the main parts of the architecture.
Below you can see a list of the commands you have used so far, and will be useful in today&rsquo;s session as well.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>make clean</code></td><td>Clean the application</td></tr><tr><td><code>make properclean</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make distclean</code></td><td>Clean the application, also remove <code>.config</code></td></tr><tr><td><code>make menuconfig</code></td><td>Configure application through the main menu</td></tr><tr><td><code>make</code></td><td>Build configured application (in <code>.config</code>)</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image></code></td><td>Start the unikernel</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -e &lt;directory></code></td><td>Start the unikernel with a filesystem mapping of <code>fs0</code> id from <code>&lt;directory></code></td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -g &lt;port> -P</code></td><td>Start the unikernel in debug mode, with GDB server on port <code>&lt;port></code></td></tr></tbody></table><h2 id=overview>Overview</h2><p>As programs may grow quite complicated, porting them requires a thorough grasp of Unikraft core components, and in certain cases, the addition of new ones.
In this session, we&rsquo;ll take a closer look at Unikraft&rsquo;s core libraries and APIs.</p><h3 id=adding-new-sections-to-an-elf>Adding New Sections to an ELF</h3><p>There are situations in which we want to add new sections in the executable file (ELF format - <em>Executable and Linking Format</em>) for our application or library.
The reason these sections are useful is that the library (or application) becomes much easier to configure, thus serving more purposes.
For example, the Unikraft virtual filesystem (i.e. the <code>vfscore</code> library) uses such a section in which it registers the used filesystem (<code>ramfs</code>, <code>9pfs</code>), and we are going to discuss this in the following sections.
Another component that makes use of additional sections is the scheduler.
The scheduler interface allows us to register a set of functions at build time that will be called when a thread is created or at the end of its execution.</p><p>The way we can add such a section in our application/library is the following:</p><ol><li><p>Create a file with the <code>.ld</code> extension (e.g. extra.ld) with the following content:</p><pre><code>SECTIONS
{
	.my_section : {
     PROVIDE(my_section_start = .);
         KEEP (*(.my_section_entry))
         PROVIDE(my_section_end = .);
	}
}
INSERT AFTER .text;
</code></pre></li><li><p>Add the following line to <code>Makefile.uk</code>:</p><pre><code>LIBYOURAPPNAME_SRCS-$(CONFIG_LIBYOURAPPNAME) += $(LIBYOURAPPNAME_BASE)/extra.ld
</code></pre><p>This will add the <code>.my_section</code> section after the <code>.text</code> section in the ELF file.
The <code>.my_section_entry</code> field will be used to register an entry in this section, and access to it is generally gained via traversing the section&rsquo;s endpoints (i.e. from <code>my_section_start</code> to <code>my_section_end</code>).</p></li></ol><p>But enough with the chit-chat, let&rsquo;s get our hands dirty.
In the <code>/demo/01-extrald-app</code> directory there is an application that defines a new section in the ELF.
Copy this directory to your app&rsquo;s directory.
Your working directory should look like this:</p><pre><code>workdir
|_______apps
|       |_______01-extrald-app
|_______libs
|_______unikraft
</code></pre><p>Before running the program let&rsquo;s analyze the source code.
Look in the <code>main.c</code> file.
We want to register the <code>my-structure</code> structure in the newly added section.
In Unikraft core libraries this is usually done using macros.
So we will do the same.</p><pre><code>#define MY_REGISTER(s, f) static const struct my_structure      \
        __section(&quot;.my_section_entry&quot;)                          \
        __my_section_var __used =                               \
                {.name = (s),                                   \
                .func = (f)};
</code></pre><p>This macro receives the fields of the structure and defines a variable called <code>__my_section_var</code> in the newly added section.
This is done via <code>__section()</code>.
We also use the <code>__used</code> attribute to tell the compiler not to optimize out the variable.
Note that this macro uses different compiler attributes.
Most of these are in <code>uk/essentials.h</code>, so please make sure you include it when working with macros.</p><p>Next, let&rsquo;s analyze the method by which we can go through this section to find the entries.
We must first import the endpoints of the section.
It can be done as follows:</p><pre><code>extern const struct my_structure my_section_start;
extern const struct my_structure my_section_end;
</code></pre><p>Using the endpoints we can write the macro for iterating through the section:</p><pre><code>#define for_each_entry(iter)                                    \
        for (iter = &amp;my_section_start;                          \
                iter &lt; &amp;my_section_end;                         \
                iter++)

</code></pre><div class="alert alert-primary" role=alert><h4 class=alert-heading>Note</h4>If you&rsquo;re not familiar with macros, you may check what they expand to with the GCC&rsquo;s preprocessor.
Remove all the included headers and run <code>gcc -E main.c</code>.</div><p>Let&rsquo;s configure the program.
Use the <code>make menuconfig</code> command to set the KVM platform as in the following image.</p><p><img src=./images/platform_configuration.png alt=platform_configuration></p><p>Save the configuration, exit the menuconfig tab and run <code>make</code>.
Now, let&rsquo;s run it.
You can use the following command:</p><pre><code>$ qemu-guest -k build/01-extrald-app_kvm-x86_64
</code></pre><p>The program&rsquo;s output should be the following:</p><p><img src=./images/01-extrald-app-output.png alt=01-extrald-app-output></p><p>To see that the information about the section size and its start address is correct we will examine the binary using the readelf utility.
The readelf utility is used to display information about ELF files, like sections or segments.
More about it <a href=https://man7.org/linux/man-pages/man1/readelf.1.html>here</a>
Use the following command to display information about the ELF sections:</p><pre><code>$ readelf -S build/01-extrald-app_kvm-x86_64
</code></pre><p>The output should look like this:</p><p><img src=./images/readelf_output.png alt=readelf_output></p><p>We can see that <code>my_section</code> is indeed among the sections of the ELF.
Looking at its size we see that it is 0x10 bytes (the equivalent of 16 in decimal).
We also notice that the start address of the section is 0x1120f0, the same as the one we got from running the program.</p><h3 id=unikraft-apis>Unikraft APIs</h3><p>One important thing to point out regarding Unikraft internal libraries is that for each &ldquo;category&rdquo; of library (e.g., memory allocators, schedulers, filesystems, network drivers, etc.)
Unikraft defines (or will define) an API that each library under that category must comply with.
This is so that it&rsquo;s possible to easily plug and play different libraries of a certain type (e.g., using a co-operative scheduler or a pre-emptive one).</p><h4 id=vfscore>VFScore</h4><p>Take for example the virtual filesystem (i.e. <code>vfscore</code>).
This library provides the implementation of system calls related to filesystem management.
We saw in previous sessions that there are two types of filesystems available in Unikraft <code>ramfs</code> and<code> 9pfs</code>.
Obviously, these two have different implementations of generic file operations, such as reading, writing, etc.
The natural question is: how can we have the same API for system calls (e.g. <code>read</code>,<code> write</code>) but with configurable functionalities?
The answer is by mapping system calls to different implementations.
This is done by using function pointers that redirect the program&rsquo;s flow to the functions we have defined.</p><p>In this regard, the <code>vfscore</code> library provides 2 structures to define operations on the filesystem:</p><pre><code>struct vfsops {
        int (*vfs_mount)        (struct mount *, const char *, int, const void *);
        ...
        struct vnops    *vfs_vnops;
};
</code></pre><pre><code>struct vnops {
        vnop_open_t             vop_open;
        vnop_close_t            vop_close;
        vnop_read_t             vop_read;
        vnop_write_t            vop_write;
        vnop_seek_t             vop_seek;
        vnop_ioctl_t            vop_ioctl;
        ...
};
</code></pre><p>The first structure mainly defines the operation of mounting the filesystem, while the second defines the operations that can be executed on files (regular files, directories, etc).
The <code>vnops</code> structure can be seen as the <code>file_operation</code> structure in the Linux Kernel (more as an idea).
More about this structure <a href=https://tldp.org/LDP/lkmpg/2.4/html/c577.htm>here</a>.</p><p>The filesystem library will define two such structures through which it will provide the specified operations.
To understand how these operations end up being used let&rsquo;s examine the open system call:</p><pre><code>int
sys_open(char *path, int flags, mode_t mode, struct vfscore_file **fpp)
{
        struct vfscore_file *fp;
        struct vnode *vp;
        ...
        error = VOP_OPEN(vp, fp);
}
</code></pre><p><code>VOP_OPEN()</code> is a macro that is defined as follows:</p><pre><code>#define VOP_OPEN(VP, FP)           ((VP)-&gt;v_op-&gt;vop_open)(FP)
</code></pre><p>So the system call will eventually call the registered operation.</p><div class="alert alert-primary" role=alert><h4 class=alert-heading>Note</h4><p>In order to find the source that contains the definition of a structure, function or other component in the <code>unikraft</code> directory you can use the following command:</p><pre><code>$ grep -r &lt;what_you_want_to_search_for&gt;
</code></pre><p>For example:</p><p><img src=./images/grep_r_usage.png alt=grep_r_usage></p></div><p>Let&rsquo;s see now how to link the &ldquo;file operations&rdquo; of a filesystem to the <code>vfscore</code> library.
For this, the library exposes a specific structure named <code>vfscore_fs_type</code>:</p><pre><code>struct vfscore_fs_type {
        const char      *vs_name;       /* name of file system */
        int             (*vs_init)(void); /* initialize routine */
        struct vfsops   *vs_op;         /* pointer to vfs operation */
};
</code></pre><p>Notice that this structure contains a pointer to the <code>vfsops</code> structure, which in turn contains the <code>vnops</code> structure.
To register a filesystem, the <code>vfscore</code> library uses an additional section in the ELF.
You can inspect the <code>extra.ld</code> file, in the <code>vfscore</code> directory to see it.
As we mentioned before, these sections come with help macros, so this time is no exception either.
The macro that registers a filesystem is:</p><pre><code> UK_FS_REGISTER(fssw)
</code></pre><p>Where the <code>fssw</code> argument is a <code>vfscore_fs_type</code> structure.</p><p>There are three other important structures that we should discuss.
First of all, the <code>vnode</code> structure.
This is the abstraction that <code>vfscore</code> provides for a file (no matter its nature, regular, directory, etc), and it can be seen as the equivalent of an inode in Linux-based systems.</p><pre><code>struct vnode {
        uint64_t        v_ino;          /* inode number */
        struct mount    *v_mount;       /* mounted vfs pointer */
        struct vnops    *v_op;          /* vnode operations */
        mode_t          v_mode;         /* file mode */
        off_t           v_size;         /* file size */
        ...
        void            *v_data;        /* private data for fs */
};
</code></pre><p>This structure maintains the metadata of the file, such as the operations we can perform on it, permissions, or the size of the file.
In addition to this, we notice the existence of a <strong>void pointer field</strong> which is used to keep a reference to the specific structures of the filesystem.
This field is used by the two available filesystems and we will use it today in our practical work.</p><p>The <code>dentry</code> structure is the second relevant structure. It offers the possibility to create links (although currently neither <code>ramfs</code> or <code>9pfs</code> does not support hard links).
A dentry can be seen as the equivalent of a path in the filesystem, and it has a pointer to the inode.</p><pre><code>struct dentry {
        char            *d_path;        /* pointer to path in fs */
        struct vnode    *d_vnode;       /* pointer to inode */
        ...
};
</code></pre><p>One thing to point out is that an inode is deleted only when there are no dentries that reference it.</p><p>Last but not least is the <code>mount</code> structure.
Mounting filesystems is the process by which the user makes the contents of a filesystem accessible.
From this point of view, the filesystem, for example, <code>ramfs</code>, is seen as a device on Linux to which we have to associate a directory (technically speaking a dentry).</p><pre><code>struct mount {
        struct vfsops   *m_op;          /* pointer to vfs operation */
        int             m_flags;        /* mount flag */
        char            m_path[PATH_MAX]; /* mounted path */
        ...
        struct dentry   *m_root;        /* root vnode */
};
</code></pre><p>Notice that the mount structure does have a dentry which will point to the inode describing the root directory.</p><h4 id=ramfs>RAMFS</h4><p>Now that we have seen the API of the virtual filesystem, let&rsquo;s go deeper into the hierarchy and look at the implementation of the ramfs filesystem.
For storage, this uses, as the name implies, the memory.
Its advantage is that it is very fast, the disadvantage you probably already guessed it&mldr; From a simplified perspective we can look at a file in ramfs as a buffer in memory.
But wait a minute, if a file is just a memory buffer, doesn&rsquo;t going through so many layers of code mean overhead?
Bien sûr, mi amigo! But having these methods of abstraction makes our work easier in terms of porting an application.
There are applications that need a small filesystem, although the source code is not very easy.
Then we prefer a little overhead than trying to patch the code.</p><p>Let&rsquo;s see how the ramfs system is registered into <code>vfscore</code>. We inspect the code from the <code>ramfs_vfsops.c</code> file from <code>ramfs</code> directory:</p><pre><code>static struct vfscore_fs_type fs_ramfs = {
        .vs_name = &quot;ramfs&quot;,
        .vs_init = NULL,
        .vs_op = &amp;ramfs_vfsops,
};

UK_FS_REGISTER(fs_ramfs);
</code></pre><p>It defines the <code>vfscore_fs_type</code> structure and uses the registration macro for the corresponding section.</p><p>Next, let&rsquo;s look at the specific structure, which is essentially the &ldquo;file&rdquo;:</p><pre><code>struct ramfs_node {
        struct ramfs_node *rn_next;   /* next node in the same directory */
        struct ramfs_node *rn_child;  /* first child node */
        int rn_type;    /* file or directory */
        char *rn_name;    /* name (null-terminated) */
        char *rn_buf;    /* buffer to the file data */
        size_t rn_bufsize;    /* allocated buffer size */
        ...
};
</code></pre><p>This structure contains the file type, the buffer in which the data will be stored, and its size.
A field that normally should not be here is the name, but for the simplicity of the library, it is used.
Unfortunately, the fact that the name field is here and is used in the code does not allow the creation of hard links.</p><p>We notice that the filesystem has the following tree-like structure:</p><p><img src=./images/ramfs_structure.png alt=ramfs_strucutre></p><p>Let&rsquo;s look at how the filesystem is mounted.
In the boot process, the mount syscall from <code>vfscore</code> is called.
This is redirected to the <code>ramfs_mount</code> function as follows:</p><pre><code>UK_SYSCALL_R_DEFINE(int, mount, const char*, dev, const char*, dir,
                const char*, fsname, unsigned long, flags, const void*, data)
{
        ...
        /*
         * Call a file system specific routine.
         */
        if ((error = VFS_MOUNT(mp, dev, flags, data)) != 0)
                goto err4;
        ...
}
</code></pre><p>Now let&rsquo;s examine this specific routine:</p><pre><code>/*
 * Mount a file system.
 */
static int
ramfs_mount(struct mount *mp, const char *dev __unused,
            int flags __unused, const void *data __unused)
{
        struct ramfs_node *np;

        /* Create a root node */
        np = ramfs_allocate_node(&quot;/&quot;, VDIR);

        mp-&gt;m_root-&gt;d_vnode-&gt;v_data = np;

        return 0;
}
</code></pre><p>If we go back to the 3 important structures of <code>vfscore</code>, <code>mount</code>, <code>dentry</code> and <code>vnode</code> we notice this call provides the upper layer the possibility to explore all the file hierarchy.</p><p>The reason why it is important to do the <code>vnode</code> - <code>ramfs_node</code> association is that most operations are done on vnodes.
Thus, in the first phases of a defined operation, references to the <code>ramfs_node</code> field are usually found.
For example:</p><pre><code>static int
ramfs_read(struct vnode *vp, struct vfscore_file *fp __unused,
           struct uio *uio, int ioflag __unused)
{
        struct ramfs_node *np =  vp-&gt;v_data;
        ...
}
</code></pre><h4 id=generic-list-api-in-unikraft>Generic List API in Unikraft</h4><p>Unikraft has an implementation of generic lists similar to those in the Linux kernel.
To use this API, one must include the <code>uk/list.h</code> header.
This type of structure is important because it is a unified way of using linked lists, which is why it is useful to know it, especially if we are working in the Unikraft core.
The <code>uk_list_head</code> structure looks as follows:</p><pre><code>struct uk_list_head {
        struct uk_list_head *next;
        struct uk_list_head *prev;
};
</code></pre><p>The way these lists are built exploits the way of defining structures in C.
A field in a structure is actually just an offset in memory.
To define a list, for example, we just need to include the <code>uk_list_head</code> structure in our container structure:</p><pre><code>struct car {
        char name[50];
        struct uk_list_head list;
};
</code></pre><p>All the list operations, adding, removing, traversing will be performed on the list field.</p><p>The usual routines from this API are:</p><ol><li><code>UK_LIST_HEAD(name)</code> declare the sentinel of a list globally.</li><li><code>UK_INIT_LIST_HEAD(struct uk_list_head *list)</code> declare the sentinel of a list dynamically (i.e. can be used inside a function).</li><li><code>uk_list_add(struct uk_list_head *new_entry, struct uk_list_head *head)</code> add a new entry to the list.</li><li><code>uk_list_entry(ptr, type, field)</code> returns the structure with the type <strong>type</strong> that contains the element <strong>ptr</strong> from the list, having the name <strong>field</strong> within the structure.</li><li><code>uk_list_for_each(p, head)</code> iterates over a list using <strong>p</strong> as a cursor.</li><li><code>uk_list_for_each_safe(p, n, head)</code> iterates over a list using <strong>p</strong> as a cursor and <strong>n</strong> as a temporary cursor.
This is useful for deletion.</li></ol><p>In the <code>/demo/02-linked-list-app</code> directory there is an application that uses generic lists.
Copy this directory to your app&rsquo;s directory.
Run <code>make menuconfig</code> and select the KVM platform.
After that run <code>make</code>.
You can start the program using the following command:</p><pre><code>$ qemu-guest -k build/02-linked-list-app_kvm-x86_64
</code></pre><p>Let&rsquo;s look at the following part of the code:</p><pre><code>        printf(&quot;\nThe structure address for c1 is: %p\n&quot;, c1);
        zero = (struct car *) 0;
        printf(&quot;The offset of list field inside car strucure is: %p\n&quot;,
                &amp;zero-&gt;list);
        printf(&quot;The list field address for c1 is: %p\n&quot;,
                &amp;c1-&gt;list);
        printf(&quot;The address of c1 based on calculation is %p\n&quot;,
                (void *) ((void *) &amp;c1-&gt;list - (void *) &amp;zero-&gt;list));
</code></pre><p>In this part we calculate the offset of the <code>list</code> field within the <code>car</code> structure, which we subtract from the actual address of the <code>list</code> field inside the structure to determine the start address.
This is precisely the way <code>uk_list_entry</code> macro works.</p><h2 id=practical-work>Practical Work</h2><p>All tasks are in the <code>work</code> directory.</p><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><pre><code>$ cd path/to/repository/clone

$ git pull --rebase

$ cd content/en/docs/sessions/09-advanced-app-porting/

$ ls
demo/  images/  index.md/  sol/  work/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><pre><code>$ git clone https://github.com/unikraft/summer-of-code-2021

$ cd summer-of-code-2021/content/en/docs/sessions/09-advanced-app-porting/

$ ls
demo/  images/  index.md/  sol/  work/
</code></pre><h3 id=01-add-extra-section-in-the-elf>01. Add Extra Section in the ELF</h3><p>In this task we will add a new section in the elf and we will define a series of macros.</p><p>Navigate to the <code>01-extrald</code> directory.
Copy <code>mycorelibrary</code> to the <code>lib</code> directory in <code>unikraft</code> and the two applications in the <code>apps</code> directory.
Your working directory should look like this:</p><pre><code>workdir
|_______apps
|       |_______01-app
|       |_______02-app
|_______libs
|_______unikraft
        |_______lib
                |_______mycorelib
                |_______Makefile.uk
</code></pre><p>Edit the <code>Makefile.uk</code> from the <code>lib</code> directory and add the following:</p><pre><code>$(eval $(call _import_lib,$(CONFIG_UK_BASE)/lib/mycorelib))
</code></pre><p>Follow the TODOs from the sources and headers.
After solving all the TODOs compile both applications and run them.
Don&rsquo;t forget to <code>make menuconfig</code> to select <code>mycorelib</code> and the KVM platform.</p><h3 id=02-using-readelf>02. Using <code>readelf</code></h3><p>Use the <code>readelf</code> utility to see the section&rsquo;s address and size and check them with the program&rsquo;s output (like we did in the demo).</p><h3 id=03-searching-symbols>03. Searching Symbols</h3><p>Using the <code>grep</code> utility search the following and inspect the source code:</p><ol><li><code>struct vfsops</code>, <code>struct vnops</code>, <code>struct vfscore_fs_type</code></li><li><code>struct vnode</code>, <code>struct dentry</code>, <code>struct mount</code></li><li><code>sys_open</code> look especially for VOP macros.
How many operations does the open system call do?</li><li><code>vfscore_vget</code> can you figure it out what this function does?</li></ol><h3 id=04-myramfs-register-the-filesystem>04. MyRamfs. Register the Filesystem.</h3><p>In the following exercises, we will build step by step a simplified version of the ramfs library.
The first step is to register the filesystem into <code>vfscore</code>.</p><p>Navigate to the <code>04-05-06-myramfs</code> directory.
Copy <code>myramfs</code> directory to the <code>lib</code> directory in <code>unikraft</code> and the application in the <code>apps</code> directory.
Your working directory should look like this:</p><pre><code>workdir
|_______apps
|       |_______ramfs-app
|_______libs
|_______unikraft
        |_______lib
                |_______myramfs
                |_______vfscore
                |_______Makefile.uk
</code></pre><p>Edit the <code>Makefile.uk</code> from the <code>lib</code> directory and add the following:</p><pre><code>$(eval $(call _import_lib,$(CONFIG_UK_BASE)/lib/myramfs))
</code></pre><p>Now we need to make our library configurable from <code>vfscore</code>, for this we will need to edit the <code>Config.uk</code> file in the <code>vfscore</code> directory.</p><p>First we will add the configuration menu:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#ce5c00;font-weight:700>...</span>
<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>LIBVFSCORE_AUTOMOUNT_ROOTFS</span>
        <span style=color:#000>choice</span> <span style=color:#000>LIBVFSCORE_ROOTFS</span>
        <span style=color:#000>prompt</span> <span style=color:#4e9a06>&#34;Default root filesystem&#34;</span>

                <span style=color:#000>config</span> <span style=color:#000>LIBVFSCORE_ROOTFS_RAMFS</span>
                <span style=color:#204a87;font-weight:700>bool</span> <span style=color:#4e9a06>&#34;RamFS&#34;</span>
                <span style=color:#204a87;font-weight:700>select</span> <span style=color:#000>LIBRAMFS</span>

<span style=display:block;width:100%;background-color:#dfdfdf>                <span style=color:#000>config</span> <span style=color:#000>LIBVFSCORE_ROOTFS_MYRAMFS</span>
</span><span style=display:block;width:100%;background-color:#dfdfdf>                <span style=color:#204a87;font-weight:700>bool</span> <span style=color:#4e9a06>&#34;My-ramfs&#34;</span>
</span><span style=display:block;width:100%;background-color:#dfdfdf>                <span style=color:#204a87;font-weight:700>select</span> <span style=color:#000>LIBMYRAMFS</span>
</span><span style=color:#ce5c00;font-weight:700>...</span></code></pre></div><p>If we run now <code>make menuconfig</code> in the application <code>ramfs-app</code> we should see our library under the <code>vfscore configuration</code>:</p><p><img src=./images/vfscore_config_myramfs.png alt=vfscore_config_myramfs></p><p>The second fundamental step is to add the following line to the same <code>Config.uk</code> file:<div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go> <span style=color:#a40000>#</span> <span style=color:#000>Hidden</span> <span style=color:#000>configuration</span> <span style=color:#000>option</span> <span style=color:#000>that</span> <span style=color:#000>gets</span> <span style=color:#000>automatically</span> <span style=color:#000>filled</span>
        <span style=color:#a40000>#</span> <span style=color:#000>with</span> <span style=color:#000>the</span> <span style=color:#000>selected</span> <span style=color:#000>filesystem</span> <span style=color:#000>name</span>
        <span style=color:#000>config</span> <span style=color:#000>LIBVFSCORE_ROOTFS</span>
        <span style=color:#204a87;font-weight:700>string</span>
        <span style=color:#204a87;font-weight:700>default</span> <span style=color:#4e9a06>&#34;ramfs&#34;</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>LIBVFSCORE_ROOTFS_RAMFS</span>
<span style=display:block;width:100%;background-color:#dfdfdf>        <span style=color:#204a87;font-weight:700>default</span> <span style=color:#4e9a06>&#34;myramfs&#34;</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>LIBVFSCORE_ROOTFS_MYRAMFS</span>
</span>        <span style=color:#204a87;font-weight:700>default</span> <span style=color:#4e9a06>&#34;9pfs&#34;</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>LIBVFSCORE_ROOTFS_9PFS</span>
        <span style=color:#204a87;font-weight:700>default</span> <span style=color:#4e9a06>&#34;initrd&#34;</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>LIBVFSCORE_ROOTFS_INITRD</span>
        <span style=color:#204a87;font-weight:700>default</span> <span style=color:#000>LIBVFSCORE_ROOTFS_CUSTOM_ARG</span> <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000>LIBVFSCORE_ROOTFS_CUSTOM</span></code></pre></div></p><p>This will fill the <code>CONFIG_LIBVFSCORE_ROOTFS</code> with the string <code>myramfs</code>.</p><p>Now that we&rsquo;ve done our setup, let&rsquo;s get started.
Follow TODOs 1-4 in myramfs_vnops.c and myramfs_vfsops.c.
Now, when you run <code>make menuconfig</code> in the app be sure you use the <code>myramfs</code>library and also check the debug library.
If everything is fine you should get a similar output:</p><p><img src=./images/04_output.png alt=04_output></p><div class="alert alert-primary" role=alert><h4 class=alert-heading>Note</h4>Try to rename the filesystem in the <code>vfscore_fs_type</code> structure. What happens? Look for the <code>fs_getfs</code> function.</div><h3 id=05-myramfs-building-the-structure>05. MyRamfs. Building the Structure</h3><p>The <code>ramfs</code> library has a tree-like structure, as we saw in the section dedicated to it.
Our library will be in the form of a list for ease of use.
We&rsquo;ll use the generic lists given before to make it even prettier.
This indicates that only ordinary files, not directories, are supported.</p><p>For this task we will still look in the files <code>myramfs_vfsops.c</code> and <code>myramfs_vnops.c</code> and we will perform the TODOs from 5 to 13.
But first we recommend you to look at the <code>struct myramfs_node</code> which is in the <code>myramfs.h</code> file.</p><p>To test this task go back to the <code>ramfs-app</code> and build it again (make sure to properclean).
If you solved everything correctly the output should look like this:</p><p><img src=./images/05_output.png alt=05_output></p><h3 id=06-myramfs-reading-and-writing>06. MyRamfs. Reading and Writing</h3><p>In today&rsquo;s last exercise we will really do what is done most with files, we write and read. Follow TODOs 14, 15 from <code>myramfs_vnops.c</code>.</p><div class="alert alert-primary" role=alert><h4 class=alert-heading>HINT</h4>Check <code>struct uio</code> structure and the <code>vfscore_uiomove</code> routine.</div><h3 id=07-give-us-feedback>07. Give Us Feedback</h3><p>We want to know how to make the next sessions better.
For this we need your <a href=https://docs.google.com/forms/d/1FW1mzu19G7A1okzkssNctjgMUDsUyMvIvDvIO1Yr6Xo/edit>feedback</a>.</p></div><div class=td-content style=page-break-before:always><h1 id=pg-9026b735a1faa018402aa9ac7ce1ebd9>12 - Session 10: High Performance</h1><h2 id=requirements-and-reminders>Requirements and Reminders</h2><p>For this session, you need Unikraft companion command-line tool <a href=https://github.com/unikraft/kraft><code>kraft</code></a> and the following extra tools:</p><ul><li><code>qemu-kvm</code></li><li><code>qemu-system-x86_64</code></li><li><code>bridge-utils</code></li><li><code>ifupdown</code></li><li><code>tshark</code></li><li><code>tcpdump</code></li></ul><p>To install on Debian/Ubuntu use the following command:</p><pre><code>$ sudo apt-get -y install qemu-kvm qemu-system-x86 sgabios socat bridge-utils ifupdown tshark tcpdump
</code></pre><h3 id=configuring-building-and-running-unikraft>Configuring, Building and Running Unikraft</h3><p>At this stage, you should be familiar with the steps of configuring, building and running any application within Unikraft and know the main parts of the architecture.
Below you can see a list of the commands you have used so far.</p><table><thead><tr><th>Command</th><th>Description</th></tr></thead><tbody><tr><td><code>kraft list</code></td><td>Get a list of all components that are available for use with kraft</td></tr><tr><td><code>kraft up -t &lt;appname> &lt;your_appname></code></td><td>Download, configure and build existing components into unikernel images</td></tr><tr><td><code>kraft run</code></td><td>Run resulting unikernel image</td></tr><tr><td><code>kraft init -t &lt;appname></code></td><td>Initialize the application</td></tr><tr><td><code>kraft configure</code></td><td>Configure platform and architecture (interactive)</td></tr><tr><td><code>kraft configure -p &lt;plat> -m &lt;arch></code></td><td>Configure platform and architecture (non-interactive)</td></tr><tr><td><code>kraft build</code></td><td>Build the application</td></tr><tr><td><code>kraft clean</code></td><td>Clean the application</td></tr><tr><td><code>kraft clean -p</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make clean</code></td><td>Clean the application</td></tr><tr><td><code>make properclean</code></td><td>Clean the application, fully remove the <code>build/</code> folder</td></tr><tr><td><code>make distclean</code></td><td>Clean the application, also remove <code>.config</code></td></tr><tr><td><code>make menuconfig</code></td><td>Configure application through the main menu</td></tr><tr><td><code>make</code></td><td>Build configured application (in <code>.config</code>)</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image></code></td><td>Start the unikernel</td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -e &lt;directory></code></td><td>Start the unikernel with a filesystem mapping of <code>fs0</code> id from <code>&lt;directory></code></td></tr><tr><td><code>qemu-guest -k &lt;kernel_image> -g &lt;port> -P</code></td><td>Start the unikernel in debug mode, with GDB server on port <code>&lt;port></code></td></tr></tbody></table><h2 id=overview>Overview</h2><p>Welcome to the last session of the Unikraft Summer of Code!
In this session, we will introduce to you how to develop highly specialized and performance-optimized unikernels with Unikraft.
So far, we have focused on applications and POSIX compatibility;
where it is important to provide the same set of APIs and system calls that your application uses on its original environment (i.e., as a Linux user space application).
We achieve this by stacking multiple micro-libraries which then assemble together to form a combination of various necessary &ldquo;higher-level&rdquo; APIs .</p><p>In the context of network-based applications, we would typically develop network functionality based on <a href=https://linux.die.net/man/7/socket><code>sockets</code></a>.
This requires the following library stack being available within Unikraft for the <code>socket</code> (and friends) API to interface with the virtual Network Interface Card (vNIC):</p><pre><code> .-------------------------.
(     Socket application    )
 '-------------------------'
              |
              V
+---------------------------+
|         libvfscore        |
+---------------------------+
+---------------------------+
|          liblwip          |
+---------------------------+
+---------------------------+
|        libuknetdev        |
+---------------------------+
+---------------------------+
|        libkvmplat         |
+---------------------------+
              |
              V
 .-------------------------.
( Virtual Network Interface )
 '-------------------------'
</code></pre><p>Especially the Virtual File System (VFS) layer (provided by <a href=https://github.com/unikraft/unikraft/tree/staging/lib/vfscore><code>libvfscore</code></a>) and the TCP/IP network stack (provided by <a href=github.com/unikraft/lib-lwip/><code>liblwip</code></a>) are complex subsystems which are potentially introduce additional overheard.</p><p>For high-performance Network Functions (NFs), it is often more efficient to bypass any OS component and interact with the driver or hardware as directly; cutting out any indirection.
A known framework in the NFV arena is <a href=https://www.dpdk.org/>Intel DPDK</a> which operates network card drivers in Linux user space.
It operates in user space in order to avoid interactions with the kernel which comes with performance penalties resulting from additional permission checks.
Despite this advantage in performance, you still need to maintain and operate a complete Linux environment in production deployments.
In the case with Unikraft, we can configure the libraries to be minimal and can, similar to Intel DPDK, directly develop our NF on top of network drivers.</p><p>In this scenario, our library stack does look like the following:</p><pre><code> .-------------------------.
(    High performance NF    )
 '-------------------------'
              |
              V
+---------------------------+
|        libuknetdev        |
+---------------------------+
+---------------------------+
|        libkvmplat         |
+---------------------------+
              |
              V
 .-------------------------.
( Virtual Network Interface )
 '-------------------------'
</code></pre><p>In the following tutorial, you will develop a simple, high performance network packet generator.
This tutorial will guide you through various options and possibilities which can help you during the development of more complex NFs with Unikraft.</p><h2 id=practical-work>Practical Work</h2><h3 id=support-files>Support Files</h3><p>Session support files are available <a href=https://github.com/unikraft/summer-of-code-2021>in the USoC'21 repository</a>.
If you already cloned the repository, update it and enter the session directory:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ <span style=color:#204a87>cd</span> path/to/repository/clone
$ git pull --rebase
$ <span style=color:#204a87>cd</span> content/en/docs/sessions/10-high-performance/
$ ls
</code></pre></div><pre><code>index.md  sol/
</code></pre><p>If you haven&rsquo;t cloned the repository yet, clone it and enter the session directory:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash>$ git clone https://github.com/unikraft/summer-of-code-2021
$ <span style=color:#204a87>cd</span> summer-of-code-2021/content/en/docs/sessions/10-high-performance/
$ ls
</code></pre></div><pre><code>index.md  sol/
</code></pre><h3 id=01-getting-started>01. Getting Started</h3><p>For this session, a template has been provided which contains some basic building blocks (like crafting a IPv4/UDP packet) for our high performance NF.
Start by making a copy of it:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ cp -a sol/pktgen path/to/your/copy
</code></pre></div><p>Go into your copy and initialize it with <code>kraft</code>:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ <span style=color:#204a87>cd</span> path/to/your/copy
$ kraft list update
$ kraft list pull
$ kraft configure
$ kraft build
</code></pre></div><p>Check if the image runs and prints the Unikraft banner:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kraft run
</code></pre></div><h3 id=02-bring-up-a-network-interface>02. Bring Up a Network Interface</h3><p>We can directly interact with network device drivers which are typically provided by each platform using Unikraft&rsquo;s internal <a href=https://github.com/unikraft/unikraft/tree/staging/lib/uknetdev><code>uknetdev</code></a> API.
First, make sure that we state a dependency of our application to <code>libuknetdev</code>.
To do this, open <code>Config.uk</code> and place the following dependency accordingly in the file (if not already there): <code>depends on LIBUKNETDEV</code>.</p><p>This dependency gives us access to the <code>&lt;uk/netdev.h></code> and <code>&lt;uk/netbuf.h></code> headers which are available within the <code>libuknetdev</code> library:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ ls <span style=color:#ce5c00;font-weight:700>[</span>PATH-TO-UNIKRAFT<span style=color:#ce5c00;font-weight:700>]</span>/lib/uknetdev/include/uk/
</code></pre></div><p>As described in <code>&lt;uk/netdev.h></code>, bringing up a network interface means transition it through configuration states before we can use the interface for sending packets:</p><ol><li><p>Check that the platform detected network interfaces.
<code>uk_netdev_count()</code> should tell us how many interfaces are available.
Please note that you should also check that the network driver is enabled in the platform configuration.
For this session we are interested in <code>virtio-net</code> within <code>KVM guest</code>.</p></li><li><p>Retrieve <code>struct uk_netdev *</code> for further API interaction from a netdev number (they are just incrementally going upwards).
We take the first interface, so our device number should be <code>0</code>.</p></li><li><p>Configure the device, which essentially indicate how many receive and transmit queues the device should provide.
In SMP scenarios, you typically configure as many queues as CPU-cores or handler threads you have been allocated.</p><p><strong>Note:</strong> Not every driver or network card can support multiple queues.</p><p>There is a query interface where you can check for queues are supported by your device.
For simplicity, we are going to configure just one queue for each direction.
This is supported by all drivers.
Although we are going to send packets only, we still have to also configure one receive queue (zero transmit or receive queues is not possible with our virtio driver):</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/* Device configuration */</span>
<span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_netdev_conf</span> <span style=color:#000>ifconf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
    <span style=color:#000;font-weight:700>.</span><span style=color:#000>nb_rx_queues</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>,</span>
    <span style=color:#000;font-weight:700>.</span><span style=color:#000>nb_tx_queues</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>1</span>
<span style=color:#000;font-weight:700>};</span>
</code></pre></div></li><li><p>Configure the transmit queue <code>0</code> and the receive queue <code>0</code>.
This step allows us to specify the size for each queue and which allocators should be used for internal queue descriptors and receive buffers.
We will take the default allocator for those items.
You can define a dummy allocation function for the receive buffers, because we are not interested in receiving for now.
We will also let the driver to choose an optimal queue size for us.
You can hand-over <code>0</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/* Dummy receive buffer allocation function that is called by the driver */</span>
<span style=color:#204a87;font-weight:700>static</span> <span style=color:#000>uint16_t</span> <span style=color:#000>dummy_alloc_rxpkts</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>argp</span> <span style=color:#000>__unused</span><span style=color:#000;font-weight:700>,</span>
             <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_netbuf</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>pkts</span><span style=color:#000;font-weight:700>[]</span> <span style=color:#000>__unused</span><span style=color:#000;font-weight:700>,</span>
             <span style=color:#000>uint16_t</span> <span style=color:#000>count</span> <span style=color:#000>__unused</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>

<span style=color:#8f5902;font-style:italic>/* Receive queue configuration */</span>
<span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_netdev_rxqueue_conf</span> <span style=color:#000>rxqconf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
     <span style=color:#000;font-weight:700>.</span><span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_alloc_get_default</span><span style=color:#000;font-weight:700>(),</span>
     <span style=color:#000;font-weight:700>.</span><span style=color:#000>alloc_rxpkts</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>dummy_alloc_rxpkts</span>
<span style=color:#000;font-weight:700>};</span>

<span style=color:#8f5902;font-style:italic>/* Transmit queue configuration */</span>
<span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_netdev_txqueue_conf</span> <span style=color:#000>txqconf</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000;font-weight:700>{</span>
     <span style=color:#000;font-weight:700>.</span><span style=color:#000>a</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_alloc_get_default</span><span style=color:#000;font-weight:700>()</span>
<span style=color:#000;font-weight:700>};</span>
</code></pre></div></li><li><p>Start the network interface.
If successful, the device is now ready to process network traffic.
You will now have the ability to also enable interrupt mode for each queue individually and change the promiscuous setting for the interface.
Because we will operate in <em>polling mode</em> to achieve the highest possible performance, we should not change any interrupt settings.
We also do not need promiscuous mode because we will put the device&rsquo;s hardware address as sender address into our generated traffic.
It is probably a good moment to print on the console this mac address and store it for later.
We will need it to craft our first network packet.</p></li></ol><p>For easier development of this state transition, we recommend to enable all kernel message types and optionally debug message (go to <code>Library Configuration</code> -> <code>ukbedug</code>).
Many of these steps should produce some kernel output so that you can quicker see if something got misconfigured.</p><p>In order to test your code you should run the guest with one interface attached.
For this purpose we need to create a network bridge on your Linux host first (we just need to do this once):</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=color:#8f5902;font-style:italic># Ensure you have permissions to change stp</span>
sudo sysctl -w net.bridge.bridge-nf-call-arptables<span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span>

<span style=color:#8f5902;font-style:italic># Create bridge &#39;usocbr0&#39;</span>
brctl addbr usocbr0
brctl setfd usocbr0 <span style=color:#0000cf;font-weight:700>0</span>
brctl sethello usocbr0 <span style=color:#0000cf;font-weight:700>0</span>
brctl stp usocbr0 off
ifconfig usocbr0 0.0.0.0 up

<span style=color:#8f5902;font-style:italic># Disable packet filtering on bridge interfaces</span>
<span style=color:#204a87>echo</span> <span style=color:#0000cf;font-weight:700>0</span> &gt; /proc/sys/net/bridge/bridge-nf-call-arptables
<span style=color:#204a87>echo</span> <span style=color:#0000cf;font-weight:700>0</span> &gt; /proc/sys/net/bridge/bridge-nf-call-iptables
<span style=color:#204a87>echo</span> <span style=color:#0000cf;font-weight:700>0</span> &gt; /proc/sys/net/bridge/bridge-nf-call-ip6tables
</code></pre></div><p>As soon as your unikernel image builds, the guest can then be started with:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ kraft run -b usocbr0
</code></pre></div><h3 id=03-say-hello-on-the-wire>03. Say Hello on the Wire</h3><p>In this chapter we are going to send out our first packet.
We provide you a function through the header <a href=https://github.com/unikraft/summer-of-code-2021/blob/main/content/en/docs/sessions/10-high-performance/sol/pktgen/genpkt.h><code>"genpkt.h"</code></a> which generates an Ethernet-IPv4-UDP frame with a dummy payload for a given size: <code>genpkt_udp4()</code>.
In the same header we also provide you the short-hand version <code>genpkt_usoc21()</code> which has some parameters, like the IP addresses, pre-filled.</p><p>The only items that the function still wants to know from you are the following:</p><ul><li><p><code>a</code>: Allocator where the packet should be allocated from.
Use <a href=https://github.com/unikraft/unikraft/blob/64870e20031aad230973b205ba80ff70a454c924/lib/ukalloc/include/uk/alloc.h#L135-L138><code>uk_alloc_get_default()</code></a> for now.</p></li><li><p><code>bufalign</code>: An alignment requirement for the packet buffer containing the packet.
Some network drivers require specific alignments.
You find this value after querying the device with <a href=https://github.com/unikraft/unikraft/blob/104fed122c41cbdedb03b701c19c38d4974cca34/lib/uknetdev/netdev.c#L217-L236><code>uk_netdev_info_get()</code></a> on <a href=https://github.com/unikraft/unikraft/blob/104fed122c41cbdedb03b701c19c38d4974cca34/lib/uknetdev/include/uk/netdev_core.h#L141-L150><code>struct uk_netdev_info</code></a> as <code>ioalign</code>.</p></li><li><p><code>headroom</code>: Reserved bytes at the beginning of the packet buffer and before the packet data starts.
Some drivers require this in order to do another encapsulation on transmit (like virtio).
You find this value on the <code>struct uk_netdev_info</code> as <code>nb_encap_tx</code>.</p></li><li><p><code>pktlen</code>: The size of the Ethernet frame (excluding CRC, FCS, SFD, and preamble) that should be generated.
According to the <a href=https://www.ietf.org/rfc/rfc1042.txt>Ethernet specification</a> the smallest packet size can be created with <code>60</code> and the biggest with <code>1518</code>.
The most interesting are minimum sized packets because those stress software and hardware components the most.
For each packet, the header needs to be parsed and the packet needs to get forwarded to the next processing layer of the stack.
As smaller the packets are, the more load with parsing and handling packet buffers occurs. So, please take <code>60</code> ;-)</p></li><li><p><code>mac_src</code>: The hardware address of our interface where we are going to send the packet out.</p></li></ul><p>The function returns you a <code>netbuf</code> that can be send out with <a href=https://github.com/unikraft/unikraft/blob/4e54f09a3930f0482a90903a5750c036346c7c06/lib/uknetdev/include/uk/netdev.h#L471-L508><code>uk_netdev_tx_one()</code></a>.
Please check the resulting status code for success and free the packet with <a href=https://github.com/unikraft/unikraft/blob/4e54f09a3930f0482a90903a5750c036346c7c06/lib/uknetdev/netbuf.c#L220-L254><code>uk_netbuf_free()</code></a> in case of failures.
The driver will do the free operation itself only if a packet got correctly enqueued to the device and sent.
In such a case, you aren&rsquo;t allowed to touch this packet anymore after sending;
so your transmit code should look like this:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>	<span style=color:#8f5902;font-style:italic>/* &lt;...&gt; */</span>

	<span style=color:#000>status</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_netdev_tx_one</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>netif</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>uk_netdev_status_successful</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>status</span><span style=color:#000;font-weight:700>))</span> <span style=color:#000;font-weight:700>{</span>
		<span style=color:#000>uk_pr_err</span><span style=color:#000;font-weight:700>(</span><span style=color:#4e9a06>&#34;netdev%u: Failed to send packet %p</span><span style=color:#4e9a06>\n</span><span style=color:#4e9a06>&#34;</span><span style=color:#000;font-weight:700>,</span>
			  <span style=color:#000>uk_netdev_id_get</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>netif</span><span style=color:#000;font-weight:700>),</span> <span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
		<span style=color:#000>uk_netbuf_free</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
	<span style=color:#000;font-weight:700>}</span>

	<span style=color:#8f5902;font-style:italic>/* Do not touch pkt here anymore */</span>
	<span style=color:#8f5902;font-style:italic>/* &lt;...&gt; */</span>
</code></pre></div><p>In order to see if everything works, attach <code>tshark</code> or <code>tcpdump</code> on your Linux host to <code>usocbr0</code> on a second terminal:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh>$ tshark -i usocbr0
</code></pre></div><p>Whenever you launch your unikernel, you should be able to see the UDP packet:</p><pre><code>    3 1.050213439 192.168.128.1 → 192.168.128.254 UDP 60 5001 → 5001 Len=18
</code></pre><h3 id=04-dont-stop>04. Don&rsquo;t Stop</h3><p>Now let us send as much as we can with the current implementation.
You can simply loop forever over packet generation and sending.
You may notice that we get too many messages on the console that slow us down.
Try disabling debug messages and all kernel messages except the critical ones.</p><p><strong>Note</strong>: You should be able to terminate your unikernel with <code>CTRL</code>+<code>C</code> when you launched it with <code>kraft</code> or <code>qemu-guest</code>.</p><h3 id=05-how-fast-are-we>05. How Fast Are We?</h3><p>It is now interesting to understand at which speed we are generating.
For this purpose we prepared a little function in <a href=https://github.com/unikraft/summer-of-code-2021/blob/main/content/en/docs/sessions/10-high-performance/sol/pktgen/netspeed.h><code>"netspeed.h"</code></a> that computes the packet rate (packets/sec) and current bandwidth (MBit/s): <a href=https://github.com/unikraft/summer-of-code-2021/blob/main/content/en/docs/sessions/10-high-performance/sol/pktgen/netspeed.h#L93-L112><code>print_netspeed()</code></a>.</p><p>Declare before your loop the following two variables:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#000>uint64_t</span> <span style=color:#000>total_nb_pkts</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* total number of pkts successfully sent */</span>
<span style=color:#000>uint64_t</span> <span style=color:#000>total_nb_bytes</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* total number of bytes successfully sent */</span>
</code></pre></div><p>Whenever a packet was successfully sent, we will simply increment <code>total_nb_pkts</code> and add the sent bytes <code>total_nb_bytes</code> counters.
In order to see a bandwidth computation that is comparable with physical Ethernet speeds, we have to additionally add the number of bytes (=<code>24</code>) for CRC, FCS, SFD, and preamble to each accounted packet size:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>	<span style=color:#000>status</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_netdev_tx_one</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>netif</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
	<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>uk_netdev_status_successful</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>status</span><span style=color:#000;font-weight:700>))</span> <span style=color:#000;font-weight:700>{</span>
		<span style=color:#8f5902;font-style:italic>/* success */</span>
		<span style=color:#000>total_nb_pkts</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
		<span style=color:#000>total_nb_bytes</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#0000cf;font-weight:700>60</span> <span style=color:#8f5902;font-style:italic>/* pktlen */</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>24</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#000;font-weight:700>}</span> <span style=color:#204a87;font-weight:700>else</span> <span style=color:#000;font-weight:700>{</span>
		<span style=color:#8f5902;font-style:italic>/* failed */</span>
		<span style=color:#000>uk_netbuf_free</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
	<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>By having this instrumentation, we could now just print the packet rate and bandwidth at every loop iteration with:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>	<span style=color:#000>print_netspeed</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>total_nb_pkts</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>total_nb_bytes</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p>The problem is that printing is extremely expensive.
This is because it happens synchronously in Unikraft, so the CPU can not do anything else while waiting for the console to finish its operation.
Additionally, for computation, the clock is accessed to measure a time delta, which is also an expensive operation.
In general, this means that we do not want this function to be called very often.
The cheapest option is to call this print function every <code>n</code>th sent packet.
We could do a cheap modulo operation by using a bitmask, for example:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>		<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>((</span><span style=color:#000>total_nb_pkts</span> <span style=color:#ce5c00;font-weight:700>&amp;</span> <span style=color:#0000cf;font-weight:700>0x3fffff</span><span style=color:#000;font-weight:700>)</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>0x0</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
			<span style=color:#000>print_netspeed</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>total_nb_pkts</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>total_nb_bytes</span><span style=color:#000;font-weight:700>);</span>
		<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>You are able to adopt the mask <code>0x3fffff</code> in order to make printing more often or less often.</p><ul><li>Faster: <code>0x1fffff</code>, <code>0x0fffff</code>, <code>0x07ffff</code>, <code>0x03ffff</code>, <code>0x01ffff</code>, &mldr;</li><li>Slower: <code>0x7fffff</code>, <code>0xffffff</code>, <code>0x1ffffff</code>, <code>0x3ffffff</code>, <code>0x7ffffff</code>, &mldr;</li></ul><p>Another option is to use another counter variable that is reset as soon as we print:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c>		<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>==</span> <span style=color:#0000cf;font-weight:700>1000</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
			<span style=color:#000>print_netspeed</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>total_nb_pkts</span><span style=color:#000;font-weight:700>,</span> <span style=color:#000>total_nb_bytes</span><span style=color:#000;font-weight:700>);</span>
			<span style=color:#000>count</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span>
		<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>Instrument your code with the two statistics variables and implement one of the mentioned printing mechanisms.
We should roughly print not faster than every <code>2</code> seconds, ideal are roughly <code>5</code>-<code>10</code> second intervals.
Remember, if your rate goes up or down with one of the following experiments, you may need to revisit your chosen value and adopt this <code>n</code>th packet parameter again.</p><h3 id=06-go-faster>06. Go Faster!</h3><p>Now, we have can go through some options to play around with.</p><p>Our overall goal is to get the packet rate of our packer generator as high as possible.
Note your rate and bandwidth before and, after each of the steps because we are going over this list twice, make sure that you do the steps non-destructive and keep the code of each step.</p><ol><li><p><strong>Try compiler options</strong>: Enable <em>Link Time Optimizations</em> (LTO) and <em>Dead Code Elimitation</em> (DCE) within <code>Build Options</code> of the <code>menuconfig</code>.
The compiler reconsiders a second time optimizations like function inlining while linking the final binary;
actually over the whole code base at once again.
These optimizations can have some visible effect on your packet rate.
Try it out!</p></li><li><p><strong>Don&rsquo;t waste packets</strong>: An obvious idea might be to keep packets which have failed to send.
We could save on packet generation time if we wouldn&rsquo;t free them.
We retry sending a packet until it finally leaves.
Our assumption is that the reason why it fails is that the transmit queue is full.
This approach can have positive but also likely negative effects.
The reason might be that some drivers may query their device more often to confirm that there is really no space left.
This causes the device to be busy answering instead of doing some actual work.
Try it out!</p></li><li><p><strong>Copy instead of create</strong>: Depending on how expensive the packet generation function is (e.g., because of an extra step computing a checksum), it could be cheaper to do a <code>memcpy</code> operation from a primordial packet buffer instead.
This means that we would run <code>genpkt_udp4()</code> just once and use as source for all cloned packets that are going to get transmitted.
We provide you such an extra routine with <code>"netbuf.h"</code>: <a href=https://github.com/unikraft/summer-of-code-2021/blob/main/content/en/docs/sessions/10-high-performance/sol/pktgen/netbuf.h#L45-L79><code>uk_netbuf_dup_single()</code></a> duplicates a given <code>netbuf</code> packet with <code>memcpy</code>.
Like <code>genpkt_udp4()</code>, it also needs the same extra information like <code>bufalign</code>, <code>headroom</code> for doing the allocation of the duplicate.
Try it out!</p></li><li><p><strong>Use a memory pool allocator</strong>: This is usually a very promising optimization.
Instead of using a general purpose allocator you can ensure that all <code>malloc</code> and <code>free</code> operations are satisfied within O(1).
If we deal with rates at maximum speed you want to have every job done as fast as possible.
A pool is basically a list of pre-allocated objects that have all the same size and an alignment property (if given).
On <code>malloc</code>, an object is returned out of this list;
on <code>free</code>, the object gets back to the free list.
For trying it out, continue with 06.1 and come back to point 5 of this list afterwards.</p></li><li><p><strong>Zero-copy with refcounting</strong>: Instead of all the optimization ahead, we could also simply increase the <code>netbuf</code> reference counter before sending.
This avoids that the packet being <code>free</code>&rsquo;d after sending and we would not need to allocate, copy, or generate a packet over and over again.
Every <code>free</code> operation will decrease the refcount until the reference counter becomes zero.
At this point the netbuf is really <code>free</code>&rsquo;d.
Unfortunately, we do not support this mode with network drivers which modify the packet for the transmission, like virtio-net does.
Unfortunately, it is not an option for virtio-net at the moment.
The transmit function will return an error.</p></li></ol><p>Besides these options, another common technique is using <strong>batching</strong>.
Instead of sending one packet at a time, you send multiple ones at once.
The advantage is that the device backend is notified just once per batch instead of for each packet.
This reduces communication overhead.
This feature is currently submitted as <a href=https://github.com/unikraft/unikraft/pull/243>PR#243</a> and will be added in the near future.</p><p>In order to understand better the bottlenecks in our implementation, we can isolate the code from the netdev device bottlenecks.
This is done by replacing the send operation with <code>uk_netbuf_free()</code>.
There we can assume that this means that every transmit operation works but this reveals more dominantly performance differences of the suggestions 1-5 ahead.
Go over the list again and note the new collected rates.
Which option results in the best performance?</p><p><strong>Recommendation</strong>: The pre-processor can help you switching between these two modes quickly:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>#if 0</span><span style=color:#8f5902;font-style:italic> /* &lt;-- toggle between these two blocks with 0 and 1 */
</span><span style=color:#8f5902;font-style:italic>	status = uk_netdev_tx_one(netif, 0, pkt);
</span><span style=color:#8f5902;font-style:italic>	if (uk_netdev_status_successful(status)) {
</span><span style=color:#8f5902;font-style:italic>		/* success */
</span><span style=color:#8f5902;font-style:italic>		total_nb_pkts += 1;
</span><span style=color:#8f5902;font-style:italic>		total_nb_bytes += 60 /* pktlen */ + 24;
</span><span style=color:#8f5902;font-style:italic>	} else {
</span><span style=color:#8f5902;font-style:italic>		/* failed */
</span><span style=color:#8f5902;font-style:italic>		uk_netbuf_free(pkt);
</span><span style=color:#8f5902;font-style:italic>	}
</span><span style=color:#8f5902;font-style:italic></span><span style=color:#8f5902;font-style:italic>#else
</span><span style=color:#8f5902;font-style:italic></span>	<span style=color:#000>uk_netbuf_free</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
	<span style=color:#8f5902;font-style:italic>/* always success */</span>
	<span style=color:#000>total_nb_pkts</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#000>total_nb_bytes</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#0000cf;font-weight:700>60</span> <span style=color:#8f5902;font-style:italic>/* pktlen */</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>24</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#8f5902;font-style:italic>#endif
</span></code></pre></div><h4 id=061-use-a-memory-pool>06.1. Use a memory pool</h4><p>We provide a pool allocator library with Unikraft: <code>libukallocpool</code>.
First of all, add a dependency to this library in your <code>Config.uk</code>:</p><pre><code>depends on LIBUKALLOCPOOL
</code></pre><p>This dependency makes the header <code>"&lt;uk/allocpool.h>"</code> (within <code>[PATH-TO-UNIKRAFT]/lib/ukallocpool/include/uk/</code>) available.</p><p>In order to allocate one pool, you call <code>uk_allocpool_alloc()</code> at your application startup.
The function will allocate the pool memory from a parent allocator.
This happens just during creation time for pre-allocating all the pool objects.</p><p>In our case this parent is the default allocator.
As <code>obj_len</code> you should choose <code>2048</code> because this is a big enough buffer to keep packet data and needed meta data.
<code>obj_align</code> should be again set to the alignment requirement of the device (<code>struct uk_netdev_info</code>-><code>ioalign</code>).
The <code>obj_count</code> argument should be big enough so that we do not run out of pool objects while sending.
You can try different values, start with <code>1024</code>.</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_allocpool</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>pool</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#000>pool</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_allocpool_alloc</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>uk_alloc_get_default</span><span style=color:#000;font-weight:700>(),</span> <span style=color:#0000cf;font-weight:700>1024</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>2048</span><span style=color:#000;font-weight:700>,</span>
                          <span style=color:#000>netdev_info</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ioalign</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p>In order to use the pool as allocator for <code>pktgen_udp4()</code> and <code>uk_netbuf_dup_single()</code>, you need to get the compatibility interface from libukallocpool:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_alloc</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>p</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#000>p</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_allocpool2ukalloc</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>pool</span><span style=color:#000;font-weight:700>);</span>
</code></pre></div><p><code>p</code> can then be handed over as normal allocator, like <code>uk_alloc_get_default()</code>.
<code>p</code> will always return 2048B objects as long as the malloc request is smaller or equal to the initialized <code>obj_len</code>.
Any bigger allocation request cannot be satisfied and libukallocpool is returning <code>NULL</code>.</p><h3 id=07-gimme-gimme-gimme>07. Gimme, gimme, gimme!</h3><p>With the last task you will implement a receive-only unikernel that measures the received traffic.
We keep busy polling for receive as well but you should implement a switching logic to switch between transmit and receive mode.
You can do this either with a configuration option (<code>Config.uk</code>) or with a kernel argument (see: <code>int argc, char *argv[]</code>).</p><p>Opening the network device is the same for receive except that we implement and hand-over a proper receive buffer allocation function.
This will replace <code>dummy_alloc_rxpkts()</code> when the receive mode is activated.
We can use the same pool allocator that we allocated for transmit during task 06.1.</p><p>Whenever the driver calls our callback, it tries to setup new receive buffers to receive new packet data.
When filled, these buffers are later returned back to us.
The function should look like this:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#8f5902;font-style:italic>/* global variables, fill-out before configuring the receive queue */</span>
<span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_netdev_info</span> <span style=color:#000>netdev_info</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_alloc</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>p</span><span style=color:#000;font-weight:700>;</span>

<span style=color:#000>uint16_t</span> <span style=color:#000>alloc_rxpkts</span><span style=color:#000;font-weight:700>(</span><span style=color:#204a87;font-weight:700>void</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>argp</span> <span style=color:#000>__unused</span><span style=color:#000;font-weight:700>,</span>
                      <span style=color:#204a87;font-weight:700>struct</span> <span style=color:#000>uk_netbuf</span> <span style=color:#ce5c00;font-weight:700>*</span><span style=color:#000>pkts</span><span style=color:#000;font-weight:700>[],</span>
                      <span style=color:#000>uint16_t</span> <span style=color:#000>count</span><span style=color:#000;font-weight:700>)</span>
<span style=color:#000;font-weight:700>{</span>
	<span style=color:#000>uint16_t</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>;</span>

	<span style=color:#8f5902;font-style:italic>/* fill out given array with allocated receive buffers */</span>
	<span style=color:#204a87;font-weight:700>for</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>=</span><span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>;</span> <span style=color:#000>i</span><span style=color:#ce5c00;font-weight:700>&lt;</span><span style=color:#000>count</span><span style=color:#000;font-weight:700>;</span> <span style=color:#ce5c00;font-weight:700>++</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>)</span> <span style=color:#000;font-weight:700>{</span>
	    <span style=color:#000>pkts</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>]</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_netbuf_alloc_buf</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>p</span><span style=color:#000;font-weight:700>,</span>
                                      <span style=color:#0000cf;font-weight:700>2048</span><span style=color:#000;font-weight:700>,</span>
                                      <span style=color:#000>netdev_info</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>ioalign</span><span style=color:#000;font-weight:700>,</span>
                                      <span style=color:#000>netdev_info</span><span style=color:#000;font-weight:700>.</span><span style=color:#000>nb_encap_rx</span><span style=color:#000;font-weight:700>,</span> <span style=color:#8f5902;font-style:italic>/* headroom for rx */</span>
                                      <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#204a87>NULL</span><span style=color:#000;font-weight:700>);</span>
	    <span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#ce5c00;font-weight:700>!</span><span style=color:#000>pkts</span><span style=color:#000;font-weight:700>[</span><span style=color:#000>i</span><span style=color:#000;font-weight:700>])</span>
			<span style=color:#204a87;font-weight:700>break</span><span style=color:#000;font-weight:700>;</span> <span style=color:#8f5902;font-style:italic>/* We ran out of memory */</span>
	<span style=color:#000;font-weight:700>}</span>
	<span style=color:#204a87;font-weight:700>return</span> <span style=color:#000>i</span><span style=color:#000;font-weight:700>;</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>Please note that this function expects that we initialized the global variables <code>netdev_info</code> and <code>p</code> before we configure the receive queue.</p><p>Now you should be able to build the polling receive loop based on the following snippet:</p><div class=highlight><pre style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=color:#000>status</span> <span style=color:#ce5c00;font-weight:700>=</span> <span style=color:#000>uk_netdev_rx_one</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>netdev</span><span style=color:#000;font-weight:700>,</span> <span style=color:#0000cf;font-weight:700>0</span><span style=color:#000;font-weight:700>,</span> <span style=color:#ce5c00;font-weight:700>&amp;</span><span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#204a87;font-weight:700>if</span> <span style=color:#000;font-weight:700>(</span><span style=color:#000>uk_netdev_status_successful</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>status</span><span style=color:#000;font-weight:700>))</span> <span style=color:#000;font-weight:700>{</span>
	<span style=color:#8f5902;font-style:italic>/* count packet and bytes and free received packet */</span>
	<span style=color:#000>nb_total_pkts</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#0000cf;font-weight:700>1</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#000>nb_total_bytes</span> <span style=color:#ce5c00;font-weight:700>+=</span> <span style=color:#000>pkt</span><span style=color:#ce5c00;font-weight:700>-&gt;</span><span style=color:#000>len</span> <span style=color:#ce5c00;font-weight:700>+</span> <span style=color:#0000cf;font-weight:700>24</span><span style=color:#000;font-weight:700>;</span>
	<span style=color:#000>uk_netbuf_free</span><span style=color:#000;font-weight:700>(</span><span style=color:#000>pkt</span><span style=color:#000;font-weight:700>);</span>
<span style=color:#000;font-weight:700>}</span>
</code></pre></div><p>In order to test your configuration, you can run 2 unikernels that are both connected to <code>usocbr0</code>.
One is transmitting traffic and the other one receives it.</p><h3 id=08-give-us-feedback>08. Give Us Feedback</h3><p>We want to know how to make the next sessions better.
For this we need your <a href=https://forms.gle/hrWo9iuNWg4NeZWt6>feedback</a>.
Thank you!</p></div></main></div></div><footer class="bg-dark py-5 row d-print-none"><div class="container-fluid mx-sm-5"><div class=row><div class="col-6 col-sm-4 text-xs-center order-sm-2"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Discord aria-label=Discord><a class=text-white target=_blank rel="noopener noreferrer" href=https://bit.ly/UnikraftDiscord><i class="fab fa-discord"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=Twitter aria-label=Twitter><a class=text-white target=_blank rel="noopener noreferrer" href=https://twitter.com/UnikraftSDK><i class="fab fa-twitter"></i></a></li></ul></div><div class="col-6 col-sm-4 text-right text-xs-center order-sm-3"><ul class="list-inline mb-0"><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=GitHub aria-label=GitHub><a class=text-white target=_blank rel="noopener noreferrer" href=https://github.com/unikraft/unikraft><i class="fab fa-github"></i></a></li><li class="list-inline-item mx-2 h3" data-toggle=tooltip data-placement=top title=LinkedIn aria-label=LinkedIn><a class=text-white target=_blank rel="noopener noreferrer" href=https://linkedin.com/company/unikraft-sdk><i class="fab fa-linkedin"></i></a></li></ul></div><div class="col-12 col-sm-4 text-center py-2 order-sm-2"><small class=text-white>&copy; 2021 Unikraft and Open-Source Contributors. All Rights Reserved</small></div></div></div></footer></div><script src=https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js integrity=sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49 crossorigin=anonymous></script><script src=https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js integrity=sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy crossorigin=anonymous></script><script src=/js/main.min.5c74b870c6953931a705f390a49c7e4c0a842ec5c83b24354758dd674343ed0d.js integrity="sha256-XHS4cMaVOTGnBfOQpJx+TAqELsXIOyQ1R1jdZ0ND7Q0=" crossorigin=anonymous></script></body></html>