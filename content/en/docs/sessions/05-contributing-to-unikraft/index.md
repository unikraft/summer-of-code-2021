---
title: "Session 05: Contributing to Unikraft"
linkTitle: "05. Contributing to Unikraft"
---

The focus of this session will be on porting new libraries to Unikraft and preparing them for upstreaming to the [main organization's github](https://github.com/unikraft).

Being a library operating system, the unikernels created using Unikraft is mainly a collection of internal and external libraries, alongside the ported application. 
As a consequence, a large library pool is mandatory in order to make this project compatible with as many applications as possible.

## 00. Reminders

From earlier sessions we saw that we can add an external library as dependency for an application by appending it to the `$LIBS` variable of the application's Makefile:
````
LIBS := $(UK_LIBS)/my_lib
````
Having done that, we can then select it in the menuconfig interface in order to be included in the build process.

Running an unikernel built for `kvm` can be done using the `qemu` command as follows:
````
qemu-guest-x86 -kernel unikraft_unikernel -nographic
````
The `-nographic` argument redirects the output generated by the unikernel to the console.

Also, in seesion 02 we saw that there are two types of libraries:
- internal: which define parts of the kernel(schedulers, file systems, etc.);
- external: which define user-space level functionalities.

## 01. Git Structure

The [organiation's github](https://github.com/unikraft) contains [the main Unikraft repository](https://github.com/unikraft/unikraft) and separate repositories for external libraries, as well as already ported apps.
In the previous sessions we saw that the Unikraft repository consists of internal libraries, platform code and architecture code.
It doesn't have any external dependencies, in contrast to the external libraries or applications, which can have external dependencies.

External libraries can have more specific purposes.
So, we can port a library even just for a single application.
The process of adding new internal libraries is almost the same as for external ones, so further we will focus on porting an external library.

Also, the main repository has [open issues](https://github.com/unikraft/unikraft/issues) to which you can contribute.
In general, this process is done by solving the issue on a separate branch and after that making a [pull request](https://docs.github.com/en/github/collaborating-with-pull-requests/proposing-changes-to-your-work-with-pull-requests/about-pull-requests) with your solution.

## 02. Example of External Library

Let's focus for now on a already ported library: [lib-libhogweed](https://github.com/unikraft/lib-libhogweed).
Let's examine its core components.
Open the sources present in `work/01-tut-porting/libs/libhogweed/` and follow the bookmars marked with `USOC_X`, where `X` is the index of the item in the list.

### Glue Code

In some cases, not all the dependencies of an external library are already present in the Unikraft project, so the solution is to add them manually, as glue code, to the library's sources.

Another situation when we need glue code is when the ported library comes with test modules, used for testing the library's functionalities.
The goal in this case is to wrap all the test modules into one single function. 
In this way, we can check the library integrity if we want so by just a single function call.
Moreover, we can create a test framework which can periodically check all of the ported libraries, useful especially for detecting if a new library will interfer with an already ported one.

Moving back to `libhogweed`, a practical example of the second case is the `run_all_libhogweed_tests(int v)` function from `work/01-tut-porting/libs/libhogweed/testutils_glue.c`, line #674, which calls every selected(we will see later how we can make selectable config variables) test module and exits with `EXIT_SUCCESS` only if it passes over all the tests.
For exposing this API, we should also make a header file with all of the test modules, as well as our wrapper function.
````
! Check `work/01-tut-porting/libs/libhogweed/include/testutils_glue.h`.
````

### Config.uk

Here are defined all the config variables, which will be visible in `make menuconfig`.
Also, these variables can be accesed from `Makefile.uk` or even from c sources, by including `"uk/config.h"`, using the prefix `CONFIG_`.

Moving to the source code, `work/01-tut-porting/libs/libhogweed/Config.uk`, we have:

1. The main variable of the library which acts like an identifier for it:
```
config LIBHOGWEED
	bool "libhogweed - Public-key algorithms"
	default n
```

2. We can also set another library's main variable, in this case `newlib`, which involves including it in the build process:
````
select LIBNEWLIBC
````

3. Creating an auxiliary menu, containing all the test cases:
````
menuconfig TESTSUITE
		bool "testsuite - tests for libhogweed"
		default n
		if TESTSUITE
			config TEST_X
				bool "test x functionality"
				default y
		endif
````
Each test case have its own variable in order to allow testing just some tests from the whole suite.

### Makefile.uk
1. Register the library to Unikraft's build system:
````
$(eval $(call addlib_s,libhogweed,$(CONFIG_LIBHOGWEED)))
````
As you can see, we are registering the library to Unikraft's build system only if the main library's config variable, `LIBHOGWEED`, is set.

2. Set the URL from where the library will be automatically downloaded at build time:
````
LIBHOGWEED_VERSION=3.6
LIBHOGWEED_URL=https://ftp.gnu.org/gnu/nettle/nettle-$(LIBHOGWEED_VERSION).tar.gz
````

3. Declare helper variables for the most used paths:
````
LIBHOGWEED_SUBDIR=nettle-$(LIBHOGWEED_VERSION)
LIBHOGWEED_EXTRACTED = $(LIBHOGWEED_ORIGIN)/nettle-$(LIBHOGWEED_VERSION)
````
There are some useful default variables:
- `$LIBNAME_ORIGIN`: represents the path where the original library is downloaded and extracted during the build process;
- `$LIBNAME_BASE`: represents the path of the ported library sources(the path appended to the `$LIBS` variable).

You can check all reserved variables in [the main documentation](http://docs.unikraft.org/developers-app.html#makefile-uk).

4. Set the locations where the headers are searched:
````
// including the path of the glue header added by us
LIBHOGWEED_COMMON_INCLUDES-y += -I$(LIBHOGWEED_BASE)/include
````
You should include the directories with the default library's headers as well as the directories with the glue headers created by you, if it's the case.

5. Add compile flags, used in general for suppresing some compile warnings and making the build proces neater:
````
LIBHOGWEED_SUPPRESS_FLAGS += -Wno-unused-parameter \
        -Wno-unused-variable -Wno-unused-value -Wno-unused-function \
        -Wno-missing-field-initializers -Wno-implicit-fallthrough \
        -Wno-sign-compare
LIBHOGWEED_CFLAGS-y   += $(LIBHOGWEED_SUPPRESS_FLAGS) \
        -Wno-pointer-to-int-cast -Wno-int-to-pointer-cast
LIBHOGWEED_CXXFLAGS-y += $(LIBHOGWEED_SUPPRESS_FLAGS)
````

6. Register the library's sources:
````
LIBHOGWEED_SRCS-y += $(LIBHOGWEED_EXTRACTED)/bignum.c
````

7. Register the library's tests:
````
ifeq ($(CONFIG_RSA_COMPUTE_ROOT_TEST),y)
LIBHOGWEED_SRCS-y += $(LIBHOGWEED_EXTRACTED)/testsuite/rsa-compute-root-test.c
LIBHOGWEED_RSA-COMPUTE-ROOT-TEST_FLAGS-y += -Dtest_main=rsa_compute_root_test
endif
````
There are situations when the test cases have each a `main()` function. In order to wrap all the tests into one single main function, we have to modify their main function name by using preprocessing symbols.

````
! A good practice is to include a test only if the config variable corresponding to that test is set.
````

You can read more about compile flags in [the main documentation](http://docs.unikraft.org/developers-app.html#makefile-uk).

8. This step is very customizabile, being like a script executed before starting to compile the unikernel.
In general, and in this case too, the libraries build their own config file through a provided executable, usually named `configure`:
````
$(LIBHOGWEED_EXTRACTED)/config.h: $(LIBHOGWEED_BUILD)/.origin
	$(call verbose_cmd,CONFIG,libhogweed: $(notdir $@), \
        cd $(LIBHOGWEED_EXTRACTED) && ./configure --enable-mini-gmp \
    )
LIBHOGWEED_PREPARED_DEPS = $(LIBHOGWEED_EXTRACTED)/config.h 

$(LIBHOGWEED_BUILD)/.prepared: $(LIBHOGWEED_PREPARED_DEPS)

UK_PREPARE += $(LIBHOGWEED_BUILD)/.prepared  
````
We can also do things like generating headers using the original building system, modify sources, etc.

## 03. Warm Up

Let's check the integrity of this library using its test suite through the exposed wrapper function.

For this task, you can use the setup from `work/01-tut-porting/`.
Complete the TODO's from `work/01-tut-porting/apps/app-libhogweed`: add the `libhogweed` library as dependency in its `Makefile` and call from `main.c` the function exposed by the library for running all its tests.

Modify the number of selected tests, rebuild, and run again the application.
````
! After you modify the selected tests, properclean the sources.
````

## 04. Practical Work

Moving to a more hands on experience, let's port a new library!
Let's suppose that we need kd tree support and that we found a C library that does what we need: http://nuclear.mutantstargoat.com/sw/kdtree/.
After downloading and inspecting this library, we can see that it also have a set of examples, which can be used by us to test if we ported this library properly.

Follow the TODO's from `work/02-task-porting/src/libs/kdtree/` and complete the porting process!

### 4.1. Declare Library Identifier

Let's start declaring a new config variable in the `Config.uk` file.
As stated before, this variable will represent the library's identifier.

### 4.2. Register it to the Build System

Now let's use it, in the `Makefile.uk` file.
If the variable declared previously is set, register the library to the build system.

### 4.3. Set its URL

Having it registered, set the URL from where it will be automatically downloaded at build time, and fetch it.

### 4.4 Helper Variables

Make a variable with the path of the default folder name obtained by extracting the library's archive.

### 4.5. Headers Location

Add the directory which contain the library's headers.

### 4.6. Add Sources

Add the sources of the library

### 4.7. Additional Requirements

Check the original `README` to see if the library needs to be configured first, and add the proper rule if so.

### 4.8. Intermediar Check

Until now we have registered the library and its sources, and if it doesn't have any more unresolved dependencies we should be able to compile an unikernel with it.
Using the `work/02-task-porting/src/apps/app-kdtree` application, try to build an unikernel with our ported library as dependency!

If needed, provide additional flags in order to suppress compile warnings generated by this library.
````
! HINTS
- You can leave the application's main empty.
- You can readme, but the solution isn't here.
````

### 4.9. Add Test Config Variables

Now let's make a wrapper for the provided test cases.
Decomment lines #7-#15 from `work/02-task-porting/src/libs/kdtree/Config.uk` and complete the `TODO_9` by adding new config variables for each test case.

### 4.10. Register Test Sources

Moving back to `work/02-task-porting/src/libs/kdtree/Makefile.uk`, register the c sources to the build system.

````
! Inspect the functions from the tests.
````

### 4.11. Wrapper Glue

Integrate all the test functions into a glue main.
Also, update the `work/02-task-porting/src/libs/kdtree/include/test_suite_glue.h` header accordingly.

````
! You can use `work/02-task-porting/src/libs/kdtree/test_suite_glue.c`.
````

### 4.12. Register Glue Code

Register both the glue test wrapper source and its header in `Makefile.uk`.

### 4.13. Final Verification

Test the resulted library by calling the test function from the `work/02-task-porting/src/apps/app-kdtree` application.


## 05. Summary

- We need a large library pool in order to make the Unikraft project compatible with as many applications as possible.
- There are also many ways in which you can contribute to the Unikraft project, and you can find them in [the issues section](https://github.com/unikraft/unikraft/issues) of the main repository.

## 06. Further Reading

You can get more in depth informations for the contributing process from [the main documentation](http://docs.unikraft.org/developers-app.html#).
